
airspy_m0.elf:     file format elf32-littlearm


Disassembly of section .text:

2000c000 <vector_table>:
2000c000:	e0 0f 00 20 55 e5 00 20 51 e5 00 20 d5 cc 00 20     ... U.. Q.. ... 
	...
2000c02c:	51 e5 00 20 00 00 00 00 00 00 00 00 51 e5 00 20     Q.. ........Q.. 
2000c03c:	51 e5 00 20 4d e5 00 20 d9 c1 00 20 4d e5 00 20     Q.. M.. ... M.. 
2000c04c:	00 00 00 00 4d e5 00 20 4d e5 00 20 4d e5 00 20     ....M.. M.. M.. 
2000c05c:	4d e5 00 20 25 db 00 20 4d e5 00 20 4d e5 00 20     M.. %.. M.. M.. 
2000c06c:	4d e5 00 20 4d e5 00 20 4d e5 00 20 4d e5 00 20     M.. M.. M.. M.. 
2000c07c:	4d e5 00 20 4d e5 00 20 4d e5 00 20 4d e5 00 20     M.. M.. M.. M.. 
2000c08c:	4d e5 00 20 4d e5 00 20 4d e5 00 20 4d e5 00 20     M.. M.. M.. M.. 
2000c09c:	4d e5 00 20 4d e5 00 20 4d e5 00 20 4d e5 00 20     M.. M.. M.. M.. 
2000c0ac:	4d e5 00 20 4d e5 00 20 4d e5 00 20 4d e5 00 20     M.. M.. M.. M.. 
2000c0bc:	4d e5 00 20                                         M.. 

2000c0c0 <usb_configuration_changed>:
      break;
  }
}

void usb_configuration_changed(usb_device_t* const device)
{
2000c0c0:	b508      	push	{r3, lr}
  if( device->configuration->number )
2000c0c2:	6903      	ldr	r3, [r0, #16]
2000c0c4:	6858      	ldr	r0, [r3, #4]
2000c0c6:	2800      	cmp	r0, #0
2000c0c8:	d001      	beq.n	2000c0ce <usb_configuration_changed+0xe>
  {
    /* RECEIVER ON */
    set_receiver_mode(get_receiver_mode());
2000c0ca:	f000 f915 	bl	2000c2f8 <get_receiver_mode>
  } else
  {
    /* RECEIVER OFF */
    /* Configuration number equal 0 means usb bus reset. */
    set_receiver_mode(RECEIVER_MODE_OFF);
2000c0ce:	f000 f8f9 	bl	2000c2c4 <set_receiver_mode>
  }
}
2000c0d2:	bd08      	pop	{r3, pc}

2000c0d4 <set_samplerate_m4>:
  }
}

void set_samplerate_m4(uint8_t conf_num)
{
  set_samplerate->conf = conf_num;
2000c0d4:	4b05      	ldr	r3, [pc, #20]	; (2000c0ec <set_samplerate_m4+0x18>)
  set_samplerate->cmd = SET_SAMPLERATE_CMD;
2000c0d6:	2201      	movs	r2, #1
  }
}

void set_samplerate_m4(uint8_t conf_num)
{
  set_samplerate->conf = conf_num;
2000c0d8:	6819      	ldr	r1, [r3, #0]
2000c0da:	7048      	strb	r0, [r1, #1]
  set_samplerate->cmd = SET_SAMPLERATE_CMD;
2000c0dc:	700a      	strb	r2, [r1, #0]
It also sets the local event register, see Power management (sleep mode, deep sleep mode of System Control Register for more details).
Instruction for Cortex M0, M3/M4 */
__attribute__ ((always_inline)) static inline void signal_sev(void)
{
  /* make sure all data transactions complete before next instruction is executed */
  __asm("dsb");
2000c0de:	f3bf 8f4f 	dsb	sy
  __asm("sev");
2000c0e2:	bf40      	sev
  signal_sev();

  /* Wait until M4 have finished executing the command (it set the data to 0) */
  while(1)
  {
    if(set_samplerate->raw == 0)
2000c0e4:	6808      	ldr	r0, [r1, #0]
2000c0e6:	2800      	cmp	r0, #0
2000c0e8:	d1fc      	bne.n	2000c0e4 <set_samplerate_m4+0x10>
      break;
  }
}
2000c0ea:	4770      	bx	lr
2000c0ec:	2000ec6c 	.word	0x2000ec6c

2000c0f0 <set_packing_m4>:

void set_packing_m4(uint8_t state)
{
  set_packing->conf = state;
2000c0f0:	4b05      	ldr	r3, [pc, #20]	; (2000c108 <set_packing_m4+0x18>)
  set_packing->cmd = SET_PACKING_CMD;
2000c0f2:	2201      	movs	r2, #1
  }
}

void set_packing_m4(uint8_t state)
{
  set_packing->conf = state;
2000c0f4:	6819      	ldr	r1, [r3, #0]
2000c0f6:	7048      	strb	r0, [r1, #1]
  set_packing->cmd = SET_PACKING_CMD;
2000c0f8:	700a      	strb	r2, [r1, #0]
It also sets the local event register, see Power management (sleep mode, deep sleep mode of System Control Register for more details).
Instruction for Cortex M0, M3/M4 */
__attribute__ ((always_inline)) static inline void signal_sev(void)
{
  /* make sure all data transactions complete before next instruction is executed */
  __asm("dsb");
2000c0fa:	f3bf 8f4f 	dsb	sy
  __asm("sev");
2000c0fe:	bf40      	sev
  
  signal_sev();
  
  while(1)
  {
    if(set_packing->raw == 0)
2000c100:	6808      	ldr	r0, [r1, #0]
2000c102:	2800      	cmp	r0, #0
2000c104:	d1fc      	bne.n	2000c100 <set_packing_m4+0x10>
      break;
  }
}
2000c106:	4770      	bx	lr
2000c108:	2000ec70 	.word	0x2000ec70

2000c10c <ADCHS_start>:
    set_receiver_mode(RECEIVER_MODE_OFF);
  }
}

void ADCHS_start(uint8_t conf_num)
{
2000c10c:	b538      	push	{r3, r4, r5, lr}

set_sample_r_params_t set_sample_r_params;

__attribute__ ((always_inline)) static inline void start_stop_adchs_m4(uint8_t conf_num, uint8_t command)
{
  start_adchs->conf = conf_num;
2000c10e:	4b20      	ldr	r3, [pc, #128]	; (2000c190 <ADCHS_start+0x84>)
    set_receiver_mode(RECEIVER_MODE_OFF);
  }
}

void ADCHS_start(uint8_t conf_num)
{
2000c110:	1c05      	adds	r5, r0, #0

set_sample_r_params_t set_sample_r_params;

__attribute__ ((always_inline)) static inline void start_stop_adchs_m4(uint8_t conf_num, uint8_t command)
{
  start_adchs->conf = conf_num;
2000c112:	6818      	ldr	r0, [r3, #0]
  start_adchs->cmd = command;
2000c114:	2201      	movs	r2, #1

set_sample_r_params_t set_sample_r_params;

__attribute__ ((always_inline)) static inline void start_stop_adchs_m4(uint8_t conf_num, uint8_t command)
{
  start_adchs->conf = conf_num;
2000c116:	7045      	strb	r5, [r0, #1]
  start_adchs->cmd = command;
2000c118:	7002      	strb	r2, [r0, #0]
It also sets the local event register, see Power management (sleep mode, deep sleep mode of System Control Register for more details).
Instruction for Cortex M0, M3/M4 */
__attribute__ ((always_inline)) static inline void signal_sev(void)
{
  /* make sure all data transactions complete before next instruction is executed */
  __asm("dsb");
2000c11a:	f3bf 8f4f 	dsb	sy
  __asm("sev");
2000c11e:	bf40      	sev
  signal_sev();

  /* Wait until M4 have finished executing the command (it set the data to 0) */
  while(1)
  {
    if(start_adchs->raw == 0)
2000c120:	6801      	ldr	r1, [r0, #0]
2000c122:	2900      	cmp	r1, #0
2000c124:	d1fc      	bne.n	2000c120 <ADCHS_start+0x14>
  start_stop_adchs_m4(conf_num, START_ADCHS_CMD);

  //enable_r820t_power();

  /* Re-Init I2C0 & I2C1 after PLL1 frequency is modified (for I2C1 also because PowerOn on R820T) */
  i2c0_init(airspy_conf->i2c_conf.i2c0_pll1_ls_hs_conf_val); /* Si5351C I2C peripheral */
2000c126:	4c1b      	ldr	r4, [pc, #108]	; (2000c194 <ADCHS_start+0x88>)
2000c128:	6823      	ldr	r3, [r4, #0]
2000c12a:	8b18      	ldrh	r0, [r3, #24]
2000c12c:	f002 f84e 	bl	2000e1cc <i2c0_init>
  i2c1_init(airspy_conf->i2c_conf.i2c1_pll1_hs_conf_val); /* R820T I2C peripheral */
2000c130:	6820      	ldr	r0, [r4, #0]
2000c132:	8b40      	ldrh	r0, [r0, #26]
2000c134:	f002 f864 	bl	2000e200 <i2c1_init>

  if((conf_num & AIRSPY_SAMPLERATE_CONF_ALT) == AIRSPY_SAMPLERATE_CONF_ALT)
2000c138:	b26a      	sxtb	r2, r5
2000c13a:	2a00      	cmp	r2, #0
2000c13c:	da12      	bge.n	2000c164 <ADCHS_start+0x58>
  {
    conf_num = conf_num & (~AIRSPY_SAMPLERATE_CONF_ALT);
    r820t_init(&airspy_conf->r820t_conf_rw, airspy_conf->airspy_m0_m4_alt_conf[conf_num].airspy_m0_conf.r820t_if_freq);
2000c13e:	207f      	movs	r0, #127	; 0x7f
2000c140:	6821      	ldr	r1, [r4, #0]
2000c142:	4005      	ands	r5, r0
2000c144:	2218      	movs	r2, #24
2000c146:	4355      	muls	r5, r2
2000c148:	1c08      	adds	r0, r1, #0
2000c14a:	3104      	adds	r1, #4
2000c14c:	6fcb      	ldr	r3, [r1, #124]	; 0x7c
2000c14e:	3048      	adds	r0, #72	; 0x48
2000c150:	1959      	adds	r1, r3, r5
2000c152:	6909      	ldr	r1, [r1, #16]
2000c154:	f001 f820 	bl	2000d198 <r820t_init>
    r820t_set_if_bandwidth(&airspy_conf->r820t_conf_rw, airspy_conf->airspy_m0_m4_alt_conf[conf_num].airspy_m0_conf.r820t_if_bw);
2000c158:	6824      	ldr	r4, [r4, #0]
2000c15a:	1c20      	adds	r0, r4, #0
2000c15c:	3404      	adds	r4, #4
2000c15e:	3048      	adds	r0, #72	; 0x48
2000c160:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
2000c162:	e00d      	b.n	2000c180 <ADCHS_start+0x74>
  }else
  {
    r820t_init(&airspy_conf->r820t_conf_rw, airspy_conf->airspy_m0_m4_conf[conf_num].airspy_m0_conf.r820t_if_freq);
2000c164:	2318      	movs	r3, #24
2000c166:	6821      	ldr	r1, [r4, #0]
2000c168:	435d      	muls	r5, r3
2000c16a:	6f8a      	ldr	r2, [r1, #120]	; 0x78
2000c16c:	1c08      	adds	r0, r1, #0
2000c16e:	1951      	adds	r1, r2, r5
2000c170:	3048      	adds	r0, #72	; 0x48
2000c172:	6909      	ldr	r1, [r1, #16]
2000c174:	f001 f810 	bl	2000d198 <r820t_init>
    r820t_set_if_bandwidth(&airspy_conf->r820t_conf_rw, airspy_conf->airspy_m0_m4_conf[conf_num].airspy_m0_conf.r820t_if_bw);
2000c178:	6824      	ldr	r4, [r4, #0]
2000c17a:	1c20      	adds	r0, r4, #0
2000c17c:	6fa3      	ldr	r3, [r4, #120]	; 0x78
2000c17e:	3048      	adds	r0, #72	; 0x48
2000c180:	195d      	adds	r5, r3, r5
2000c182:	7d29      	ldrb	r1, [r5, #20]
2000c184:	f001 f828 	bl	2000d1d8 <r820t_set_if_bandwidth>
  }
  phase = 1;
2000c188:	4a03      	ldr	r2, [pc, #12]	; (2000c198 <ADCHS_start+0x8c>)
2000c18a:	2001      	movs	r0, #1
2000c18c:	6010      	str	r0, [r2, #0]
}
2000c18e:	bd38      	pop	{r3, r4, r5, pc}
2000c190:	2000ec78 	.word	0x2000ec78
2000c194:	2000ef28 	.word	0x2000ef28
2000c198:	2000f000 	.word	0x2000f000

2000c19c <ADCHS_stop>:

void ADCHS_stop(uint8_t conf_num)
{
2000c19c:	b510      	push	{r4, lr}
2000c19e:	1c04      	adds	r4, r0, #0
  r820t_standby();
2000c1a0:	f001 f840 	bl	2000d224 <r820t_standby>

set_sample_r_params_t set_sample_r_params;

__attribute__ ((always_inline)) static inline void start_stop_adchs_m4(uint8_t conf_num, uint8_t command)
{
  start_adchs->conf = conf_num;
2000c1a4:	4b0a      	ldr	r3, [pc, #40]	; (2000c1d0 <ADCHS_stop+0x34>)
  start_adchs->cmd = command;
2000c1a6:	2202      	movs	r2, #2

set_sample_r_params_t set_sample_r_params;

__attribute__ ((always_inline)) static inline void start_stop_adchs_m4(uint8_t conf_num, uint8_t command)
{
  start_adchs->conf = conf_num;
2000c1a8:	6818      	ldr	r0, [r3, #0]
2000c1aa:	7044      	strb	r4, [r0, #1]
  start_adchs->cmd = command;
2000c1ac:	7002      	strb	r2, [r0, #0]
It also sets the local event register, see Power management (sleep mode, deep sleep mode of System Control Register for more details).
Instruction for Cortex M0, M3/M4 */
__attribute__ ((always_inline)) static inline void signal_sev(void)
{
  /* make sure all data transactions complete before next instruction is executed */
  __asm("dsb");
2000c1ae:	f3bf 8f4f 	dsb	sy
  __asm("sev");
2000c1b2:	bf40      	sev
  signal_sev();

  /* Wait until M4 have finished executing the command (it set the data to 0) */
  while(1)
  {
    if(start_adchs->raw == 0)
2000c1b4:	6801      	ldr	r1, [r0, #0]
2000c1b6:	2900      	cmp	r1, #0
2000c1b8:	d1fc      	bne.n	2000c1b4 <ADCHS_stop+0x18>
{
  r820t_standby();
  start_stop_adchs_m4(conf_num, STOP_ADCHS_CMD);

  /* Re-Init I2C0 & I2C1 after PLL1 frequency is modified */
  i2c0_init(airspy_conf->i2c_conf.i2c0_pll1_ls_hs_conf_val); /* Si5351C I2C peripheral */
2000c1ba:	4c06      	ldr	r4, [pc, #24]	; (2000c1d4 <ADCHS_stop+0x38>)
2000c1bc:	6823      	ldr	r3, [r4, #0]
2000c1be:	8b18      	ldrh	r0, [r3, #24]
2000c1c0:	f002 f804 	bl	2000e1cc <i2c0_init>
  i2c1_init(airspy_conf->i2c_conf.i2c1_pll1_ls_conf_val); /* R820T I2C peripheral */
2000c1c4:	6820      	ldr	r0, [r4, #0]
2000c1c6:	8b80      	ldrh	r0, [r0, #28]
2000c1c8:	f002 f81a 	bl	2000e200 <i2c1_init>
}
2000c1cc:	bd10      	pop	{r4, pc}
2000c1ce:	46c0      	nop			; (mov r8, r8)
2000c1d0:	2000ec78 	.word	0x2000ec78
2000c1d4:	2000ef28 	.word	0x2000ef28

2000c1d8 <m4core_isr>:
/***************************/
/* adchs_isr managed by M4 */
/***************************/
void m4core_isr(void)
{
  MASTER_TXEV_QUIT();
2000c1d8:	4b01      	ldr	r3, [pc, #4]	; (2000c1e0 <m4core_isr+0x8>)
2000c1da:	2200      	movs	r2, #0
2000c1dc:	601a      	str	r2, [r3, #0]
}
2000c1de:	4770      	bx	lr
2000c1e0:	40043130 	.word	0x40043130

2000c1e4 <main>:

/*
M0 Core Manage USB 
*/
int main(void)
{
2000c1e4:	b570      	push	{r4, r5, r6, lr}
2000c1e6:	b08c      	sub	sp, #48	; 0x30
  iap_cmd_res_t iap_cmd_res;
  usb_descriptor_serial_number_t serial_number;
  airspy_usb_req_init();
2000c1e8:	f000 fc72 	bl	2000cad0 <airspy_usb_req_init>

  /* R820T Startup */
  r820t_startup(&airspy_conf->r820t_conf_rw);
2000c1ec:	4b27      	ldr	r3, [pc, #156]	; (2000c28c <main+0xa8>)

  usb_endpoint_init(&usb_endpoint_control_out);
  usb_endpoint_init(&usb_endpoint_control_in);

  /* Read IAP Serial Number Identification */
  iap_cmd_res.cmd_param.command_code = IAP_CMD_READ_SERIAL_NO;
2000c1ee:	ac01      	add	r4, sp, #4
  iap_cmd_res_t iap_cmd_res;
  usb_descriptor_serial_number_t serial_number;
  airspy_usb_req_init();

  /* R820T Startup */
  r820t_startup(&airspy_conf->r820t_conf_rw);
2000c1f0:	6818      	ldr	r0, [r3, #0]
2000c1f2:	3048      	adds	r0, #72	; 0x48
2000c1f4:	f001 f84a 	bl	2000d28c <r820t_startup>

  usb_set_configuration_changed_cb(usb_configuration_changed);
2000c1f8:	4825      	ldr	r0, [pc, #148]	; (2000c290 <main+0xac>)
2000c1fa:	f001 feb5 	bl	2000df68 <usb_set_configuration_changed_cb>
  usb_peripheral_reset();
2000c1fe:	f001 faf5 	bl	2000d7ec <usb_peripheral_reset>

  usb_device_init(0, &usb_device);
2000c202:	4d24      	ldr	r5, [pc, #144]	; (2000c294 <main+0xb0>)
2000c204:	2000      	movs	r0, #0
2000c206:	1c29      	adds	r1, r5, #0
2000c208:	f001 fbee 	bl	2000d9e8 <usb_device_init>

  usb_queue_init(&usb_endpoint_control_out_queue);
2000c20c:	4822      	ldr	r0, [pc, #136]	; (2000c298 <main+0xb4>)
2000c20e:	f001 fd5f 	bl	2000dcd0 <usb_queue_init>
  usb_queue_init(&usb_endpoint_control_in_queue);
2000c212:	4822      	ldr	r0, [pc, #136]	; (2000c29c <main+0xb8>)
2000c214:	f001 fd5c 	bl	2000dcd0 <usb_queue_init>
  usb_queue_init(&usb_endpoint_bulk_out_queue);
2000c218:	4821      	ldr	r0, [pc, #132]	; (2000c2a0 <main+0xbc>)
2000c21a:	f001 fd59 	bl	2000dcd0 <usb_queue_init>
  usb_queue_init(&usb_endpoint_bulk_in_queue);
2000c21e:	4821      	ldr	r0, [pc, #132]	; (2000c2a4 <main+0xc0>)
2000c220:	f001 fd56 	bl	2000dcd0 <usb_queue_init>

  usb_endpoint_init(&usb_endpoint_control_out);
2000c224:	4820      	ldr	r0, [pc, #128]	; (2000c2a8 <main+0xc4>)
2000c226:	f001 fc35 	bl	2000da94 <usb_endpoint_init>
  usb_endpoint_init(&usb_endpoint_control_in);
2000c22a:	4820      	ldr	r0, [pc, #128]	; (2000c2ac <main+0xc8>)
2000c22c:	f001 fc32 	bl	2000da94 <usb_endpoint_init>

  /* Read IAP Serial Number Identification */
  iap_cmd_res.cmd_param.command_code = IAP_CMD_READ_SERIAL_NO;
2000c230:	203a      	movs	r0, #58	; 0x3a
2000c232:	7020      	strb	r0, [r4, #0]
  iap_cmd_call(&iap_cmd_res);
2000c234:	1c20      	adds	r0, r4, #0
2000c236:	f001 fa4f 	bl	2000d6d8 <iap_cmd_call>
  if(iap_cmd_res.status_res.status_ret == CMD_SUCCESS)
2000c23a:	8b21      	ldrh	r1, [r4, #24]
2000c23c:	2900      	cmp	r1, #0
2000c23e:	d103      	bne.n	2000c248 <main+0x64>
  {
    /* Only retrieve 2 last 32bits for Serial Number */
    serial_number.sn_32b[0] = iap_cmd_res.status_res.iap_result[2];
2000c240:	6a60      	ldr	r0, [r4, #36]	; 0x24
    serial_number.sn_32b[1] = iap_cmd_res.status_res.iap_result[3];
2000c242:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    usb_descriptor_fill_string_serial_number(serial_number);
2000c244:	f000 fcc4 	bl	2000cbd0 <usb_descriptor_fill_string_serial_number>
  }

  nvic_set_priority(NVIC_USB0_IRQ, 255);
2000c248:	2008      	movs	r0, #8
2000c24a:	21ff      	movs	r1, #255	; 0xff
2000c24c:	f002 fa42 	bl	2000e6d4 <nvic_set_priority>
  
  nvic_set_priority(NVIC_M4CORE_IRQ, 1);
2000c250:	2001      	movs	r0, #1
2000c252:	1c01      	adds	r1, r0, #0
2000c254:	f002 fa3e 	bl	2000e6d4 <nvic_set_priority>
  nvic_enable_irq(NVIC_M4CORE_IRQ);
2000c258:	2001      	movs	r0, #1
2000c25a:	f002 fa2f 	bl	2000e6bc <nvic_enable_irq>

  usb_run(&usb_device);
2000c25e:	1c28      	adds	r0, r5, #0
2000c260:	f001 fc06 	bl	2000da70 <usb_run>

  while(true)
  {
    signal_wfe();

    uint32_t offset = get_usb_buffer_offset();
2000c264:	4a12      	ldr	r2, [pc, #72]	; (2000c2b0 <main+0xcc>)
    uint32_t length = get_usb_buffer_length();
2000c266:	4b13      	ldr	r3, [pc, #76]	; (2000c2b4 <main+0xd0>)

    if(offset != *last_offset_m0)
2000c268:	4d13      	ldr	r5, [pc, #76]	; (2000c2b8 <main+0xd4>)

  while(true)
  {
    signal_wfe();

    uint32_t offset = get_usb_buffer_offset();
2000c26a:	6816      	ldr	r6, [r2, #0]
    uint32_t length = get_usb_buffer_length();
2000c26c:	6818      	ldr	r0, [r3, #0]

    if(offset != *last_offset_m0)
2000c26e:	6829      	ldr	r1, [r5, #0]
If the event register is 1, WFE clears it to 0 and completes immediately.
Instruction for Cortex M0, M3/M4
*/
__attribute__ ((always_inline)) static inline void signal_wfe(void)
{
  __asm("wfe");
2000c270:	bf20      	wfe

  while(true)
  {
    signal_wfe();

    uint32_t offset = get_usb_buffer_offset();
2000c272:	6834      	ldr	r4, [r6, #0]
    uint32_t length = get_usb_buffer_length();
2000c274:	6802      	ldr	r2, [r0, #0]

    if(offset != *last_offset_m0)
2000c276:	680b      	ldr	r3, [r1, #0]
2000c278:	429c      	cmp	r4, r3
2000c27a:	d0f9      	beq.n	2000c270 <main+0x8c>
    {
      usb_transfer_schedule_block(&usb_endpoint_bulk_in, &usb_bulk_buffer[offset], length);
2000c27c:	4e0f      	ldr	r6, [pc, #60]	; (2000c2bc <main+0xd8>)
2000c27e:	4810      	ldr	r0, [pc, #64]	; (2000c2c0 <main+0xdc>)
2000c280:	19a1      	adds	r1, r4, r6
2000c282:	f001 fdb1 	bl	2000dde8 <usb_transfer_schedule_block>
      *last_offset_m0 = offset;
2000c286:	682a      	ldr	r2, [r5, #0]
2000c288:	6014      	str	r4, [r2, #0]
2000c28a:	e7eb      	b.n	2000c264 <main+0x80>
2000c28c:	2000ef28 	.word	0x2000ef28
2000c290:	2000c0c1 	.word	0x2000c0c1
2000c294:	2000ee1c 	.word	0x2000ee1c
2000c298:	2000ee48 	.word	0x2000ee48
2000c29c:	2000ee68 	.word	0x2000ee68
2000c2a0:	2000ee58 	.word	0x2000ee58
2000c2a4:	2000eef0 	.word	0x2000eef0
2000c2a8:	2000ee78 	.word	0x2000ee78
2000c2ac:	2000eec8 	.word	0x2000eec8
2000c2b0:	2000ec74 	.word	0x2000ec74
2000c2b4:	2000ec7c 	.word	0x2000ec7c
2000c2b8:	2000ec80 	.word	0x2000ec80
2000c2bc:	20004000 	.word	0x20004000
2000c2c0:	2000ef00 	.word	0x2000ef00

2000c2c4 <set_receiver_mode>:
extern usb_endpoint_t usb_endpoint_bulk_in;

static volatile receiver_mode_t receiver_mode = RECEIVER_MODE_OFF;

void set_receiver_mode(const receiver_mode_t new_receiver_mode)
{
2000c2c4:	b538      	push	{r3, r4, r5, lr}
2000c2c6:	1c04      	adds	r4, r0, #0
  usb_streaming_disable();
2000c2c8:	f000 fbf6 	bl	2000cab8 <usb_streaming_disable>
2000c2cc:	4d07      	ldr	r5, [pc, #28]	; (2000c2ec <set_receiver_mode+0x28>)

  if( new_receiver_mode == RECEIVER_MODE_RX )
2000c2ce:	2c01      	cmp	r4, #1
2000c2d0:	d106      	bne.n	2000c2e0 <set_receiver_mode+0x1c>
  {
    usb_endpoint_init(&usb_endpoint_bulk_in);
2000c2d2:	4807      	ldr	r0, [pc, #28]	; (2000c2f0 <set_receiver_mode+0x2c>)
2000c2d4:	f001 fbde 	bl	2000da94 <usb_endpoint_init>
    ADCHS_start(sample_rate_conf_no);
2000c2d8:	7828      	ldrb	r0, [r5, #0]
2000c2da:	f7ff ff17 	bl	2000c10c <ADCHS_start>
2000c2de:	e002      	b.n	2000c2e6 <set_receiver_mode+0x22>
  }else
  {
    ADCHS_stop(sample_rate_conf_no);
2000c2e0:	7828      	ldrb	r0, [r5, #0]
2000c2e2:	f7ff ff5b 	bl	2000c19c <ADCHS_stop>
  }
  receiver_mode = new_receiver_mode;
2000c2e6:	4b03      	ldr	r3, [pc, #12]	; (2000c2f4 <set_receiver_mode+0x30>)
2000c2e8:	701c      	strb	r4, [r3, #0]
}
2000c2ea:	bd38      	pop	{r3, r4, r5, pc}
2000c2ec:	2000f500 	.word	0x2000f500
2000c2f0:	2000ef00 	.word	0x2000ef00
2000c2f4:	2000f004 	.word	0x2000f004

2000c2f8 <get_receiver_mode>:

receiver_mode_t get_receiver_mode(void)
{
  return receiver_mode;
2000c2f8:	4b01      	ldr	r3, [pc, #4]	; (2000c300 <get_receiver_mode+0x8>)
2000c2fa:	7818      	ldrb	r0, [r3, #0]
}
2000c2fc:	4770      	bx	lr
2000c2fe:	46c0      	nop			; (mov r8, r8)
2000c300:	2000f004 	.word	0x2000f004

2000c304 <usb_vendor_request>:

  vendor_request_handler[AIRSPY_SPIFLASH_ERASE_SECTOR] = usb_vendor_request_erase_sector_spiflash;
}

usb_request_status_t usb_vendor_request(usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c304:	b508      	push	{r3, lr}
  usb_request_status_t status = USB_REQUEST_STATUS_STALL;
  
  if( endpoint->setup.request <= AIRSPY_CMD_MAX )
2000c306:	7843      	ldrb	r3, [r0, #1]
2000c308:	2b1b      	cmp	r3, #27
2000c30a:	d806      	bhi.n	2000c31a <usb_vendor_request+0x16>
  {
    usb_request_handler_fn handler = vendor_request_handler[endpoint->setup.request];
2000c30c:	4a05      	ldr	r2, [pc, #20]	; (2000c324 <usb_vendor_request+0x20>)
2000c30e:	009b      	lsls	r3, r3, #2
2000c310:	589b      	ldr	r3, [r3, r2]
    if( handler )
2000c312:	2b00      	cmp	r3, #0
2000c314:	d004      	beq.n	2000c320 <usb_vendor_request+0x1c>
    {
      status = handler(endpoint, stage);
2000c316:	4798      	blx	r3
2000c318:	e003      	b.n	2000c322 <usb_vendor_request+0x1e>
2000c31a:	4248      	negs	r0, r1
2000c31c:	4148      	adcs	r0, r1
2000c31e:	e000      	b.n	2000c322 <usb_vendor_request+0x1e>
  vendor_request_handler[AIRSPY_SPIFLASH_ERASE_SECTOR] = usb_vendor_request_erase_sector_spiflash;
}

usb_request_status_t usb_vendor_request(usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
  usb_request_status_t status = USB_REQUEST_STATUS_STALL;
2000c320:	2001      	movs	r0, #1
  {
    status = USB_REQUEST_STATUS_OK;
  }
  }
  return status;
}
2000c322:	bd08      	pop	{r3, pc}
2000c324:	2000f390 	.word	0x2000f390

2000c328 <usb_vendor_request_reset>:
  }
}

usb_request_status_t usb_vendor_request_reset(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c328:	b508      	push	{r3, lr}
  if (stage == USB_TRANSFER_STAGE_SETUP)
2000c32a:	2900      	cmp	r1, #0
2000c32c:	d101      	bne.n	2000c332 <usb_vendor_request_reset+0xa>
  {
    //usb_transfer_schedule_ack(endpoint->in);
    cpu_reset();
2000c32e:	f000 fcb7 	bl	2000cca0 <cpu_reset>
  }
  return USB_REQUEST_STATUS_OK;
}
2000c332:	2000      	movs	r0, #0
2000c334:	bd08      	pop	{r3, pc}

2000c336 <usb_vendor_request_erase_sector_spiflash>:
  }
}

usb_request_status_t usb_vendor_request_erase_sector_spiflash(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c336:	b570      	push	{r4, r5, r6, lr}
2000c338:	1c05      	adds	r5, r0, #0
    w25q80bv_setup();
    addr = (sector * MAX_SECTOR_SIZE_64KB);
    w25q80bv_sector_erase(addr); /* Erase 64KB */
    usb_transfer_schedule_ack(endpoint->in);
  }
  return USB_REQUEST_STATUS_OK;
2000c33a:	2000      	movs	r0, #0
  }
}

usb_request_status_t usb_vendor_request_erase_sector_spiflash(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c33c:	1e0c      	subs	r4, r1, #0
  uint32_t sector = 0;
  #define MIN_SECTOR (2) /* 128KB Reserved (Firmware) */
  #define MAX_SECTOR (13) /* 128KB Reserved + (13 * 64KB) Conf = 1MB Flash */
  #define MAX_SECTOR_SIZE_64KB (64 * 1024)

  if (stage == USB_TRANSFER_STAGE_SETUP)
2000c33e:	4284      	cmp	r4, r0
2000c340:	d10d      	bne.n	2000c35e <usb_vendor_request_erase_sector_spiflash+0x28>
  {
    sector = (uint32_t)endpoint->setup.value;
2000c342:	886e      	ldrh	r6, [r5, #2]
    /* Check if we exceed Flash Size */
    if(sector < MIN_SECTOR || sector > MAX_SECTOR)
    {
      return USB_REQUEST_STATUS_STALL;
2000c344:	2001      	movs	r0, #1

  if (stage == USB_TRANSFER_STAGE_SETUP)
  {
    sector = (uint32_t)endpoint->setup.value;
    /* Check if we exceed Flash Size */
    if(sector < MIN_SECTOR || sector > MAX_SECTOR)
2000c346:	1eb2      	subs	r2, r6, #2
2000c348:	2a0b      	cmp	r2, #11
2000c34a:	d808      	bhi.n	2000c35e <usb_vendor_request_erase_sector_spiflash+0x28>
    {
      return USB_REQUEST_STATUS_STALL;
    }
    w25q80bv_setup();
2000c34c:	f000 ffea 	bl	2000d324 <w25q80bv_setup>
    addr = (sector * MAX_SECTOR_SIZE_64KB);
2000c350:	0430      	lsls	r0, r6, #16
    w25q80bv_sector_erase(addr); /* Erase 64KB */
2000c352:	f001 f8c7 	bl	2000d4e4 <w25q80bv_sector_erase>
    usb_transfer_schedule_ack(endpoint->in);
2000c356:	69a8      	ldr	r0, [r5, #24]
2000c358:	f001 fd53 	bl	2000de02 <usb_transfer_schedule_ack>
  }
  return USB_REQUEST_STATUS_OK;
2000c35c:	1c20      	adds	r0, r4, #0
}
2000c35e:	bd70      	pop	{r4, r5, r6, pc}

2000c360 <usb_vendor_request_gpiodir_write_command>:
}

usb_request_status_t usb_vendor_request_gpiodir_write_command(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
2000c360:	b538      	push	{r3, r4, r5, lr}
        return USB_REQUEST_STATUS_OK;
      }
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
2000c362:	2300      	movs	r3, #0
  uint32_t port_num;
  uint32_t pin_num;
  uint16_t index;
  uint16_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c364:	4299      	cmp	r1, r3
2000c366:	d119      	bne.n	2000c39c <usb_vendor_request_gpiodir_write_command+0x3c>
  {
    index = endpoint->setup.index;
2000c368:	8881      	ldrh	r1, [r0, #4]
        }
        usb_transfer_schedule_ack(endpoint->in);
        return USB_REQUEST_STATUS_OK;
      }
    }
    return USB_REQUEST_STATUS_STALL;
2000c36a:	2301      	movs	r3, #1
  uint16_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    index = endpoint->setup.index;
    if( index < 256 )
2000c36c:	29ff      	cmp	r1, #255	; 0xff
2000c36e:	d815      	bhi.n	2000c39c <usb_vendor_request_gpiodir_write_command+0x3c>
    {
      value = endpoint->setup.value;
2000c370:	8844      	ldrh	r4, [r0, #2]
      if( value < 2 )
2000c372:	429c      	cmp	r4, r3
2000c374:	d812      	bhi.n	2000c39c <usb_vendor_request_gpiodir_write_command+0x3c>
      {
        port_num = index >> 5;
        port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));
2000c376:	4d0a      	ldr	r5, [pc, #40]	; (2000c3a0 <usb_vendor_request_gpiodir_write_command+0x40>)
    if( index < 256 )
    {
      value = endpoint->setup.value;
      if( value < 2 )
      {
        port_num = index >> 5;
2000c378:	094a      	lsrs	r2, r1, #5
        port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));
2000c37a:	1952      	adds	r2, r2, r5

        pin_num = index & 0x1F;
        pin_num = (1 << pin_num);
2000c37c:	251f      	movs	r5, #31
2000c37e:	4029      	ands	r1, r5
    {
      value = endpoint->setup.value;
      if( value < 2 )
      {
        port_num = index >> 5;
        port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));
2000c380:	0092      	lsls	r2, r2, #2

        pin_num = index & 0x1F;
        pin_num = (1 << pin_num);
2000c382:	408b      	lsls	r3, r1

        if(value == 1)
        {
          GPIO_DIR(port_num) = (GPIO_DIR(port_num) | pin_num);
2000c384:	6811      	ldr	r1, [r2, #0]
        port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));

        pin_num = index & 0x1F;
        pin_num = (1 << pin_num);

        if(value == 1)
2000c386:	2c01      	cmp	r4, #1
2000c388:	d101      	bne.n	2000c38e <usb_vendor_request_gpiodir_write_command+0x2e>
        {
          GPIO_DIR(port_num) = (GPIO_DIR(port_num) | pin_num);
2000c38a:	430b      	orrs	r3, r1
2000c38c:	e001      	b.n	2000c392 <usb_vendor_request_gpiodir_write_command+0x32>
        }else
        {
          GPIO_DIR(port_num) = (GPIO_DIR(port_num) & (~pin_num));
2000c38e:	4399      	bics	r1, r3
2000c390:	1c0b      	adds	r3, r1, #0
2000c392:	6013      	str	r3, [r2, #0]
        }
        usb_transfer_schedule_ack(endpoint->in);
2000c394:	6980      	ldr	r0, [r0, #24]
2000c396:	f001 fd34 	bl	2000de02 <usb_transfer_schedule_ack>
        return USB_REQUEST_STATUS_OK;
2000c39a:	2300      	movs	r3, #0
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
  }
}
2000c39c:	1c18      	adds	r0, r3, #0
2000c39e:	bd38      	pop	{r3, r4, r5, pc}
2000c3a0:	1003d800 	.word	0x1003d800

2000c3a4 <usb_vendor_request_erase_spiflash>:
  }
}

usb_request_status_t usb_vendor_request_erase_spiflash(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c3a4:	b538      	push	{r3, r4, r5, lr}
2000c3a6:	1c05      	adds	r5, r0, #0
2000c3a8:	1e0c      	subs	r4, r1, #0
  if (stage == USB_TRANSFER_STAGE_SETUP)
2000c3aa:	d107      	bne.n	2000c3bc <usb_vendor_request_erase_spiflash+0x18>
  {
    w25q80bv_setup();
2000c3ac:	f000 ffba 	bl	2000d324 <w25q80bv_setup>
    w25q80bv_sector_erase(0); /* Erase 1st sector 64KB */
2000c3b0:	1c20      	adds	r0, r4, #0
2000c3b2:	f001 f897 	bl	2000d4e4 <w25q80bv_sector_erase>
    usb_transfer_schedule_ack(endpoint->in);
2000c3b6:	69a8      	ldr	r0, [r5, #24]
2000c3b8:	f001 fd23 	bl	2000de02 <usb_transfer_schedule_ack>
  }
  return USB_REQUEST_STATUS_OK;
}
2000c3bc:	2000      	movs	r0, #0
2000c3be:	bd38      	pop	{r3, r4, r5, pc}

2000c3c0 <usb_vendor_request_get_samplerates_command>:
  }
}

usb_request_status_t usb_vendor_request_get_samplerates_command(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c3c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000c3c2:	1c04      	adds	r4, r0, #0
  uint16_t nb_samplerate;
  uint32_t schedule_block_len;
  uint16_t airspy_conf_nb;
  uint32_t* samplerates_buffer;

  if (stage == USB_TRANSFER_STAGE_SETUP) 
2000c3c4:	2900      	cmp	r1, #0
2000c3c6:	d12a      	bne.n	2000c41e <usb_vendor_request_get_samplerates_command+0x5e>
  {
    nb_samplerate = endpoint->setup.index;
    airspy_conf_nb = airspy_conf->nb_airspy_m0_m4_conf_t;
2000c3c8:	4b16      	ldr	r3, [pc, #88]	; (2000c424 <usb_vendor_request_get_samplerates_command+0x64>)
  uint16_t airspy_conf_nb;
  uint32_t* samplerates_buffer;

  if (stage == USB_TRANSFER_STAGE_SETUP) 
  {
    nb_samplerate = endpoint->setup.index;
2000c3ca:	8881      	ldrh	r1, [r0, #4]
    airspy_conf_nb = airspy_conf->nb_airspy_m0_m4_conf_t;
2000c3cc:	6818      	ldr	r0, [r3, #0]
2000c3ce:	1c02      	adds	r2, r0, #0
2000c3d0:	3276      	adds	r2, #118	; 0x76
2000c3d2:	8815      	ldrh	r5, [r2, #0]
2000c3d4:	1c2e      	adds	r6, r5, #0
2000c3d6:	428d      	cmp	r5, r1
2000c3d8:	d900      	bls.n	2000c3dc <usb_vendor_request_get_samplerates_command+0x1c>
2000c3da:	1c0e      	adds	r6, r1, #0
2000c3dc:	b2b2      	uxth	r2, r6
2000c3de:	4912      	ldr	r1, [pc, #72]	; (2000c428 <usb_vendor_request_get_samplerates_command+0x68>)

    if(nb_samplerate > airspy_conf_nb)
    {
      nb_samplerate = airspy_conf_nb;
    }
    if(nb_samplerate > AIRSPY_CONF_NB_MAX)
2000c3e0:	2a40      	cmp	r2, #64	; 0x40
2000c3e2:	d802      	bhi.n	2000c3ea <usb_vendor_request_get_samplerates_command+0x2a>
    {
      nb_samplerate = AIRSPY_CONF_NB_MAX;
    }

    samplerates_buffer = (uint32_t*)&spiflash_buffer[0];
    if(nb_samplerate == 0)
2000c3e4:	2a00      	cmp	r2, #0
2000c3e6:	d003      	beq.n	2000c3f0 <usb_vendor_request_get_samplerates_command+0x30>
2000c3e8:	e000      	b.n	2000c3ec <usb_vendor_request_get_samplerates_command+0x2c>
    {
      nb_samplerate = airspy_conf_nb;
    }
    if(nb_samplerate > AIRSPY_CONF_NB_MAX)
    {
      nb_samplerate = AIRSPY_CONF_NB_MAX;
2000c3ea:	2240      	movs	r2, #64	; 0x40
2000c3ec:	2300      	movs	r3, #0
2000c3ee:	e003      	b.n	2000c3f8 <usb_vendor_request_get_samplerates_command+0x38>

    samplerates_buffer = (uint32_t*)&spiflash_buffer[0];
    if(nb_samplerate == 0)
    {
      /* Return the number of samplerates available */
      samplerates_buffer[0] = airspy_conf_nb;
2000c3f0:	600d      	str	r5, [r1, #0]
      usb_transfer_schedule_block(endpoint->in, &samplerates_buffer[0], 4);
2000c3f2:	69a0      	ldr	r0, [r4, #24]
2000c3f4:	2204      	movs	r2, #4
2000c3f6:	e00d      	b.n	2000c414 <usb_vendor_request_get_samplerates_command+0x54>
    } else
    {
      /* Return each samplerate available */
      for(i = 0; i < nb_samplerate; i++)
2000c3f8:	4293      	cmp	r3, r2
2000c3fa:	da09      	bge.n	2000c410 <usb_vendor_request_get_samplerates_command+0x50>
      {
        samplerates_buffer[i] = airspy_conf->airspy_m0_m4_conf[i].airspy_m0_conf.r820t_if_freq * 2; /* samplerate = IF_freq * 2 */
2000c3fc:	2618      	movs	r6, #24
2000c3fe:	435e      	muls	r6, r3
2000c400:	6f87      	ldr	r7, [r0, #120]	; 0x78
  } else {
    return USB_REQUEST_STATUS_OK;
  }
}

usb_request_status_t usb_vendor_request_get_samplerates_command(
2000c402:	009d      	lsls	r5, r3, #2
    } else
    {
      /* Return each samplerate available */
      for(i = 0; i < nb_samplerate; i++)
      {
        samplerates_buffer[i] = airspy_conf->airspy_m0_m4_conf[i].airspy_m0_conf.r820t_if_freq * 2; /* samplerate = IF_freq * 2 */
2000c404:	19be      	adds	r6, r7, r6
2000c406:	6937      	ldr	r7, [r6, #16]
      samplerates_buffer[0] = airspy_conf_nb;
      usb_transfer_schedule_block(endpoint->in, &samplerates_buffer[0], 4);
    } else
    {
      /* Return each samplerate available */
      for(i = 0; i < nb_samplerate; i++)
2000c408:	3301      	adds	r3, #1
      {
        samplerates_buffer[i] = airspy_conf->airspy_m0_m4_conf[i].airspy_m0_conf.r820t_if_freq * 2; /* samplerate = IF_freq * 2 */
2000c40a:	007e      	lsls	r6, r7, #1
2000c40c:	514e      	str	r6, [r1, r5]
2000c40e:	e7f3      	b.n	2000c3f8 <usb_vendor_request_get_samplerates_command+0x38>
      }
      schedule_block_len = nb_samplerate * sizeof(uint32_t);
      usb_transfer_schedule_block(endpoint->in, &samplerates_buffer[0], schedule_block_len);
2000c410:	69a0      	ldr	r0, [r4, #24]
      /* Return each samplerate available */
      for(i = 0; i < nb_samplerate; i++)
      {
        samplerates_buffer[i] = airspy_conf->airspy_m0_m4_conf[i].airspy_m0_conf.r820t_if_freq * 2; /* samplerate = IF_freq * 2 */
      }
      schedule_block_len = nb_samplerate * sizeof(uint32_t);
2000c412:	0092      	lsls	r2, r2, #2
      usb_transfer_schedule_block(endpoint->in, &samplerates_buffer[0], schedule_block_len);
2000c414:	f001 fce8 	bl	2000dde8 <usb_transfer_schedule_block>
    }
    usb_transfer_schedule_ack(endpoint->out);
2000c418:	69e0      	ldr	r0, [r4, #28]
2000c41a:	f001 fcf2 	bl	2000de02 <usb_transfer_schedule_ack>
    return USB_REQUEST_STATUS_OK;
  } else 
  {
    return USB_REQUEST_STATUS_OK;
  }
}
2000c41e:	2000      	movs	r0, #0
2000c420:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2000c422:	46c0      	nop			; (mov r8, r8)
2000c424:	2000ef28 	.word	0x2000ef28
2000c428:	2000f400 	.word	0x2000f400

2000c42c <usb_vendor_request_gpiodir_read_command>:
      usb_transfer_schedule_ack(endpoint->out);
      return USB_REQUEST_STATUS_OK;
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
2000c42c:	2200      	movs	r2, #0
}

usb_request_status_t usb_vendor_request_gpiodir_read_command(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
2000c42e:	b538      	push	{r3, r4, r5, lr}
2000c430:	1c04      	adds	r4, r0, #0
2000c432:	1e0d      	subs	r5, r1, #0
  uint32_t port_num;
  uint32_t pin_num;
  uint8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c434:	4295      	cmp	r5, r2
2000c436:	d11a      	bne.n	2000c46e <usb_vendor_request_gpiodir_read_command+0x42>
  {
    if( endpoint->setup.index < 256 )
2000c438:	8883      	ldrh	r3, [r0, #4]
      endpoint->buffer[0] = value;
      usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
      usb_transfer_schedule_ack(endpoint->out);
      return USB_REQUEST_STATUS_OK;
    }
    return USB_REQUEST_STATUS_STALL;
2000c43a:	2201      	movs	r2, #1
  uint32_t pin_num;
  uint8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    if( endpoint->setup.index < 256 )
2000c43c:	2bff      	cmp	r3, #255	; 0xff
2000c43e:	d816      	bhi.n	2000c46e <usb_vendor_request_gpiodir_read_command+0x42>
    {
      port_num = endpoint->setup.index >> 5;
      port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));
2000c440:	480c      	ldr	r0, [pc, #48]	; (2000c474 <usb_vendor_request_gpiodir_read_command+0x48>)

  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    if( endpoint->setup.index < 256 )
    {
      port_num = endpoint->setup.index >> 5;
2000c442:	0959      	lsrs	r1, r3, #5
      port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));
2000c444:	1809      	adds	r1, r1, r0
2000c446:	0088      	lsls	r0, r1, #2

      pin_num = endpoint->setup.index & 0x1F;
      pin_num = (1 << pin_num);
      
      if( (GPIO_DIR(port_num) & pin_num) )
2000c448:	6801      	ldr	r1, [r0, #0]
    {
      port_num = endpoint->setup.index >> 5;
      port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));

      pin_num = endpoint->setup.index & 0x1F;
      pin_num = (1 << pin_num);
2000c44a:	201f      	movs	r0, #31
2000c44c:	4003      	ands	r3, r0
2000c44e:	1c10      	adds	r0, r2, #0
2000c450:	4098      	lsls	r0, r3
2000c452:	1c03      	adds	r3, r0, #0
      
      if( (GPIO_DIR(port_num) & pin_num) )
2000c454:	400b      	ands	r3, r1
2000c456:	1e59      	subs	r1, r3, #1
2000c458:	418b      	sbcs	r3, r1
      }else
      {
        value = 0;
      }
      endpoint->buffer[0] = value;
      usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c45a:	1c21      	adds	r1, r4, #0
        value = 1;
      }else
      {
        value = 0;
      }
      endpoint->buffer[0] = value;
2000c45c:	7223      	strb	r3, [r4, #8]
      usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c45e:	3108      	adds	r1, #8
2000c460:	69a0      	ldr	r0, [r4, #24]
2000c462:	f001 fcc1 	bl	2000dde8 <usb_transfer_schedule_block>
      usb_transfer_schedule_ack(endpoint->out);
2000c466:	69e0      	ldr	r0, [r4, #28]
2000c468:	f001 fccb 	bl	2000de02 <usb_transfer_schedule_ack>
      return USB_REQUEST_STATUS_OK;
2000c46c:	1c2a      	adds	r2, r5, #0
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
  }
}
2000c46e:	1c10      	adds	r0, r2, #0
2000c470:	bd38      	pop	{r3, r4, r5, pc}
2000c472:	46c0      	nop			; (mov r8, r8)
2000c474:	1003d800 	.word	0x1003d800

2000c478 <usb_vendor_request_ms_vendor_command>:
  return USB_REQUEST_STATUS_OK;
}

usb_request_status_t usb_vendor_request_ms_vendor_command(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c478:	b570      	push	{r4, r5, r6, lr}
        usb_transfer_schedule_ack(endpoint->out);
        return USB_REQUEST_STATUS_OK;
     }  
    return USB_REQUEST_STATUS_STALL;
  }
  return USB_REQUEST_STATUS_OK;
2000c47a:	2500      	movs	r5, #0
  return USB_REQUEST_STATUS_OK;
}

usb_request_status_t usb_vendor_request_ms_vendor_command(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c47c:	1c04      	adds	r4, r0, #0
2000c47e:	1e0e      	subs	r6, r1, #0
  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c480:	42ae      	cmp	r6, r5
2000c482:	d117      	bne.n	2000c4b4 <usb_vendor_request_ms_vendor_command+0x3c>
  {
     if (endpoint->setup.index == 0x04)
2000c484:	8883      	ldrh	r3, [r0, #4]
2000c486:	2b04      	cmp	r3, #4
2000c488:	d108      	bne.n	2000c49c <usb_vendor_request_ms_vendor_command+0x24>
     {  
        usb_transfer_schedule_block(endpoint->in, &usb_descriptor_CompatIDDescriptor, endpoint->setup.length);
2000c48a:	88c2      	ldrh	r2, [r0, #6]
2000c48c:	490a      	ldr	r1, [pc, #40]	; (2000c4b8 <usb_vendor_request_ms_vendor_command+0x40>)
2000c48e:	6980      	ldr	r0, [r0, #24]
2000c490:	f001 fcaa 	bl	2000dde8 <usb_transfer_schedule_block>
        usb_transfer_schedule_ack(endpoint->out);
2000c494:	69e0      	ldr	r0, [r4, #28]
2000c496:	f001 fcb4 	bl	2000de02 <usb_transfer_schedule_ack>
2000c49a:	e00b      	b.n	2000c4b4 <usb_vendor_request_ms_vendor_command+0x3c>
     {
        usb_transfer_schedule_block(endpoint->in, &usb_descriptor_ExtProps, endpoint->setup.length);
        usb_transfer_schedule_ack(endpoint->out);
        return USB_REQUEST_STATUS_OK;
     }  
    return USB_REQUEST_STATUS_STALL;
2000c49c:	2501      	movs	r5, #1
     {  
        usb_transfer_schedule_block(endpoint->in, &usb_descriptor_CompatIDDescriptor, endpoint->setup.length);
        usb_transfer_schedule_ack(endpoint->out);
        return USB_REQUEST_STATUS_OK;
     }
     if (endpoint->setup.index == 0x05)
2000c49e:	2b05      	cmp	r3, #5
2000c4a0:	d108      	bne.n	2000c4b4 <usb_vendor_request_ms_vendor_command+0x3c>
     {
        usb_transfer_schedule_block(endpoint->in, &usb_descriptor_ExtProps, endpoint->setup.length);
2000c4a2:	88c2      	ldrh	r2, [r0, #6]
2000c4a4:	4905      	ldr	r1, [pc, #20]	; (2000c4bc <usb_vendor_request_ms_vendor_command+0x44>)
2000c4a6:	6980      	ldr	r0, [r0, #24]
2000c4a8:	f001 fc9e 	bl	2000dde8 <usb_transfer_schedule_block>
        usb_transfer_schedule_ack(endpoint->out);
2000c4ac:	69e0      	ldr	r0, [r4, #28]
2000c4ae:	f001 fca8 	bl	2000de02 <usb_transfer_schedule_ack>
        return USB_REQUEST_STATUS_OK;
2000c4b2:	1c35      	adds	r5, r6, #0
     }  
    return USB_REQUEST_STATUS_STALL;
  }
  return USB_REQUEST_STATUS_OK;
}
2000c4b4:	1c28      	adds	r0, r5, #0
2000c4b6:	bd70      	pop	{r4, r5, r6, pc}
2000c4b8:	2000ecaf 	.word	0x2000ecaf
2000c4bc:	2000ed82 	.word	0x2000ed82

2000c4c0 <usb_vendor_request_read_board_id>:
  }
}

usb_request_status_t usb_vendor_request_read_board_id(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c4c0:	b510      	push	{r4, lr}
2000c4c2:	1c04      	adds	r4, r0, #0
  if (stage == USB_TRANSFER_STAGE_SETUP) {
2000c4c4:	2900      	cmp	r1, #0
2000c4c6:	d109      	bne.n	2000c4dc <usb_vendor_request_read_board_id+0x1c>
    endpoint->buffer[0] = BOARD_ID;
2000c4c8:	7201      	strb	r1, [r0, #8]
    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c4ca:	1c01      	adds	r1, r0, #0
2000c4cc:	3108      	adds	r1, #8
2000c4ce:	6980      	ldr	r0, [r0, #24]
2000c4d0:	2201      	movs	r2, #1
2000c4d2:	f001 fc89 	bl	2000dde8 <usb_transfer_schedule_block>
    usb_transfer_schedule_ack(endpoint->out);
2000c4d6:	69e0      	ldr	r0, [r4, #28]
2000c4d8:	f001 fc93 	bl	2000de02 <usb_transfer_schedule_ack>
  }
  return USB_REQUEST_STATUS_OK;
}
2000c4dc:	2000      	movs	r0, #0
2000c4de:	bd10      	pop	{r4, pc}

2000c4e0 <usb_vendor_request_set_rf_bias_command>:
  return USB_REQUEST_STATUS_OK;
}

usb_request_status_t usb_vendor_request_set_rf_bias_command(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c4e0:	b510      	push	{r4, lr}
2000c4e2:	1c04      	adds	r4, r0, #0
  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c4e4:	2900      	cmp	r1, #0
2000c4e6:	d10a      	bne.n	2000c4fe <usb_vendor_request_set_rf_bias_command+0x1e>
  {
    if(endpoint->setup.index == 1)
2000c4e8:	8883      	ldrh	r3, [r0, #4]
2000c4ea:	2b01      	cmp	r3, #1
2000c4ec:	d102      	bne.n	2000c4f4 <usb_vendor_request_set_rf_bias_command+0x14>
    {
      enable_biast_power();
2000c4ee:	f000 fbdd 	bl	2000ccac <enable_biast_power>
2000c4f2:	e001      	b.n	2000c4f8 <usb_vendor_request_set_rf_bias_command+0x18>
    }else
    {
      disable_biast_power();
2000c4f4:	f000 fbe4 	bl	2000ccc0 <disable_biast_power>
    }
    usb_transfer_schedule_ack(endpoint->in);
2000c4f8:	69a0      	ldr	r0, [r4, #24]
2000c4fa:	f001 fc82 	bl	2000de02 <usb_transfer_schedule_ack>
    return USB_REQUEST_STATUS_OK;
  }
  return USB_REQUEST_STATUS_OK;
}
2000c4fe:	2000      	movs	r0, #0
2000c500:	bd10      	pop	{r4, pc}
	...

2000c504 <usb_vendor_request_set_mixer_agc>:
  return USB_REQUEST_STATUS_OK;
}

usb_request_status_t usb_vendor_request_set_mixer_agc(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c504:	b510      	push	{r4, lr}
2000c506:	1c04      	adds	r4, r0, #0
  int8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c508:	2900      	cmp	r1, #0
2000c50a:	d10f      	bne.n	2000c52c <usb_vendor_request_set_mixer_agc+0x28>
  {
    value = r820t_set_mixer_agc(&airspy_conf->r820t_conf_rw, endpoint->setup.index);
2000c50c:	4b08      	ldr	r3, [pc, #32]	; (2000c530 <usb_vendor_request_set_mixer_agc+0x2c>)
2000c50e:	7921      	ldrb	r1, [r4, #4]
2000c510:	6818      	ldr	r0, [r3, #0]
2000c512:	3048      	adds	r0, #72	; 0x48
2000c514:	f000 fde2 	bl	2000d0dc <r820t_set_mixer_agc>
    endpoint->buffer[0] = value;

    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c518:	1c21      	adds	r1, r4, #0
  int8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    value = r820t_set_mixer_agc(&airspy_conf->r820t_conf_rw, endpoint->setup.index);
    endpoint->buffer[0] = value;
2000c51a:	7220      	strb	r0, [r4, #8]

    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c51c:	3108      	adds	r1, #8
2000c51e:	69a0      	ldr	r0, [r4, #24]
2000c520:	2201      	movs	r2, #1
2000c522:	f001 fc61 	bl	2000dde8 <usb_transfer_schedule_block>
    usb_transfer_schedule_ack(endpoint->out);
2000c526:	69e0      	ldr	r0, [r4, #28]
2000c528:	f001 fc6b 	bl	2000de02 <usb_transfer_schedule_ack>
    return USB_REQUEST_STATUS_OK;
  }
  return USB_REQUEST_STATUS_OK;
}
2000c52c:	2000      	movs	r0, #0
2000c52e:	bd10      	pop	{r4, pc}
2000c530:	2000ef28 	.word	0x2000ef28

2000c534 <usb_vendor_request_set_lna_agc>:
  return USB_REQUEST_STATUS_OK;
}

usb_request_status_t usb_vendor_request_set_lna_agc(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c534:	b510      	push	{r4, lr}
2000c536:	1c04      	adds	r4, r0, #0
  int8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c538:	2900      	cmp	r1, #0
2000c53a:	d10f      	bne.n	2000c55c <usb_vendor_request_set_lna_agc+0x28>
  {
    value = r820t_set_lna_agc(&airspy_conf->r820t_conf_rw, endpoint->setup.index);
2000c53c:	4b08      	ldr	r3, [pc, #32]	; (2000c560 <usb_vendor_request_set_lna_agc+0x2c>)
2000c53e:	7921      	ldrb	r1, [r4, #4]
2000c540:	6818      	ldr	r0, [r3, #0]
2000c542:	3048      	adds	r0, #72	; 0x48
2000c544:	f000 fdc1 	bl	2000d0ca <r820t_set_lna_agc>
    endpoint->buffer[0] = value;

    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c548:	1c21      	adds	r1, r4, #0
  int8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    value = r820t_set_lna_agc(&airspy_conf->r820t_conf_rw, endpoint->setup.index);
    endpoint->buffer[0] = value;
2000c54a:	7220      	strb	r0, [r4, #8]

    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c54c:	3108      	adds	r1, #8
2000c54e:	69a0      	ldr	r0, [r4, #24]
2000c550:	2201      	movs	r2, #1
2000c552:	f001 fc49 	bl	2000dde8 <usb_transfer_schedule_block>
    usb_transfer_schedule_ack(endpoint->out);
2000c556:	69e0      	ldr	r0, [r4, #28]
2000c558:	f001 fc53 	bl	2000de02 <usb_transfer_schedule_ack>
    return USB_REQUEST_STATUS_OK;
  }
  return USB_REQUEST_STATUS_OK;
}
2000c55c:	2000      	movs	r0, #0
2000c55e:	bd10      	pop	{r4, pc}
2000c560:	2000ef28 	.word	0x2000ef28

2000c564 <usb_vendor_request_set_vga_gain>:
  return USB_REQUEST_STATUS_OK;
}

usb_request_status_t usb_vendor_request_set_vga_gain(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c564:	b510      	push	{r4, lr}
2000c566:	1c04      	adds	r4, r0, #0
  int8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c568:	2900      	cmp	r1, #0
2000c56a:	d10f      	bne.n	2000c58c <usb_vendor_request_set_vga_gain+0x28>
  {
    value = r820t_set_vga_gain(&airspy_conf->r820t_conf_rw, endpoint->setup.index);
2000c56c:	4b08      	ldr	r3, [pc, #32]	; (2000c590 <usb_vendor_request_set_vga_gain+0x2c>)
2000c56e:	7921      	ldrb	r1, [r4, #4]
2000c570:	6818      	ldr	r0, [r3, #0]
2000c572:	3048      	adds	r0, #72	; 0x48
2000c574:	f000 fda2 	bl	2000d0bc <r820t_set_vga_gain>
    endpoint->buffer[0] = value;

    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c578:	1c21      	adds	r1, r4, #0
  int8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    value = r820t_set_vga_gain(&airspy_conf->r820t_conf_rw, endpoint->setup.index);
    endpoint->buffer[0] = value;
2000c57a:	7220      	strb	r0, [r4, #8]

    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c57c:	3108      	adds	r1, #8
2000c57e:	69a0      	ldr	r0, [r4, #24]
2000c580:	2201      	movs	r2, #1
2000c582:	f001 fc31 	bl	2000dde8 <usb_transfer_schedule_block>
    usb_transfer_schedule_ack(endpoint->out);
2000c586:	69e0      	ldr	r0, [r4, #28]
2000c588:	f001 fc3b 	bl	2000de02 <usb_transfer_schedule_ack>
    return USB_REQUEST_STATUS_OK;
  }
  return USB_REQUEST_STATUS_OK;
}
2000c58c:	2000      	movs	r0, #0
2000c58e:	bd10      	pop	{r4, pc}
2000c590:	2000ef28 	.word	0x2000ef28

2000c594 <usb_vendor_request_set_mixer_gain>:
  return USB_REQUEST_STATUS_OK;
}

usb_request_status_t usb_vendor_request_set_mixer_gain(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c594:	b510      	push	{r4, lr}
2000c596:	1c04      	adds	r4, r0, #0
  int8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c598:	2900      	cmp	r1, #0
2000c59a:	d10f      	bne.n	2000c5bc <usb_vendor_request_set_mixer_gain+0x28>
  {
    value = r820t_set_mixer_gain(&airspy_conf->r820t_conf_rw, endpoint->setup.index);
2000c59c:	4b08      	ldr	r3, [pc, #32]	; (2000c5c0 <usb_vendor_request_set_mixer_gain+0x2c>)
2000c59e:	7921      	ldrb	r1, [r4, #4]
2000c5a0:	6818      	ldr	r0, [r3, #0]
2000c5a2:	3048      	adds	r0, #72	; 0x48
2000c5a4:	f000 fd83 	bl	2000d0ae <r820t_set_mixer_gain>
    endpoint->buffer[0] = value;

    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c5a8:	1c21      	adds	r1, r4, #0
  int8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    value = r820t_set_mixer_gain(&airspy_conf->r820t_conf_rw, endpoint->setup.index);
    endpoint->buffer[0] = value;
2000c5aa:	7220      	strb	r0, [r4, #8]

    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c5ac:	3108      	adds	r1, #8
2000c5ae:	69a0      	ldr	r0, [r4, #24]
2000c5b0:	2201      	movs	r2, #1
2000c5b2:	f001 fc19 	bl	2000dde8 <usb_transfer_schedule_block>
    usb_transfer_schedule_ack(endpoint->out);
2000c5b6:	69e0      	ldr	r0, [r4, #28]
2000c5b8:	f001 fc23 	bl	2000de02 <usb_transfer_schedule_ack>
    return USB_REQUEST_STATUS_OK;
  }
  return USB_REQUEST_STATUS_OK;
}
2000c5bc:	2000      	movs	r0, #0
2000c5be:	bd10      	pop	{r4, pc}
2000c5c0:	2000ef28 	.word	0x2000ef28

2000c5c4 <usb_vendor_request_set_lna_gain>:
  }
}

usb_request_status_t usb_vendor_request_set_lna_gain(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c5c4:	b510      	push	{r4, lr}
2000c5c6:	1c04      	adds	r4, r0, #0
  int8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c5c8:	2900      	cmp	r1, #0
2000c5ca:	d10f      	bne.n	2000c5ec <usb_vendor_request_set_lna_gain+0x28>
  {
    value = r820t_set_lna_gain(&airspy_conf->r820t_conf_rw, endpoint->setup.index);
2000c5cc:	4b08      	ldr	r3, [pc, #32]	; (2000c5f0 <usb_vendor_request_set_lna_gain+0x2c>)
2000c5ce:	7921      	ldrb	r1, [r4, #4]
2000c5d0:	6818      	ldr	r0, [r3, #0]
2000c5d2:	3048      	adds	r0, #72	; 0x48
2000c5d4:	f000 fd64 	bl	2000d0a0 <r820t_set_lna_gain>
    endpoint->buffer[0] = value;

    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c5d8:	1c21      	adds	r1, r4, #0
  int8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    value = r820t_set_lna_gain(&airspy_conf->r820t_conf_rw, endpoint->setup.index);
    endpoint->buffer[0] = value;
2000c5da:	7220      	strb	r0, [r4, #8]

    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c5dc:	3108      	adds	r1, #8
2000c5de:	69a0      	ldr	r0, [r4, #24]
2000c5e0:	2201      	movs	r2, #1
2000c5e2:	f001 fc01 	bl	2000dde8 <usb_transfer_schedule_block>
    usb_transfer_schedule_ack(endpoint->out);
2000c5e6:	69e0      	ldr	r0, [r4, #28]
2000c5e8:	f001 fc0b 	bl	2000de02 <usb_transfer_schedule_ack>
    return USB_REQUEST_STATUS_OK;
  }
  return USB_REQUEST_STATUS_OK;
}
2000c5ec:	2000      	movs	r0, #0
2000c5ee:	bd10      	pop	{r4, pc}
2000c5f0:	2000ef28 	.word	0x2000ef28

2000c5f4 <usb_vendor_request_set_freq>:
}

usb_request_status_t usb_vendor_request_set_freq(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage) 
{
2000c5f4:	b510      	push	{r4, lr}
2000c5f6:	1c04      	adds	r4, r0, #0
  if (stage == USB_TRANSFER_STAGE_SETUP) 
2000c5f8:	2900      	cmp	r1, #0
2000c5fa:	d105      	bne.n	2000c608 <usb_vendor_request_set_freq+0x14>
  {
    usb_transfer_schedule_block(endpoint->out, &set_freq_params, sizeof(set_freq_params_t));
2000c5fc:	4909      	ldr	r1, [pc, #36]	; (2000c624 <usb_vendor_request_set_freq+0x30>)
2000c5fe:	2204      	movs	r2, #4
2000c600:	69c0      	ldr	r0, [r0, #28]
2000c602:	f001 fbf1 	bl	2000dde8 <usb_transfer_schedule_block>
    return USB_REQUEST_STATUS_OK;
2000c606:	e00b      	b.n	2000c620 <usb_vendor_request_set_freq+0x2c>
  } else if (stage == USB_TRANSFER_STAGE_DATA) 
2000c608:	2901      	cmp	r1, #1
2000c60a:	d109      	bne.n	2000c620 <usb_vendor_request_set_freq+0x2c>
  {
    r820t_set_freq(&airspy_conf->r820t_conf_rw, set_freq_params.freq_hz);
2000c60c:	4b06      	ldr	r3, [pc, #24]	; (2000c628 <usb_vendor_request_set_freq+0x34>)
2000c60e:	4905      	ldr	r1, [pc, #20]	; (2000c624 <usb_vendor_request_set_freq+0x30>)
2000c610:	6818      	ldr	r0, [r3, #0]
2000c612:	6809      	ldr	r1, [r1, #0]
2000c614:	3048      	adds	r0, #72	; 0x48
2000c616:	f000 fcef 	bl	2000cff8 <r820t_set_freq>
    usb_transfer_schedule_ack(endpoint->in);
2000c61a:	69a0      	ldr	r0, [r4, #24]
2000c61c:	f001 fbf1 	bl	2000de02 <usb_transfer_schedule_ack>
    return USB_REQUEST_STATUS_OK;
  } else
  {
    return USB_REQUEST_STATUS_OK;
  }
}
2000c620:	2000      	movs	r0, #0
2000c622:	bd10      	pop	{r4, pc}
2000c624:	2000f388 	.word	0x2000f388
2000c628:	2000ef28 	.word	0x2000ef28

2000c62c <usb_vendor_request_set_samplerate>:
}

usb_request_status_t usb_vendor_request_set_samplerate(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage) 
{
2000c62c:	b570      	push	{r4, r5, r6, lr}
2000c62e:	1c04      	adds	r4, r0, #0
    endpoint->buffer[0] = 1;
    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
    usb_transfer_schedule_ack(endpoint->out);
    return USB_REQUEST_STATUS_OK;
  }
  return USB_REQUEST_STATUS_OK;
2000c630:	2000      	movs	r0, #0
  uint16_t conf_no;
  uint32_t conf_hz;
  uint32_t freq_hz;
  bool conf_found;

  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c632:	4281      	cmp	r1, r0
2000c634:	d155      	bne.n	2000c6e2 <usb_vendor_request_set_samplerate+0xb6>
  {
    conf_no = endpoint->setup.index;
2000c636:	88a3      	ldrh	r3, [r4, #4]
2000c638:	4a2a      	ldr	r2, [pc, #168]	; (2000c6e4 <usb_vendor_request_set_samplerate+0xb8>)
    if(conf_no < AIRSPY_CONF_NB_MAX)
2000c63a:	2b3f      	cmp	r3, #63	; 0x3f
2000c63c:	d806      	bhi.n	2000c64c <usb_vendor_request_set_samplerate+0x20>
    {
      airspy_conf_nb = airspy_conf->nb_airspy_m0_m4_conf_t;
2000c63e:	6810      	ldr	r0, [r2, #0]
2000c640:	3076      	adds	r0, #118	; 0x76
      if(conf_no > (airspy_conf_nb-1))
2000c642:	8801      	ldrh	r1, [r0, #0]
      {
          return USB_REQUEST_STATUS_STALL;
2000c644:	2001      	movs	r0, #1
  {
    conf_no = endpoint->setup.index;
    if(conf_no < AIRSPY_CONF_NB_MAX)
    {
      airspy_conf_nb = airspy_conf->nb_airspy_m0_m4_conf_t;
      if(conf_no > (airspy_conf_nb-1))
2000c646:	4299      	cmp	r1, r3
2000c648:	dc2a      	bgt.n	2000c6a0 <usb_vendor_request_set_samplerate+0x74>
2000c64a:	e04a      	b.n	2000c6e2 <usb_vendor_request_set_samplerate+0xb6>
        sample_rate_conf_no = conf_no;
      }
    }else
    {
      conf_found = false;
      conf_hz = (uint32_t)(conf_no) * 1000;
2000c64c:	20fa      	movs	r0, #250	; 0xfa

      for(i = 0; i < airspy_conf->nb_airspy_m0_m4_conf_t; i++)
2000c64e:	6812      	ldr	r2, [r2, #0]
        sample_rate_conf_no = conf_no;
      }
    }else
    {
      conf_found = false;
      conf_hz = (uint32_t)(conf_no) * 1000;
2000c650:	0080      	lsls	r0, r0, #2
2000c652:	4358      	muls	r0, r3

      for(i = 0; i < airspy_conf->nb_airspy_m0_m4_conf_t; i++)
2000c654:	1c13      	adds	r3, r2, #0
2000c656:	3376      	adds	r3, #118	; 0x76
2000c658:	881b      	ldrh	r3, [r3, #0]
2000c65a:	4299      	cmp	r1, r3
2000c65c:	da0c      	bge.n	2000c678 <usb_vendor_request_set_samplerate+0x4c>
      {
        freq_hz = (airspy_conf->airspy_m0_m4_conf[i].airspy_m0_conf.r820t_if_freq * 4);
2000c65e:	2518      	movs	r5, #24
2000c660:	434d      	muls	r5, r1
2000c662:	6f96      	ldr	r6, [r2, #120]	; 0x78
2000c664:	1975      	adds	r5, r6, r5
2000c666:	692e      	ldr	r6, [r5, #16]
2000c668:	00b5      	lsls	r5, r6, #2
        if(freq_hz == conf_hz)
2000c66a:	4285      	cmp	r5, r0
2000c66c:	d102      	bne.n	2000c674 <usb_vendor_request_set_samplerate+0x48>
        {
          sample_rate_conf_no = i;
2000c66e:	4a1e      	ldr	r2, [pc, #120]	; (2000c6e8 <usb_vendor_request_set_samplerate+0xbc>)
2000c670:	7011      	strb	r1, [r2, #0]
2000c672:	e01a      	b.n	2000c6aa <usb_vendor_request_set_samplerate+0x7e>
    }else
    {
      conf_found = false;
      conf_hz = (uint32_t)(conf_no) * 1000;

      for(i = 0; i < airspy_conf->nb_airspy_m0_m4_conf_t; i++)
2000c674:	3101      	adds	r1, #1
2000c676:	e7f0      	b.n	2000c65a <usb_vendor_request_set_samplerate+0x2e>
        }
      }

      if(conf_found == false)
      {
        for(i = 0; i < airspy_conf->nb_airspy_m0_m4_alt_conf_t; i++)
2000c678:	1c11      	adds	r1, r2, #0
2000c67a:	317e      	adds	r1, #126	; 0x7e
2000c67c:	8809      	ldrh	r1, [r1, #0]
2000c67e:	2300      	movs	r3, #0
2000c680:	e000      	b.n	2000c684 <usb_vendor_request_set_samplerate+0x58>
2000c682:	3301      	adds	r3, #1
2000c684:	428b      	cmp	r3, r1
2000c686:	da0e      	bge.n	2000c6a6 <usb_vendor_request_set_samplerate+0x7a>
        {
          freq_hz = (airspy_conf->airspy_m0_m4_alt_conf[i].airspy_m0_conf.r820t_if_freq * 4);
2000c688:	1d15      	adds	r5, r2, #4
2000c68a:	6fee      	ldr	r6, [r5, #124]	; 0x7c
2000c68c:	2518      	movs	r5, #24
2000c68e:	435d      	muls	r5, r3
2000c690:	1976      	adds	r6, r6, r5
2000c692:	6935      	ldr	r5, [r6, #16]
2000c694:	00ae      	lsls	r6, r5, #2
          if(freq_hz == conf_hz)
2000c696:	4286      	cmp	r6, r0
2000c698:	d1f3      	bne.n	2000c682 <usb_vendor_request_set_samplerate+0x56>
          {
            sample_rate_conf_no = AIRSPY_SAMPLERATE_CONF_ALT | i;
2000c69a:	2080      	movs	r0, #128	; 0x80
2000c69c:	4241      	negs	r1, r0
2000c69e:	430b      	orrs	r3, r1
2000c6a0:	4e11      	ldr	r6, [pc, #68]	; (2000c6e8 <usb_vendor_request_set_samplerate+0xbc>)
2000c6a2:	7033      	strb	r3, [r6, #0]
2000c6a4:	e001      	b.n	2000c6aa <usb_vendor_request_set_samplerate+0x7e>
    if(conf_no < AIRSPY_CONF_NB_MAX)
    {
      airspy_conf_nb = airspy_conf->nb_airspy_m0_m4_conf_t;
      if(conf_no > (airspy_conf_nb-1))
      {
          return USB_REQUEST_STATUS_STALL;
2000c6a6:	2001      	movs	r0, #1
2000c6a8:	e01b      	b.n	2000c6e2 <usb_vendor_request_set_samplerate+0xb6>
      {
        return USB_REQUEST_STATUS_STALL;
      }
    }

    rx_mode = get_receiver_mode();
2000c6aa:	f7ff fe25 	bl	2000c2f8 <get_receiver_mode>
2000c6ae:	4d0e      	ldr	r5, [pc, #56]	; (2000c6e8 <usb_vendor_request_set_samplerate+0xbc>)
2000c6b0:	1e06      	subs	r6, r0, #0
    if(rx_mode == RECEIVER_MODE_RX)
2000c6b2:	2e01      	cmp	r6, #1
2000c6b4:	d102      	bne.n	2000c6bc <usb_vendor_request_set_samplerate+0x90>
    {
      ADCHS_stop(sample_rate_conf_no);
2000c6b6:	7828      	ldrb	r0, [r5, #0]
2000c6b8:	f7ff fd70 	bl	2000c19c <ADCHS_stop>
    }

    set_samplerate_m4(sample_rate_conf_no);
2000c6bc:	7828      	ldrb	r0, [r5, #0]
2000c6be:	f7ff fd09 	bl	2000c0d4 <set_samplerate_m4>

    if(rx_mode == RECEIVER_MODE_RX)
2000c6c2:	2e01      	cmp	r6, #1
2000c6c4:	d102      	bne.n	2000c6cc <usb_vendor_request_set_samplerate+0xa0>
    {
      ADCHS_start(sample_rate_conf_no);
2000c6c6:	7828      	ldrb	r0, [r5, #0]
2000c6c8:	f7ff fd20 	bl	2000c10c <ADCHS_start>
    }

    endpoint->buffer[0] = 1;
2000c6cc:	2201      	movs	r2, #1
    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c6ce:	1c21      	adds	r1, r4, #0
    if(rx_mode == RECEIVER_MODE_RX)
    {
      ADCHS_start(sample_rate_conf_no);
    }

    endpoint->buffer[0] = 1;
2000c6d0:	7222      	strb	r2, [r4, #8]
    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c6d2:	3108      	adds	r1, #8
2000c6d4:	69a0      	ldr	r0, [r4, #24]
2000c6d6:	f001 fb87 	bl	2000dde8 <usb_transfer_schedule_block>
    usb_transfer_schedule_ack(endpoint->out);
2000c6da:	69e0      	ldr	r0, [r4, #28]
2000c6dc:	f001 fb91 	bl	2000de02 <usb_transfer_schedule_ack>
    return USB_REQUEST_STATUS_OK;
2000c6e0:	2000      	movs	r0, #0
  }
  return USB_REQUEST_STATUS_OK;
}
2000c6e2:	bd70      	pop	{r4, r5, r6, pc}
2000c6e4:	2000ef28 	.word	0x2000ef28
2000c6e8:	2000f500 	.word	0x2000f500

2000c6ec <usb_vendor_request_set_packing_command>:
}

usb_request_status_t usb_vendor_request_set_packing_command(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage) 
{
2000c6ec:	b570      	push	{r4, r5, r6, lr}
2000c6ee:	1c04      	adds	r4, r0, #0
    endpoint->buffer[0] = 1;
    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
    usb_transfer_schedule_ack(endpoint->out);
    return USB_REQUEST_STATUS_OK;
  }
  return USB_REQUEST_STATUS_OK;
2000c6f0:	2000      	movs	r0, #0
const usb_transfer_stage_t stage) 
{
  receiver_mode_t rx_mode;
  uint8_t state;

  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c6f2:	4281      	cmp	r1, r0
2000c6f4:	d121      	bne.n	2000c73a <usb_vendor_request_set_packing_command+0x4e>
  {
    if(endpoint->setup.index > 1)
2000c6f6:	88a3      	ldrh	r3, [r4, #4]
    {
      return USB_REQUEST_STATUS_STALL;
2000c6f8:	2001      	movs	r0, #1
  receiver_mode_t rx_mode;
  uint8_t state;

  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    if(endpoint->setup.index > 1)
2000c6fa:	4283      	cmp	r3, r0
2000c6fc:	d81d      	bhi.n	2000c73a <usb_vendor_request_set_packing_command+0x4e>
    {
      return USB_REQUEST_STATUS_STALL;
    }else
    {
      state = endpoint->setup.index;
2000c6fe:	b2de      	uxtb	r6, r3
    }

    rx_mode = get_receiver_mode();
2000c700:	f7ff fdfa 	bl	2000c2f8 <get_receiver_mode>
2000c704:	1e05      	subs	r5, r0, #0
    if(rx_mode == RECEIVER_MODE_RX)
2000c706:	2d01      	cmp	r5, #1
2000c708:	d103      	bne.n	2000c712 <usb_vendor_request_set_packing_command+0x26>
    {
      ADCHS_stop(sample_rate_conf_no);
2000c70a:	480c      	ldr	r0, [pc, #48]	; (2000c73c <usb_vendor_request_set_packing_command+0x50>)
2000c70c:	7800      	ldrb	r0, [r0, #0]
2000c70e:	f7ff fd45 	bl	2000c19c <ADCHS_stop>
    }

    set_packing_m4(state);
2000c712:	1c30      	adds	r0, r6, #0
2000c714:	f7ff fcec 	bl	2000c0f0 <set_packing_m4>

    if(rx_mode == RECEIVER_MODE_RX)
2000c718:	2d01      	cmp	r5, #1
2000c71a:	d103      	bne.n	2000c724 <usb_vendor_request_set_packing_command+0x38>
    {
      ADCHS_start(sample_rate_conf_no);
2000c71c:	4907      	ldr	r1, [pc, #28]	; (2000c73c <usb_vendor_request_set_packing_command+0x50>)
2000c71e:	7808      	ldrb	r0, [r1, #0]
2000c720:	f7ff fcf4 	bl	2000c10c <ADCHS_start>
    }

    endpoint->buffer[0] = 1;
2000c724:	2201      	movs	r2, #1
    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c726:	1c21      	adds	r1, r4, #0
    if(rx_mode == RECEIVER_MODE_RX)
    {
      ADCHS_start(sample_rate_conf_no);
    }

    endpoint->buffer[0] = 1;
2000c728:	7222      	strb	r2, [r4, #8]
    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c72a:	3108      	adds	r1, #8
2000c72c:	69a0      	ldr	r0, [r4, #24]
2000c72e:	f001 fb5b 	bl	2000dde8 <usb_transfer_schedule_block>
    usb_transfer_schedule_ack(endpoint->out);
2000c732:	69e0      	ldr	r0, [r4, #28]
2000c734:	f001 fb65 	bl	2000de02 <usb_transfer_schedule_ack>
2000c738:	2000      	movs	r0, #0
    return USB_REQUEST_STATUS_OK;
  }
  return USB_REQUEST_STATUS_OK;
}
2000c73a:	bd70      	pop	{r4, r5, r6, pc}
2000c73c:	2000f500 	.word	0x2000f500

2000c740 <usb_vendor_request_read_partid_serialno>:
  uint32_t serial_no[4];
} read_partid_serialno_t;

usb_request_status_t usb_vendor_request_read_partid_serialno(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c740:	b570      	push	{r4, r5, r6, lr}
    
    length = (uint8_t)sizeof(read_partid_serialno_t);
    usb_transfer_schedule_block(endpoint->in, &read_partid_serialno, length);
    usb_transfer_schedule_ack(endpoint->out);
  }
  return USB_REQUEST_STATUS_OK;
2000c742:	2500      	movs	r5, #0
  uint32_t serial_no[4];
} read_partid_serialno_t;

usb_request_status_t usb_vendor_request_read_partid_serialno(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c744:	b092      	sub	sp, #72	; 0x48
2000c746:	1c06      	adds	r6, r0, #0
  uint8_t length;
  read_partid_serialno_t read_partid_serialno;
  iap_cmd_res_t iap_cmd_res;

  if (stage == USB_TRANSFER_STAGE_SETUP) 
2000c748:	42a9      	cmp	r1, r5
2000c74a:	d126      	bne.n	2000c79a <usb_vendor_request_read_partid_serialno+0x5a>
  {
    /* Read IAP Part Number Identification */
    iap_cmd_res.cmd_param.command_code = IAP_CMD_READ_PART_ID_NO;
2000c74c:	ac07      	add	r4, sp, #28
2000c74e:	2336      	movs	r3, #54	; 0x36
    iap_cmd_call(&iap_cmd_res);
2000c750:	1c20      	adds	r0, r4, #0
  iap_cmd_res_t iap_cmd_res;

  if (stage == USB_TRANSFER_STAGE_SETUP) 
  {
    /* Read IAP Part Number Identification */
    iap_cmd_res.cmd_param.command_code = IAP_CMD_READ_PART_ID_NO;
2000c752:	7023      	strb	r3, [r4, #0]
    iap_cmd_call(&iap_cmd_res);
2000c754:	f000 ffc0 	bl	2000d6d8 <iap_cmd_call>
    if(iap_cmd_res.status_res.status_ret != CMD_SUCCESS)
2000c758:	8b20      	ldrh	r0, [r4, #24]
2000c75a:	42a8      	cmp	r0, r5
2000c75c:	d001      	beq.n	2000c762 <usb_vendor_request_read_partid_serialno+0x22>
      return USB_REQUEST_STATUS_STALL;
2000c75e:	2501      	movs	r5, #1
2000c760:	e01b      	b.n	2000c79a <usb_vendor_request_read_partid_serialno+0x5a>

    read_partid_serialno.part_id[0] = iap_cmd_res.status_res.iap_result[0];
2000c762:	69e1      	ldr	r1, [r4, #28]
    read_partid_serialno.part_id[1] = iap_cmd_res.status_res.iap_result[1];
2000c764:	6a22      	ldr	r2, [r4, #32]
    
    /* Read IAP Serial Number Identification */
    iap_cmd_res.cmd_param.command_code = IAP_CMD_READ_SERIAL_NO;
2000c766:	233a      	movs	r3, #58	; 0x3a
    iap_cmd_call(&iap_cmd_res);
2000c768:	1c20      	adds	r0, r4, #0
    iap_cmd_res.cmd_param.command_code = IAP_CMD_READ_PART_ID_NO;
    iap_cmd_call(&iap_cmd_res);
    if(iap_cmd_res.status_res.status_ret != CMD_SUCCESS)
      return USB_REQUEST_STATUS_STALL;

    read_partid_serialno.part_id[0] = iap_cmd_res.status_res.iap_result[0];
2000c76a:	9101      	str	r1, [sp, #4]
    read_partid_serialno.part_id[1] = iap_cmd_res.status_res.iap_result[1];
2000c76c:	9202      	str	r2, [sp, #8]
    
    /* Read IAP Serial Number Identification */
    iap_cmd_res.cmd_param.command_code = IAP_CMD_READ_SERIAL_NO;
2000c76e:	7023      	strb	r3, [r4, #0]
    iap_cmd_call(&iap_cmd_res);
2000c770:	f000 ffb2 	bl	2000d6d8 <iap_cmd_call>
    if(iap_cmd_res.status_res.status_ret != CMD_SUCCESS)
2000c774:	8b20      	ldrh	r0, [r4, #24]
2000c776:	2800      	cmp	r0, #0
2000c778:	d1f1      	bne.n	2000c75e <usb_vendor_request_read_partid_serialno+0x1e>
      return USB_REQUEST_STATUS_STALL;

    read_partid_serialno.serial_no[0] = iap_cmd_res.status_res.iap_result[0];
2000c77a:	69e1      	ldr	r1, [r4, #28]
    read_partid_serialno.serial_no[1] = iap_cmd_res.status_res.iap_result[1];
2000c77c:	6a22      	ldr	r2, [r4, #32]
    read_partid_serialno.serial_no[2] = iap_cmd_res.status_res.iap_result[2];
2000c77e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    read_partid_serialno.serial_no[3] = iap_cmd_res.status_res.iap_result[3];
2000c780:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    iap_cmd_res.cmd_param.command_code = IAP_CMD_READ_SERIAL_NO;
    iap_cmd_call(&iap_cmd_res);
    if(iap_cmd_res.status_res.status_ret != CMD_SUCCESS)
      return USB_REQUEST_STATUS_STALL;

    read_partid_serialno.serial_no[0] = iap_cmd_res.status_res.iap_result[0];
2000c782:	9103      	str	r1, [sp, #12]
    read_partid_serialno.serial_no[1] = iap_cmd_res.status_res.iap_result[1];
2000c784:	9204      	str	r2, [sp, #16]
    read_partid_serialno.serial_no[2] = iap_cmd_res.status_res.iap_result[2];
    read_partid_serialno.serial_no[3] = iap_cmd_res.status_res.iap_result[3];
    
    length = (uint8_t)sizeof(read_partid_serialno_t);
    usb_transfer_schedule_block(endpoint->in, &read_partid_serialno, length);
2000c786:	69b0      	ldr	r0, [r6, #24]
2000c788:	a901      	add	r1, sp, #4
2000c78a:	2218      	movs	r2, #24
    if(iap_cmd_res.status_res.status_ret != CMD_SUCCESS)
      return USB_REQUEST_STATUS_STALL;

    read_partid_serialno.serial_no[0] = iap_cmd_res.status_res.iap_result[0];
    read_partid_serialno.serial_no[1] = iap_cmd_res.status_res.iap_result[1];
    read_partid_serialno.serial_no[2] = iap_cmd_res.status_res.iap_result[2];
2000c78c:	9305      	str	r3, [sp, #20]
    read_partid_serialno.serial_no[3] = iap_cmd_res.status_res.iap_result[3];
2000c78e:	9406      	str	r4, [sp, #24]
    
    length = (uint8_t)sizeof(read_partid_serialno_t);
    usb_transfer_schedule_block(endpoint->in, &read_partid_serialno, length);
2000c790:	f001 fb2a 	bl	2000dde8 <usb_transfer_schedule_block>
    usb_transfer_schedule_ack(endpoint->out);
2000c794:	69f0      	ldr	r0, [r6, #28]
2000c796:	f001 fb34 	bl	2000de02 <usb_transfer_schedule_ack>
  }
  return USB_REQUEST_STATUS_OK;
}
2000c79a:	1c28      	adds	r0, r5, #0
2000c79c:	b012      	add	sp, #72	; 0x48
2000c79e:	bd70      	pop	{r4, r5, r6, pc}

2000c7a0 <usb_vendor_request_read_version_string>:
  return USB_REQUEST_STATUS_OK;
}

usb_request_status_t usb_vendor_request_read_version_string(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c7a0:	b538      	push	{r3, r4, r5, lr}
2000c7a2:	1c05      	adds	r5, r0, #0
  unsigned int i;
  int version_string_len;

  if (stage == USB_TRANSFER_STAGE_SETUP) {
2000c7a4:	2900      	cmp	r1, #0
2000c7a6:	d122      	bne.n	2000c7ee <usb_vendor_request_read_version_string+0x4e>
    for(i = 0; i < sizeof(spiflash_buffer); i++)
      spiflash_buffer[i] = 0;
2000c7a8:	4c12      	ldr	r4, [pc, #72]	; (2000c7f4 <usb_vendor_request_read_version_string+0x54>)
2000c7aa:	2200      	movs	r2, #0
2000c7ac:	190b      	adds	r3, r1, r4
{
  unsigned int i;
  int version_string_len;

  if (stage == USB_TRANSFER_STAGE_SETUP) {
    for(i = 0; i < sizeof(spiflash_buffer); i++)
2000c7ae:	2080      	movs	r0, #128	; 0x80
2000c7b0:	3101      	adds	r1, #1
      spiflash_buffer[i] = 0;
2000c7b2:	701a      	strb	r2, [r3, #0]
{
  unsigned int i;
  int version_string_len;

  if (stage == USB_TRANSFER_STAGE_SETUP) {
    for(i = 0; i < sizeof(spiflash_buffer); i++)
2000c7b4:	0043      	lsls	r3, r0, #1
2000c7b6:	4299      	cmp	r1, r3
2000c7b8:	d1f6      	bne.n	2000c7a8 <usb_vendor_request_read_version_string+0x8>
      spiflash_buffer[i] = 0;
    
    strcpy((char *)spiflash_buffer, (char *)airspy_conf->conf_hw.version);
2000c7ba:	490f      	ldr	r1, [pc, #60]	; (2000c7f8 <usb_vendor_request_read_version_string+0x58>)
2000c7bc:	1c20      	adds	r0, r4, #0
2000c7be:	6809      	ldr	r1, [r1, #0]
2000c7c0:	3108      	adds	r1, #8
2000c7c2:	f002 f8b5 	bl	2000e930 <strcpy>
    version_string_len = strlen((char *)spiflash_buffer);
2000c7c6:	1c20      	adds	r0, r4, #0
2000c7c8:	f002 f8ba 	bl	2000e940 <strlen>
    strcpy((char *)&spiflash_buffer[version_string_len], version_string);
2000c7cc:	490b      	ldr	r1, [pc, #44]	; (2000c7fc <usb_vendor_request_read_version_string+0x5c>)
2000c7ce:	1900      	adds	r0, r0, r4
2000c7d0:	f002 f8ae 	bl	2000e930 <strcpy>
    version_string_len = strlen((char *)spiflash_buffer) + 1;
2000c7d4:	1c20      	adds	r0, r4, #0
2000c7d6:	f002 f8b3 	bl	2000e940 <strlen>
    version_string_len = (version_string_len + 3) & ~0x03; /* Round to a multiple of 4 */
2000c7da:	1d02      	adds	r2, r0, #4
2000c7dc:	2003      	movs	r0, #3
2000c7de:	4382      	bics	r2, r0

    usb_transfer_schedule_block(endpoint->in, spiflash_buffer, version_string_len);
2000c7e0:	1c21      	adds	r1, r4, #0
2000c7e2:	69a8      	ldr	r0, [r5, #24]
2000c7e4:	f001 fb00 	bl	2000dde8 <usb_transfer_schedule_block>
    usb_transfer_schedule_ack(endpoint->out);
2000c7e8:	69e8      	ldr	r0, [r5, #28]
2000c7ea:	f001 fb0a 	bl	2000de02 <usb_transfer_schedule_ack>
  }
  return USB_REQUEST_STATUS_OK;
}
2000c7ee:	2000      	movs	r0, #0
2000c7f0:	bd38      	pop	{r3, r4, r5, pc}
2000c7f2:	46c0      	nop			; (mov r8, r8)
2000c7f4:	2000f400 	.word	0x2000f400
2000c7f8:	2000ef28 	.word	0x2000ef28
2000c7fc:	2000e950 	.word	0x2000e950

2000c800 <usb_vendor_request_read_spiflash>:
  }
}

usb_request_status_t usb_vendor_request_read_spiflash(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c800:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000c802:	1c05      	adds	r5, r0, #0
  uint16_t len;
  uint8_t* u8_addr_pt;
  uint32_t* u32_addr_pt;
  uint32_t* u32_dest_pt;

  if (stage == USB_TRANSFER_STAGE_SETUP) 
2000c804:	2900      	cmp	r1, #0
2000c806:	d131      	bne.n	2000c86c <usb_vendor_request_read_spiflash+0x6c>
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
    len = endpoint->setup.length;
2000c808:	88c4      	ldrh	r4, [r0, #6]
  uint32_t* u32_addr_pt;
  uint32_t* u32_dest_pt;

  if (stage == USB_TRANSFER_STAGE_SETUP) 
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
2000c80a:	8847      	ldrh	r7, [r0, #2]
2000c80c:	8882      	ldrh	r2, [r0, #4]
    len = endpoint->setup.length;

    if(len > W25Q80BV_PAGE_LEN)
2000c80e:	2680      	movs	r6, #128	; 0x80
    {
      return USB_REQUEST_STATUS_STALL;
2000c810:	2001      	movs	r0, #1
  if (stage == USB_TRANSFER_STAGE_SETUP) 
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
    len = endpoint->setup.length;

    if(len > W25Q80BV_PAGE_LEN)
2000c812:	4086      	lsls	r6, r0
2000c814:	42b4      	cmp	r4, r6
2000c816:	d836      	bhi.n	2000c886 <usb_vendor_request_read_spiflash+0x86>
  uint32_t* u32_addr_pt;
  uint32_t* u32_dest_pt;

  if (stage == USB_TRANSFER_STAGE_SETUP) 
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
2000c818:	0438      	lsls	r0, r7, #16
2000c81a:	4310      	orrs	r0, r2
    if(len > W25Q80BV_PAGE_LEN)
    {
      return USB_REQUEST_STATUS_STALL;
    } else 
    {
      if((addr + len) > W25Q80BV_NUM_BYTES)
2000c81c:	2380      	movs	r3, #128	; 0x80
2000c81e:	1907      	adds	r7, r0, r4
2000c820:	4e19      	ldr	r6, [pc, #100]	; (2000c888 <usb_vendor_request_read_spiflash+0x88>)
2000c822:	035a      	lsls	r2, r3, #13
2000c824:	4297      	cmp	r7, r2
2000c826:	d917      	bls.n	2000c858 <usb_vendor_request_read_spiflash+0x58>
      {
        if( (len >= 4) &&
2000c828:	2c03      	cmp	r4, #3
2000c82a:	d90d      	bls.n	2000c848 <usb_vendor_request_read_spiflash+0x48>
            ((len & ADDR_ALIGN_32BITS) == 0) &&
2000c82c:	2303      	movs	r3, #3
      return USB_REQUEST_STATUS_STALL;
    } else 
    {
      if((addr + len) > W25Q80BV_NUM_BYTES)
      {
        if( (len >= 4) &&
2000c82e:	1c27      	adds	r7, r4, #0
2000c830:	401f      	ands	r7, r3
2000c832:	d109      	bne.n	2000c848 <usb_vendor_request_read_spiflash+0x48>
            ((len & ADDR_ALIGN_32BITS) == 0) &&
            ((addr & ADDR_ALIGN_32BITS) == 0)
2000c834:	4003      	ands	r3, r0
    } else 
    {
      if((addr + len) > W25Q80BV_NUM_BYTES)
      {
        if( (len >= 4) &&
            ((len & ADDR_ALIGN_32BITS) == 0) &&
2000c836:	d108      	bne.n	2000c84a <usb_vendor_request_read_spiflash+0x4a>
            ((addr & ADDR_ALIGN_32BITS) == 0)
          )
        {
          u32_addr_pt = (uint32_t*)addr;
          u32_dest_pt = (uint32_t*)&spiflash_buffer[0];
          for(i=0; i<(len/4); i++)
2000c838:	08a1      	lsrs	r1, r4, #2
  } else {
    return USB_REQUEST_STATUS_OK;
  }
}

usb_request_status_t usb_vendor_request_read_spiflash(
2000c83a:	009a      	lsls	r2, r3, #2
        {
          u32_addr_pt = (uint32_t*)addr;
          u32_dest_pt = (uint32_t*)&spiflash_buffer[0];
          for(i=0; i<(len/4); i++)
          {
            u32_dest_pt[i] = u32_addr_pt[i];
2000c83c:	5817      	ldr	r7, [r2, r0]
            ((addr & ADDR_ALIGN_32BITS) == 0)
          )
        {
          u32_addr_pt = (uint32_t*)addr;
          u32_dest_pt = (uint32_t*)&spiflash_buffer[0];
          for(i=0; i<(len/4); i++)
2000c83e:	3301      	adds	r3, #1
          {
            u32_dest_pt[i] = u32_addr_pt[i];
2000c840:	50b7      	str	r7, [r6, r2]
            ((addr & ADDR_ALIGN_32BITS) == 0)
          )
        {
          u32_addr_pt = (uint32_t*)addr;
          u32_dest_pt = (uint32_t*)&spiflash_buffer[0];
          for(i=0; i<(len/4); i++)
2000c842:	428b      	cmp	r3, r1
2000c844:	d3f9      	bcc.n	2000c83a <usb_vendor_request_read_spiflash+0x3a>
2000c846:	e00b      	b.n	2000c860 <usb_vendor_request_read_spiflash+0x60>
2000c848:	e000      	b.n	2000c84c <usb_vendor_request_read_spiflash+0x4c>
            u32_dest_pt[i] = u32_addr_pt[i];
          }
        } else
        {
          u8_addr_pt = (uint8_t*)addr;
          for(i=0; i<len; i++)
2000c84a:	1c39      	adds	r1, r7, #0
2000c84c:	42a1      	cmp	r1, r4
2000c84e:	d207      	bcs.n	2000c860 <usb_vendor_request_read_spiflash+0x60>
          {
            spiflash_buffer[i] = u8_addr_pt[i];
2000c850:	5c0a      	ldrb	r2, [r1, r0]
2000c852:	5472      	strb	r2, [r6, r1]
            u32_dest_pt[i] = u32_addr_pt[i];
          }
        } else
        {
          u8_addr_pt = (uint8_t*)addr;
          for(i=0; i<len; i++)
2000c854:	3101      	adds	r1, #1
2000c856:	e7f9      	b.n	2000c84c <usb_vendor_request_read_spiflash+0x4c>
            spiflash_buffer[i] = u8_addr_pt[i];
          }
        }
      } else
      {
        w25q80bv_read(addr, len, &spiflash_buffer[0]);
2000c858:	1c21      	adds	r1, r4, #0
2000c85a:	1c32      	adds	r2, r6, #0
2000c85c:	f000 fef2 	bl	2000d644 <w25q80bv_read>
      }
      usb_transfer_schedule_block(endpoint->in, &spiflash_buffer[0], len);
2000c860:	69a8      	ldr	r0, [r5, #24]
2000c862:	1c31      	adds	r1, r6, #0
2000c864:	1c22      	adds	r2, r4, #0
2000c866:	f001 fabf 	bl	2000dde8 <usb_transfer_schedule_block>
2000c86a:	e00b      	b.n	2000c884 <usb_vendor_request_read_spiflash+0x84>
      usb_transfer_schedule_ack(endpoint->out);
      return USB_REQUEST_STATUS_OK;
    }
  } else 
  {
    return USB_REQUEST_STATUS_OK;
2000c86c:	2000      	movs	r0, #0
        w25q80bv_read(addr, len, &spiflash_buffer[0]);
      }
      usb_transfer_schedule_block(endpoint->in, &spiflash_buffer[0], len);
      return USB_REQUEST_STATUS_OK;
    }
  } else if (stage == USB_TRANSFER_STAGE_DATA) 
2000c86e:	2901      	cmp	r1, #1
2000c870:	d109      	bne.n	2000c886 <usb_vendor_request_read_spiflash+0x86>
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
    len = endpoint->setup.length;
    /* This check is redundant but makes me feel better. */
    if(len > W25Q80BV_PAGE_LEN) 
2000c872:	88ea      	ldrh	r2, [r5, #6]
2000c874:	2380      	movs	r3, #128	; 0x80
    {
      return USB_REQUEST_STATUS_STALL;
2000c876:	1c08      	adds	r0, r1, #0
  } else if (stage == USB_TRANSFER_STAGE_DATA) 
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
    len = endpoint->setup.length;
    /* This check is redundant but makes me feel better. */
    if(len > W25Q80BV_PAGE_LEN) 
2000c878:	0059      	lsls	r1, r3, #1
2000c87a:	428a      	cmp	r2, r1
2000c87c:	d803      	bhi.n	2000c886 <usb_vendor_request_read_spiflash+0x86>
    {
      return USB_REQUEST_STATUS_STALL;
    } else
    {
      usb_transfer_schedule_ack(endpoint->out);
2000c87e:	69e8      	ldr	r0, [r5, #28]
2000c880:	f001 fabf 	bl	2000de02 <usb_transfer_schedule_ack>
      return USB_REQUEST_STATUS_OK;
2000c884:	2000      	movs	r0, #0
    }
  } else 
  {
    return USB_REQUEST_STATUS_OK;
  }
}
2000c886:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2000c888:	2000f400 	.word	0x2000f400

2000c88c <usb_vendor_request_write_spiflash>:
  return USB_REQUEST_STATUS_OK;
}

usb_request_status_t usb_vendor_request_write_spiflash(
usb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)
{
2000c88c:	b570      	push	{r4, r5, r6, lr}
2000c88e:	1c04      	adds	r4, r0, #0
2000c890:	1e0d      	subs	r5, r1, #0
  uint32_t addr = 0;
  uint16_t len = 0;

  if (stage == USB_TRANSFER_STAGE_SETUP)
2000c892:	d117      	bne.n	2000c8c4 <usb_vendor_request_write_spiflash+0x38>
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
    len = endpoint->setup.length;
2000c894:	88e2      	ldrh	r2, [r4, #6]
    if ((len > W25Q80BV_PAGE_LEN) || (addr > W25Q80BV_NUM_BYTES)
        || ((addr + len) > W25Q80BV_NUM_BYTES))
    {
      return USB_REQUEST_STATUS_STALL;
2000c896:	2301      	movs	r3, #1

  if (stage == USB_TRANSFER_STAGE_SETUP)
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
    len = endpoint->setup.length;
    if ((len > W25Q80BV_PAGE_LEN) || (addr > W25Q80BV_NUM_BYTES)
2000c898:	2680      	movs	r6, #128	; 0x80
  uint32_t addr = 0;
  uint16_t len = 0;

  if (stage == USB_TRANSFER_STAGE_SETUP)
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
2000c89a:	8840      	ldrh	r0, [r0, #2]
2000c89c:	88a1      	ldrh	r1, [r4, #4]
    len = endpoint->setup.length;
    if ((len > W25Q80BV_PAGE_LEN) || (addr > W25Q80BV_NUM_BYTES)
2000c89e:	409e      	lsls	r6, r3
2000c8a0:	42b2      	cmp	r2, r6
2000c8a2:	d82a      	bhi.n	2000c8fa <usb_vendor_request_write_spiflash+0x6e>
  uint32_t addr = 0;
  uint16_t len = 0;

  if (stage == USB_TRANSFER_STAGE_SETUP)
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
2000c8a4:	0405      	lsls	r5, r0, #16
    len = endpoint->setup.length;
    if ((len > W25Q80BV_PAGE_LEN) || (addr > W25Q80BV_NUM_BYTES)
2000c8a6:	2080      	movs	r0, #128	; 0x80
  uint32_t addr = 0;
  uint16_t len = 0;

  if (stage == USB_TRANSFER_STAGE_SETUP)
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
2000c8a8:	430d      	orrs	r5, r1
    len = endpoint->setup.length;
    if ((len > W25Q80BV_PAGE_LEN) || (addr > W25Q80BV_NUM_BYTES)
2000c8aa:	0341      	lsls	r1, r0, #13
2000c8ac:	428d      	cmp	r5, r1
2000c8ae:	d824      	bhi.n	2000c8fa <usb_vendor_request_write_spiflash+0x6e>
        || ((addr + len) > W25Q80BV_NUM_BYTES))
2000c8b0:	18ae      	adds	r6, r5, r2
2000c8b2:	428e      	cmp	r6, r1
2000c8b4:	d821      	bhi.n	2000c8fa <usb_vendor_request_write_spiflash+0x6e>
    {
      return USB_REQUEST_STATUS_STALL;
    } else
    {
      usb_transfer_schedule_block(endpoint->out, &spiflash_buffer[0], len);
2000c8b6:	4912      	ldr	r1, [pc, #72]	; (2000c900 <usb_vendor_request_write_spiflash+0x74>)
2000c8b8:	69e0      	ldr	r0, [r4, #28]
2000c8ba:	f001 fa95 	bl	2000dde8 <usb_transfer_schedule_block>
      w25q80bv_setup();
2000c8be:	f000 fd31 	bl	2000d324 <w25q80bv_setup>
2000c8c2:	e019      	b.n	2000c8f8 <usb_vendor_request_write_spiflash+0x6c>
      w25q80bv_program(addr, len, &spiflash_buffer[0]);
      usb_transfer_schedule_ack(endpoint->in);
      return USB_REQUEST_STATUS_OK;
    }
  } else {
    return USB_REQUEST_STATUS_OK;
2000c8c4:	2300      	movs	r3, #0
    {
      usb_transfer_schedule_block(endpoint->out, &spiflash_buffer[0], len);
      w25q80bv_setup();
      return USB_REQUEST_STATUS_OK;
    }
  } else if (stage == USB_TRANSFER_STAGE_DATA)
2000c8c6:	2901      	cmp	r1, #1
2000c8c8:	d117      	bne.n	2000c8fa <usb_vendor_request_write_spiflash+0x6e>
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
    len = endpoint->setup.length;
2000c8ca:	88e1      	ldrh	r1, [r4, #6]
    /* This check is redundant but makes me feel better. */
    if ((len > W25Q80BV_PAGE_LEN) || (addr > W25Q80BV_NUM_BYTES)
2000c8cc:	2680      	movs	r6, #128	; 0x80
        || ((addr + len) > W25Q80BV_NUM_BYTES))
    {
      return USB_REQUEST_STATUS_STALL;
2000c8ce:	1c2b      	adds	r3, r5, #0
      w25q80bv_setup();
      return USB_REQUEST_STATUS_OK;
    }
  } else if (stage == USB_TRANSFER_STAGE_DATA)
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
2000c8d0:	8840      	ldrh	r0, [r0, #2]
2000c8d2:	88a2      	ldrh	r2, [r4, #4]
    len = endpoint->setup.length;
    /* This check is redundant but makes me feel better. */
    if ((len > W25Q80BV_PAGE_LEN) || (addr > W25Q80BV_NUM_BYTES)
2000c8d4:	0075      	lsls	r5, r6, #1
2000c8d6:	42a9      	cmp	r1, r5
2000c8d8:	d80f      	bhi.n	2000c8fa <usb_vendor_request_write_spiflash+0x6e>
      w25q80bv_setup();
      return USB_REQUEST_STATUS_OK;
    }
  } else if (stage == USB_TRANSFER_STAGE_DATA)
  {
    addr = (endpoint->setup.value << 16) | endpoint->setup.index;
2000c8da:	0400      	lsls	r0, r0, #16
2000c8dc:	4310      	orrs	r0, r2
    len = endpoint->setup.length;
    /* This check is redundant but makes me feel better. */
    if ((len > W25Q80BV_PAGE_LEN) || (addr > W25Q80BV_NUM_BYTES)
2000c8de:	2280      	movs	r2, #128	; 0x80
2000c8e0:	0356      	lsls	r6, r2, #13
2000c8e2:	42b0      	cmp	r0, r6
2000c8e4:	d809      	bhi.n	2000c8fa <usb_vendor_request_write_spiflash+0x6e>
        || ((addr + len) > W25Q80BV_NUM_BYTES))
2000c8e6:	1845      	adds	r5, r0, r1
2000c8e8:	42b5      	cmp	r5, r6
2000c8ea:	d806      	bhi.n	2000c8fa <usb_vendor_request_write_spiflash+0x6e>
    {
      return USB_REQUEST_STATUS_STALL;
    } else {
      w25q80bv_program(addr, len, &spiflash_buffer[0]);
2000c8ec:	4a04      	ldr	r2, [pc, #16]	; (2000c900 <usb_vendor_request_write_spiflash+0x74>)
2000c8ee:	f000 fe69 	bl	2000d5c4 <w25q80bv_program>
      usb_transfer_schedule_ack(endpoint->in);
2000c8f2:	69a0      	ldr	r0, [r4, #24]
2000c8f4:	f001 fa85 	bl	2000de02 <usb_transfer_schedule_ack>
      return USB_REQUEST_STATUS_OK;
2000c8f8:	2300      	movs	r3, #0
    }
  } else {
    return USB_REQUEST_STATUS_OK;
  }
}
2000c8fa:	1c18      	adds	r0, r3, #0
2000c8fc:	bd70      	pop	{r4, r5, r6, pc}
2000c8fe:	46c0      	nop			; (mov r8, r8)
2000c900:	2000f400 	.word	0x2000f400

2000c904 <usb_vendor_request_read_r820t>:
}

usb_request_status_t usb_vendor_request_read_r820t(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
2000c904:	b570      	push	{r4, r5, r6, lr}
      usb_transfer_schedule_ack(endpoint->out);
      return USB_REQUEST_STATUS_OK;
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
2000c906:	2500      	movs	r5, #0
}

usb_request_status_t usb_vendor_request_read_r820t(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
2000c908:	1c04      	adds	r4, r0, #0
2000c90a:	1e0e      	subs	r6, r1, #0
  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c90c:	42ae      	cmp	r6, r5
2000c90e:	d114      	bne.n	2000c93a <usb_vendor_request_read_r820t+0x36>
  {
    if( endpoint->setup.index < 256 )
2000c910:	8881      	ldrh	r1, [r0, #4]
      endpoint->buffer[0] = value;
      usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
      usb_transfer_schedule_ack(endpoint->out);
      return USB_REQUEST_STATUS_OK;
    }
    return USB_REQUEST_STATUS_STALL;
2000c912:	2501      	movs	r5, #1
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    if( endpoint->setup.index < 256 )
2000c914:	29ff      	cmp	r1, #255	; 0xff
2000c916:	d810      	bhi.n	2000c93a <usb_vendor_request_read_r820t+0x36>
    {
      const uint8_t value = airspy_r820t_read_single(&airspy_conf->r820t_conf_rw, endpoint->setup.index);
2000c918:	4b09      	ldr	r3, [pc, #36]	; (2000c940 <usb_vendor_request_read_r820t+0x3c>)
2000c91a:	b2c9      	uxtb	r1, r1
2000c91c:	6818      	ldr	r0, [r3, #0]
2000c91e:	3048      	adds	r0, #72	; 0x48
2000c920:	f000 faf4 	bl	2000cf0c <airspy_r820t_read_single>
      endpoint->buffer[0] = value;
      usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c924:	1c21      	adds	r1, r4, #0
2000c926:	1c2a      	adds	r2, r5, #0
  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    if( endpoint->setup.index < 256 )
    {
      const uint8_t value = airspy_r820t_read_single(&airspy_conf->r820t_conf_rw, endpoint->setup.index);
      endpoint->buffer[0] = value;
2000c928:	7220      	strb	r0, [r4, #8]
      usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c92a:	3108      	adds	r1, #8
2000c92c:	69a0      	ldr	r0, [r4, #24]
2000c92e:	f001 fa5b 	bl	2000dde8 <usb_transfer_schedule_block>
      usb_transfer_schedule_ack(endpoint->out);
2000c932:	69e0      	ldr	r0, [r4, #28]
2000c934:	f001 fa65 	bl	2000de02 <usb_transfer_schedule_ack>
      return USB_REQUEST_STATUS_OK;
2000c938:	1c35      	adds	r5, r6, #0
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
  }
}
2000c93a:	1c28      	adds	r0, r5, #0
2000c93c:	bd70      	pop	{r4, r5, r6, pc}
2000c93e:	46c0      	nop			; (mov r8, r8)
2000c940:	2000ef28 	.word	0x2000ef28

2000c944 <usb_vendor_request_write_r820t>:
}

usb_request_status_t usb_vendor_request_write_r820t(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
2000c944:	b538      	push	{r3, r4, r5, lr}
2000c946:	1c04      	adds	r4, r0, #0
        return USB_REQUEST_STATUS_OK;
      }
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
2000c948:	2000      	movs	r0, #0
}

usb_request_status_t usb_vendor_request_write_r820t(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
2000c94a:	1e0d      	subs	r5, r1, #0
  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c94c:	4285      	cmp	r5, r0
2000c94e:	d111      	bne.n	2000c974 <usb_vendor_request_write_r820t+0x30>
  {
    if( endpoint->setup.index < 256 )
2000c950:	88a1      	ldrh	r1, [r4, #4]
        airspy_r820t_write_single(&airspy_conf->r820t_conf_rw, endpoint->setup.index, endpoint->setup.value);
        usb_transfer_schedule_ack(endpoint->in);
        return USB_REQUEST_STATUS_OK;
      }
    }
    return USB_REQUEST_STATUS_STALL;
2000c952:	2001      	movs	r0, #1
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    if( endpoint->setup.index < 256 )
2000c954:	29ff      	cmp	r1, #255	; 0xff
2000c956:	d80d      	bhi.n	2000c974 <usb_vendor_request_write_r820t+0x30>
    {
      if( endpoint->setup.value < 256 )
2000c958:	8862      	ldrh	r2, [r4, #2]
2000c95a:	2aff      	cmp	r2, #255	; 0xff
2000c95c:	d80a      	bhi.n	2000c974 <usb_vendor_request_write_r820t+0x30>
      {
        airspy_r820t_write_single(&airspy_conf->r820t_conf_rw, endpoint->setup.index, endpoint->setup.value);
2000c95e:	4b06      	ldr	r3, [pc, #24]	; (2000c978 <usb_vendor_request_write_r820t+0x34>)
2000c960:	b2c9      	uxtb	r1, r1
2000c962:	6818      	ldr	r0, [r3, #0]
2000c964:	b2d2      	uxtb	r2, r2
2000c966:	3048      	adds	r0, #72	; 0x48
2000c968:	f000 fa8e 	bl	2000ce88 <airspy_r820t_write_single>
        usb_transfer_schedule_ack(endpoint->in);
2000c96c:	69a0      	ldr	r0, [r4, #24]
2000c96e:	f001 fa48 	bl	2000de02 <usb_transfer_schedule_ack>
        return USB_REQUEST_STATUS_OK;
2000c972:	1c28      	adds	r0, r5, #0
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
  }
}
2000c974:	bd38      	pop	{r3, r4, r5, pc}
2000c976:	46c0      	nop			; (mov r8, r8)
2000c978:	2000ef28 	.word	0x2000ef28

2000c97c <usb_vendor_request_read_si5351c>:
}

usb_request_status_t usb_vendor_request_read_si5351c(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
2000c97c:	b570      	push	{r4, r5, r6, lr}
      usb_transfer_schedule_ack(endpoint->out);
      return USB_REQUEST_STATUS_OK;
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
2000c97e:	2500      	movs	r5, #0
}

usb_request_status_t usb_vendor_request_read_si5351c(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
2000c980:	1c04      	adds	r4, r0, #0
2000c982:	1e0e      	subs	r6, r1, #0
  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c984:	42ae      	cmp	r6, r5
2000c986:	d111      	bne.n	2000c9ac <usb_vendor_request_read_si5351c+0x30>
  {
    if( endpoint->setup.index < 256 )
2000c988:	8880      	ldrh	r0, [r0, #4]
      endpoint->buffer[0] = value;
      usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
      usb_transfer_schedule_ack(endpoint->out);
      return USB_REQUEST_STATUS_OK;
    }
    return USB_REQUEST_STATUS_STALL;
2000c98a:	2501      	movs	r5, #1
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    if( endpoint->setup.index < 256 )
2000c98c:	28ff      	cmp	r0, #255	; 0xff
2000c98e:	d80d      	bhi.n	2000c9ac <usb_vendor_request_read_si5351c+0x30>
    {
      const uint8_t value = si5351c_read_single(endpoint->setup.index);
2000c990:	b2c0      	uxtb	r0, r0
2000c992:	f000 f9c0 	bl	2000cd16 <si5351c_read_single>
      endpoint->buffer[0] = value;
      usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c996:	1c21      	adds	r1, r4, #0
2000c998:	1c2a      	adds	r2, r5, #0
  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    if( endpoint->setup.index < 256 )
    {
      const uint8_t value = si5351c_read_single(endpoint->setup.index);
      endpoint->buffer[0] = value;
2000c99a:	7220      	strb	r0, [r4, #8]
      usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000c99c:	3108      	adds	r1, #8
2000c99e:	69a0      	ldr	r0, [r4, #24]
2000c9a0:	f001 fa22 	bl	2000dde8 <usb_transfer_schedule_block>
      usb_transfer_schedule_ack(endpoint->out);
2000c9a4:	69e0      	ldr	r0, [r4, #28]
2000c9a6:	f001 fa2c 	bl	2000de02 <usb_transfer_schedule_ack>
      return USB_REQUEST_STATUS_OK;
2000c9aa:	1c35      	adds	r5, r6, #0
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
  }
}
2000c9ac:	1c28      	adds	r0, r5, #0
2000c9ae:	bd70      	pop	{r4, r5, r6, pc}

2000c9b0 <usb_vendor_request_write_si5351c>:
}

usb_request_status_t usb_vendor_request_write_si5351c(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
2000c9b0:	b538      	push	{r3, r4, r5, lr}
2000c9b2:	1c04      	adds	r4, r0, #0
        return USB_REQUEST_STATUS_OK;
      }
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
2000c9b4:	2000      	movs	r0, #0
}

usb_request_status_t usb_vendor_request_write_si5351c(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
2000c9b6:	1e0d      	subs	r5, r1, #0
  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c9b8:	4285      	cmp	r5, r0
2000c9ba:	d10e      	bne.n	2000c9da <usb_vendor_request_write_si5351c+0x2a>
  {
    if( endpoint->setup.index < 256 )
2000c9bc:	88a3      	ldrh	r3, [r4, #4]
        si5351c_write_single(endpoint->setup.index, endpoint->setup.value);
        usb_transfer_schedule_ack(endpoint->in);
        return USB_REQUEST_STATUS_OK;
      }
    }
    return USB_REQUEST_STATUS_STALL;
2000c9be:	2001      	movs	r0, #1
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    if( endpoint->setup.index < 256 )
2000c9c0:	2bff      	cmp	r3, #255	; 0xff
2000c9c2:	d80a      	bhi.n	2000c9da <usb_vendor_request_write_si5351c+0x2a>
    {
      if( endpoint->setup.value < 256 )
2000c9c4:	8861      	ldrh	r1, [r4, #2]
2000c9c6:	29ff      	cmp	r1, #255	; 0xff
2000c9c8:	d807      	bhi.n	2000c9da <usb_vendor_request_write_si5351c+0x2a>
      {
        si5351c_write_single(endpoint->setup.index, endpoint->setup.value);
2000c9ca:	b2d8      	uxtb	r0, r3
2000c9cc:	b2c9      	uxtb	r1, r1
2000c9ce:	f000 f991 	bl	2000ccf4 <si5351c_write_single>
        usb_transfer_schedule_ack(endpoint->in);
2000c9d2:	69a0      	ldr	r0, [r4, #24]
2000c9d4:	f001 fa15 	bl	2000de02 <usb_transfer_schedule_ack>
        return USB_REQUEST_STATUS_OK;
2000c9d8:	1c28      	adds	r0, r5, #0
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
  }
}
2000c9da:	bd38      	pop	{r3, r4, r5, pc}

2000c9dc <usb_vendor_request_set_receiver_mode>:

usb_request_status_t usb_vendor_request_set_receiver_mode(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage
)
{
2000c9dc:	b538      	push	{r3, r4, r5, lr}
      default:
        return USB_REQUEST_STATUS_STALL;
    }
  } else
  {
    return USB_REQUEST_STATUS_OK;
2000c9de:	2300      	movs	r3, #0

usb_request_status_t usb_vendor_request_set_receiver_mode(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage
)
{
2000c9e0:	1c05      	adds	r5, r0, #0
2000c9e2:	1e0c      	subs	r4, r1, #0
  if( stage == USB_TRANSFER_STAGE_SETUP )
2000c9e4:	429c      	cmp	r4, r3
2000c9e6:	d10a      	bne.n	2000c9fe <usb_vendor_request_set_receiver_mode+0x22>
  {
    switch( endpoint->setup.value )
2000c9e8:	8840      	ldrh	r0, [r0, #2]
      case RECEIVER_MODE_RX:
        set_receiver_mode(endpoint->setup.value);
        usb_transfer_schedule_ack(endpoint->in);
        return USB_REQUEST_STATUS_OK;
      default:
        return USB_REQUEST_STATUS_STALL;
2000c9ea:	2301      	movs	r3, #1
const usb_transfer_stage_t stage
)
{
  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    switch( endpoint->setup.value )
2000c9ec:	4298      	cmp	r0, r3
2000c9ee:	d806      	bhi.n	2000c9fe <usb_vendor_request_set_receiver_mode+0x22>
    {
      case RECEIVER_MODE_OFF:
      case RECEIVER_MODE_RX:
        set_receiver_mode(endpoint->setup.value);
2000c9f0:	b2c0      	uxtb	r0, r0
2000c9f2:	f7ff fc67 	bl	2000c2c4 <set_receiver_mode>
        usb_transfer_schedule_ack(endpoint->in);
2000c9f6:	69a8      	ldr	r0, [r5, #24]
2000c9f8:	f001 fa03 	bl	2000de02 <usb_transfer_schedule_ack>
        return USB_REQUEST_STATUS_OK;
2000c9fc:	1c23      	adds	r3, r4, #0
    }
  } else
  {
    return USB_REQUEST_STATUS_OK;
  }
}
2000c9fe:	1c18      	adds	r0, r3, #0
2000ca00:	bd38      	pop	{r3, r4, r5, pc}
	...

2000ca04 <usb_vendor_request_write_gpio_command>:
}

usb_request_status_t usb_vendor_request_write_gpio_command(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
2000ca04:	b538      	push	{r3, r4, r5, lr}
        return USB_REQUEST_STATUS_OK;
      }
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
2000ca06:	2300      	movs	r3, #0
  uint32_t port_num;
  uint32_t pin_num;
  uint16_t index;
  uint16_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
2000ca08:	4299      	cmp	r1, r3
2000ca0a:	d11b      	bne.n	2000ca44 <usb_vendor_request_write_gpio_command+0x40>
  {
    index = endpoint->setup.index;
2000ca0c:	8882      	ldrh	r2, [r0, #4]
        }
        usb_transfer_schedule_ack(endpoint->in);
        return USB_REQUEST_STATUS_OK;
      }
    }
    return USB_REQUEST_STATUS_STALL;
2000ca0e:	2301      	movs	r3, #1
  uint16_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    index = endpoint->setup.index;
    if( index < 256 )
2000ca10:	2aff      	cmp	r2, #255	; 0xff
2000ca12:	d817      	bhi.n	2000ca44 <usb_vendor_request_write_gpio_command+0x40>
    {
      value = endpoint->setup.value;
2000ca14:	8844      	ldrh	r4, [r0, #2]
      if( value < 2 )
2000ca16:	429c      	cmp	r4, r3
2000ca18:	d814      	bhi.n	2000ca44 <usb_vendor_request_write_gpio_command+0x40>
      {
        port_num = index >> 5;
        port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));
2000ca1a:	4d0b      	ldr	r5, [pc, #44]	; (2000ca48 <usb_vendor_request_write_gpio_command+0x44>)
    if( index < 256 )
    {
      value = endpoint->setup.value;
      if( value < 2 )
      {
        port_num = index >> 5;
2000ca1c:	0951      	lsrs	r1, r2, #5
        port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));
2000ca1e:	1949      	adds	r1, r1, r5

        pin_num = index & 0x1F;
        pin_num = (1 << pin_num);
2000ca20:	251f      	movs	r5, #31
2000ca22:	402a      	ands	r2, r5
    {
      value = endpoint->setup.value;
      if( value < 2 )
      {
        port_num = index >> 5;
        port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));
2000ca24:	0089      	lsls	r1, r1, #2

        pin_num = index & 0x1F;
        pin_num = (1 << pin_num);
2000ca26:	4093      	lsls	r3, r2

        if(value == 1)
2000ca28:	2c01      	cmp	r4, #1
2000ca2a:	d103      	bne.n	2000ca34 <usb_vendor_request_write_gpio_command+0x30>
  .reserved = 0,
};

__inline__ void gpio_set(uint32_t gpioport, uint32_t gpios)
{
  GPIO_SET(gpioport) = gpios;
2000ca2c:	2580      	movs	r5, #128	; 0x80
2000ca2e:	00aa      	lsls	r2, r5, #2
2000ca30:	1889      	adds	r1, r1, r2
2000ca32:	e002      	b.n	2000ca3a <usb_vendor_request_write_gpio_command+0x36>
}

__inline__ void gpio_clear(uint32_t gpioport, uint32_t gpios)
{
  GPIO_CLR(gpioport) = gpios;
2000ca34:	22a0      	movs	r2, #160	; 0xa0
2000ca36:	0094      	lsls	r4, r2, #2
2000ca38:	1909      	adds	r1, r1, r4
2000ca3a:	600b      	str	r3, [r1, #0]
          gpio_set(port_num, pin_num);
        }else
        {
          gpio_clear(port_num, pin_num);
        }
        usb_transfer_schedule_ack(endpoint->in);
2000ca3c:	6980      	ldr	r0, [r0, #24]
2000ca3e:	f001 f9e0 	bl	2000de02 <usb_transfer_schedule_ack>
        return USB_REQUEST_STATUS_OK;
2000ca42:	2300      	movs	r3, #0
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
  }
}
2000ca44:	1c18      	adds	r0, r3, #0
2000ca46:	bd38      	pop	{r3, r4, r5, pc}
2000ca48:	1003d800 	.word	0x1003d800

2000ca4c <usb_vendor_request_read_gpio_command>:

usb_request_status_t usb_vendor_request_read_gpio_command(
usb_endpoint_t* const endpoint,
const usb_transfer_stage_t stage)
{
2000ca4c:	b510      	push	{r4, lr}
2000ca4e:	1c04      	adds	r4, r0, #0
      usb_transfer_schedule_ack(endpoint->out);
      return USB_REQUEST_STATUS_OK;
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
2000ca50:	2000      	movs	r0, #0
{
  uint32_t port_num;
  uint32_t pin_num;
  uint8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
2000ca52:	4281      	cmp	r1, r0
2000ca54:	d122      	bne.n	2000ca9c <usb_vendor_request_read_gpio_command+0x50>
  {
    if( endpoint->setup.index < 256 )
2000ca56:	88a2      	ldrh	r2, [r4, #4]
      endpoint->buffer[0] = value;
      usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
      usb_transfer_schedule_ack(endpoint->out);
      return USB_REQUEST_STATUS_OK;
    }
    return USB_REQUEST_STATUS_STALL;
2000ca58:	2001      	movs	r0, #1
  uint32_t pin_num;
  uint8_t value;

  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    if( endpoint->setup.index < 256 )
2000ca5a:	2aff      	cmp	r2, #255	; 0xff
2000ca5c:	d81e      	bhi.n	2000ca9c <usb_vendor_request_read_gpio_command+0x50>
    {
      port_num = endpoint->setup.index >> 5;
      port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));
2000ca5e:	4910      	ldr	r1, [pc, #64]	; (2000caa0 <usb_vendor_request_read_gpio_command+0x54>)

  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    if( endpoint->setup.index < 256 )
    {
      port_num = endpoint->setup.index >> 5;
2000ca60:	0953      	lsrs	r3, r2, #5
      port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));
2000ca62:	185b      	adds	r3, r3, r1

      pin_num = endpoint->setup.index & 0x1F;
      pin_num = (1 << pin_num);
2000ca64:	211f      	movs	r1, #31
2000ca66:	400a      	ands	r2, r1
  if( stage == USB_TRANSFER_STAGE_SETUP )
  {
    if( endpoint->setup.index < 256 )
    {
      port_num = endpoint->setup.index >> 5;
      port_num = (GPIO_PORT_BASE + 0x2000 + (port_num * 4));
2000ca68:	009b      	lsls	r3, r3, #2

      pin_num = endpoint->setup.index & 0x1F;
      pin_num = (1 << pin_num);
2000ca6a:	4090      	lsls	r0, r2
      
      /* If GPIO DIR is set to OUT read the GPIO_SET reg else just read GPIO PIN */
      if( (GPIO_DIR(port_num) & pin_num) )
2000ca6c:	681a      	ldr	r2, [r3, #0]
2000ca6e:	4210      	tst	r0, r2
2000ca70:	d003      	beq.n	2000ca7a <usb_vendor_request_read_gpio_command+0x2e>
      {
        value = ((GPIO_SET(port_num) & pin_num) != 0);
2000ca72:	2180      	movs	r1, #128	; 0x80
2000ca74:	008a      	lsls	r2, r1, #2
2000ca76:	189b      	adds	r3, r3, r2
2000ca78:	e001      	b.n	2000ca7e <usb_vendor_request_read_gpio_command+0x32>
  GPIO_CLR(gpioport) = gpios;
}

__inline__ uint32_t gpio_get(uint32_t gpioport, uint32_t gpios)
{
  return (GPIO_PIN(gpioport) & gpios) != 0;
2000ca7a:	3301      	adds	r3, #1
2000ca7c:	33ff      	adds	r3, #255	; 0xff
2000ca7e:	681b      	ldr	r3, [r3, #0]
      }else
      {
        value = gpio_get(port_num, pin_num);
      }
      endpoint->buffer[0] = value;
      usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000ca80:	1c21      	adds	r1, r4, #0
  GPIO_CLR(gpioport) = gpios;
}

__inline__ uint32_t gpio_get(uint32_t gpioport, uint32_t gpios)
{
  return (GPIO_PIN(gpioport) & gpios) != 0;
2000ca82:	4018      	ands	r0, r3
      if( (GPIO_DIR(port_num) & pin_num) )
      {
        value = ((GPIO_SET(port_num) & pin_num) != 0);
      }else
      {
        value = gpio_get(port_num, pin_num);
2000ca84:	1e43      	subs	r3, r0, #1
2000ca86:	4198      	sbcs	r0, r3
      }
      endpoint->buffer[0] = value;
2000ca88:	7220      	strb	r0, [r4, #8]
      usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000ca8a:	3108      	adds	r1, #8
2000ca8c:	2201      	movs	r2, #1
2000ca8e:	69a0      	ldr	r0, [r4, #24]
2000ca90:	f001 f9aa 	bl	2000dde8 <usb_transfer_schedule_block>
      usb_transfer_schedule_ack(endpoint->out);
2000ca94:	69e0      	ldr	r0, [r4, #28]
2000ca96:	f001 f9b4 	bl	2000de02 <usb_transfer_schedule_ack>
      return USB_REQUEST_STATUS_OK;
2000ca9a:	2000      	movs	r0, #0
    }
    return USB_REQUEST_STATUS_STALL;
  } else {
    return USB_REQUEST_STATUS_OK;
  }
}
2000ca9c:	bd10      	pop	{r4, pc}
2000ca9e:	46c0      	nop			; (mov r8, r8)
2000caa0:	1003d800 	.word	0x1003d800

2000caa4 <gpio_set>:
  .reserved = 0,
};

__inline__ void gpio_set(uint32_t gpioport, uint32_t gpios)
{
  GPIO_SET(gpioport) = gpios;
2000caa4:	2380      	movs	r3, #128	; 0x80
2000caa6:	009a      	lsls	r2, r3, #2
2000caa8:	1880      	adds	r0, r0, r2
2000caaa:	6001      	str	r1, [r0, #0]
}
2000caac:	4770      	bx	lr

2000caae <gpio_clear>:

__inline__ void gpio_clear(uint32_t gpioport, uint32_t gpios)
{
  GPIO_CLR(gpioport) = gpios;
2000caae:	23a0      	movs	r3, #160	; 0xa0
2000cab0:	009a      	lsls	r2, r3, #2
2000cab2:	1880      	adds	r0, r0, r2
2000cab4:	6001      	str	r1, [r0, #0]
}
2000cab6:	4770      	bx	lr

2000cab8 <usb_streaming_disable>:
{
  return (GPIO_PIN(gpioport) & gpios) != 0;
}

void usb_streaming_disable(void)
{
2000cab8:	b508      	push	{r3, lr}
  usb_endpoint_disable(&usb_endpoint_bulk_in);
2000caba:	4803      	ldr	r0, [pc, #12]	; (2000cac8 <usb_streaming_disable+0x10>)
2000cabc:	f000 fece 	bl	2000d85c <usb_endpoint_disable>
  usb_endpoint_disable(&usb_endpoint_bulk_out);
2000cac0:	4802      	ldr	r0, [pc, #8]	; (2000cacc <usb_streaming_disable+0x14>)
2000cac2:	f000 fecb 	bl	2000d85c <usb_endpoint_disable>
}
2000cac6:	bd08      	pop	{r3, pc}
2000cac8:	2000ef00 	.word	0x2000ef00
2000cacc:	2000eea0 	.word	0x2000eea0

2000cad0 <airspy_usb_req_init>:
usb_request_handler_fn vendor_request_handler[AIRSPY_CMD_MAX+1];

void airspy_usb_req_init(void)
{
  /* Init default sample_rate conf */
  sample_rate_conf_no = AIRSPY_SAMPLERATE_DEFAULT_CONF;
2000cad0:	4b1f      	ldr	r3, [pc, #124]	; (2000cb50 <airspy_usb_req_init+0x80>)

  /* Init default value to 100.0MHz */
  set_freq_params.freq_hz = 100000000;
2000cad2:	4920      	ldr	r1, [pc, #128]	; (2000cb54 <airspy_usb_req_init+0x84>)
2000cad4:	4820      	ldr	r0, [pc, #128]	; (2000cb58 <airspy_usb_req_init+0x88>)
usb_request_handler_fn vendor_request_handler[AIRSPY_CMD_MAX+1];

void airspy_usb_req_init(void)
{
  /* Init default sample_rate conf */
  sample_rate_conf_no = AIRSPY_SAMPLERATE_DEFAULT_CONF;
2000cad6:	2200      	movs	r2, #0
2000cad8:	701a      	strb	r2, [r3, #0]

  /* Init default value to 100.0MHz */
  set_freq_params.freq_hz = 100000000;
2000cada:	6008      	str	r0, [r1, #0]

  /* TODO remove this code, for test => INVALID => RESET */
  vendor_request_handler[AIRSPY_INVALID] = usb_vendor_request_reset;
2000cadc:	4b1f      	ldr	r3, [pc, #124]	; (2000cb5c <airspy_usb_req_init+0x8c>)
2000cade:	4a20      	ldr	r2, [pc, #128]	; (2000cb60 <airspy_usb_req_init+0x90>)

  vendor_request_handler[AIRSPY_RECEIVER_MODE] = usb_vendor_request_set_receiver_mode;
2000cae0:	4820      	ldr	r0, [pc, #128]	; (2000cb64 <airspy_usb_req_init+0x94>)

  vendor_request_handler[AIRSPY_SI5351C_WRITE] = usb_vendor_request_write_si5351c;
2000cae2:	4921      	ldr	r1, [pc, #132]	; (2000cb68 <airspy_usb_req_init+0x98>)

  /* Init default value to 100.0MHz */
  set_freq_params.freq_hz = 100000000;

  /* TODO remove this code, for test => INVALID => RESET */
  vendor_request_handler[AIRSPY_INVALID] = usb_vendor_request_reset;
2000cae4:	601a      	str	r2, [r3, #0]

  vendor_request_handler[AIRSPY_RECEIVER_MODE] = usb_vendor_request_set_receiver_mode;
2000cae6:	6058      	str	r0, [r3, #4]

  vendor_request_handler[AIRSPY_SI5351C_WRITE] = usb_vendor_request_write_si5351c;
2000cae8:	6099      	str	r1, [r3, #8]
  vendor_request_handler[AIRSPY_SI5351C_READ] = usb_vendor_request_read_si5351c;
2000caea:	4a20      	ldr	r2, [pc, #128]	; (2000cb6c <airspy_usb_req_init+0x9c>)

  vendor_request_handler[AIRSPY_R820T_WRITE] = usb_vendor_request_write_r820t;
2000caec:	4820      	ldr	r0, [pc, #128]	; (2000cb70 <airspy_usb_req_init+0xa0>)
  vendor_request_handler[AIRSPY_R820T_READ] = usb_vendor_request_read_r820t;
2000caee:	4921      	ldr	r1, [pc, #132]	; (2000cb74 <airspy_usb_req_init+0xa4>)
  vendor_request_handler[AIRSPY_INVALID] = usb_vendor_request_reset;

  vendor_request_handler[AIRSPY_RECEIVER_MODE] = usb_vendor_request_set_receiver_mode;

  vendor_request_handler[AIRSPY_SI5351C_WRITE] = usb_vendor_request_write_si5351c;
  vendor_request_handler[AIRSPY_SI5351C_READ] = usb_vendor_request_read_si5351c;
2000caf0:	60da      	str	r2, [r3, #12]

  vendor_request_handler[AIRSPY_R820T_WRITE] = usb_vendor_request_write_r820t;
2000caf2:	6118      	str	r0, [r3, #16]
  vendor_request_handler[AIRSPY_R820T_READ] = usb_vendor_request_read_r820t;
2000caf4:	6159      	str	r1, [r3, #20]

  vendor_request_handler[AIRSPY_SPIFLASH_ERASE] = usb_vendor_request_erase_spiflash;
2000caf6:	4a20      	ldr	r2, [pc, #128]	; (2000cb78 <airspy_usb_req_init+0xa8>)
  vendor_request_handler[AIRSPY_SPIFLASH_WRITE] = usb_vendor_request_write_spiflash;
2000caf8:	4820      	ldr	r0, [pc, #128]	; (2000cb7c <airspy_usb_req_init+0xac>)
  vendor_request_handler[AIRSPY_SPIFLASH_READ] = usb_vendor_request_read_spiflash;
2000cafa:	4921      	ldr	r1, [pc, #132]	; (2000cb80 <airspy_usb_req_init+0xb0>)
  vendor_request_handler[AIRSPY_SI5351C_READ] = usb_vendor_request_read_si5351c;

  vendor_request_handler[AIRSPY_R820T_WRITE] = usb_vendor_request_write_r820t;
  vendor_request_handler[AIRSPY_R820T_READ] = usb_vendor_request_read_r820t;

  vendor_request_handler[AIRSPY_SPIFLASH_ERASE] = usb_vendor_request_erase_spiflash;
2000cafc:	619a      	str	r2, [r3, #24]
  vendor_request_handler[AIRSPY_SPIFLASH_WRITE] = usb_vendor_request_write_spiflash;
2000cafe:	61d8      	str	r0, [r3, #28]
  vendor_request_handler[AIRSPY_SPIFLASH_READ] = usb_vendor_request_read_spiflash;
2000cb00:	6219      	str	r1, [r3, #32]

  vendor_request_handler[AIRSPY_BOARD_ID_READ] = usb_vendor_request_read_board_id;
2000cb02:	4a20      	ldr	r2, [pc, #128]	; (2000cb84 <airspy_usb_req_init+0xb4>)
  vendor_request_handler[AIRSPY_VERSION_STRING_READ] = usb_vendor_request_read_version_string;
2000cb04:	4820      	ldr	r0, [pc, #128]	; (2000cb88 <airspy_usb_req_init+0xb8>)
  vendor_request_handler[AIRSPY_BOARD_PARTID_SERIALNO_READ] = usb_vendor_request_read_partid_serialno;
2000cb06:	4921      	ldr	r1, [pc, #132]	; (2000cb8c <airspy_usb_req_init+0xbc>)

  vendor_request_handler[AIRSPY_SPIFLASH_ERASE] = usb_vendor_request_erase_spiflash;
  vendor_request_handler[AIRSPY_SPIFLASH_WRITE] = usb_vendor_request_write_spiflash;
  vendor_request_handler[AIRSPY_SPIFLASH_READ] = usb_vendor_request_read_spiflash;

  vendor_request_handler[AIRSPY_BOARD_ID_READ] = usb_vendor_request_read_board_id;
2000cb08:	625a      	str	r2, [r3, #36]	; 0x24
  vendor_request_handler[AIRSPY_VERSION_STRING_READ] = usb_vendor_request_read_version_string;
2000cb0a:	6298      	str	r0, [r3, #40]	; 0x28
  vendor_request_handler[AIRSPY_BOARD_PARTID_SERIALNO_READ] = usb_vendor_request_read_partid_serialno;
2000cb0c:	62d9      	str	r1, [r3, #44]	; 0x2c

  vendor_request_handler[AIRSPY_SET_SAMPLERATE] = usb_vendor_request_set_samplerate;
2000cb0e:	4a20      	ldr	r2, [pc, #128]	; (2000cb90 <airspy_usb_req_init+0xc0>)

  vendor_request_handler[AIRSPY_SET_FREQ] = usb_vendor_request_set_freq;
2000cb10:	4820      	ldr	r0, [pc, #128]	; (2000cb94 <airspy_usb_req_init+0xc4>)

  vendor_request_handler[AIRSPY_SET_LNA_GAIN] = usb_vendor_request_set_lna_gain;
2000cb12:	4921      	ldr	r1, [pc, #132]	; (2000cb98 <airspy_usb_req_init+0xc8>)

  vendor_request_handler[AIRSPY_BOARD_ID_READ] = usb_vendor_request_read_board_id;
  vendor_request_handler[AIRSPY_VERSION_STRING_READ] = usb_vendor_request_read_version_string;
  vendor_request_handler[AIRSPY_BOARD_PARTID_SERIALNO_READ] = usb_vendor_request_read_partid_serialno;

  vendor_request_handler[AIRSPY_SET_SAMPLERATE] = usb_vendor_request_set_samplerate;
2000cb14:	631a      	str	r2, [r3, #48]	; 0x30

  vendor_request_handler[AIRSPY_SET_FREQ] = usb_vendor_request_set_freq;
2000cb16:	6358      	str	r0, [r3, #52]	; 0x34

  vendor_request_handler[AIRSPY_SET_LNA_GAIN] = usb_vendor_request_set_lna_gain;
2000cb18:	6399      	str	r1, [r3, #56]	; 0x38
  vendor_request_handler[AIRSPY_SET_MIXER_GAIN] = usb_vendor_request_set_mixer_gain;
2000cb1a:	4a20      	ldr	r2, [pc, #128]	; (2000cb9c <airspy_usb_req_init+0xcc>)
  vendor_request_handler[AIRSPY_SET_VGA_GAIN] = usb_vendor_request_set_vga_gain;
2000cb1c:	4820      	ldr	r0, [pc, #128]	; (2000cba0 <airspy_usb_req_init+0xd0>)

  vendor_request_handler[AIRSPY_SET_LNA_AGC] = usb_vendor_request_set_lna_agc;
2000cb1e:	4921      	ldr	r1, [pc, #132]	; (2000cba4 <airspy_usb_req_init+0xd4>)
  vendor_request_handler[AIRSPY_SET_SAMPLERATE] = usb_vendor_request_set_samplerate;

  vendor_request_handler[AIRSPY_SET_FREQ] = usb_vendor_request_set_freq;

  vendor_request_handler[AIRSPY_SET_LNA_GAIN] = usb_vendor_request_set_lna_gain;
  vendor_request_handler[AIRSPY_SET_MIXER_GAIN] = usb_vendor_request_set_mixer_gain;
2000cb20:	63da      	str	r2, [r3, #60]	; 0x3c
  vendor_request_handler[AIRSPY_SET_VGA_GAIN] = usb_vendor_request_set_vga_gain;

  vendor_request_handler[AIRSPY_SET_LNA_AGC] = usb_vendor_request_set_lna_agc;
  vendor_request_handler[AIRSPY_SET_MIXER_AGC] = usb_vendor_request_set_mixer_agc;
2000cb22:	4a21      	ldr	r2, [pc, #132]	; (2000cba8 <airspy_usb_req_init+0xd8>)

  vendor_request_handler[AIRSPY_SET_FREQ] = usb_vendor_request_set_freq;

  vendor_request_handler[AIRSPY_SET_LNA_GAIN] = usb_vendor_request_set_lna_gain;
  vendor_request_handler[AIRSPY_SET_MIXER_GAIN] = usb_vendor_request_set_mixer_gain;
  vendor_request_handler[AIRSPY_SET_VGA_GAIN] = usb_vendor_request_set_vga_gain;
2000cb24:	6418      	str	r0, [r3, #64]	; 0x40

  vendor_request_handler[AIRSPY_SET_LNA_AGC] = usb_vendor_request_set_lna_agc;
2000cb26:	6459      	str	r1, [r3, #68]	; 0x44
  vendor_request_handler[AIRSPY_SET_MIXER_AGC] = usb_vendor_request_set_mixer_agc;
  
  vendor_request_handler[AIRSPY_MS_VENDOR_CMD] = usb_vendor_request_ms_vendor_command;
2000cb28:	4820      	ldr	r0, [pc, #128]	; (2000cbac <airspy_usb_req_init+0xdc>)

  vendor_request_handler[AIRSPY_SET_RF_BIAS_CMD] = usb_vendor_request_set_rf_bias_command;
2000cb2a:	4921      	ldr	r1, [pc, #132]	; (2000cbb0 <airspy_usb_req_init+0xe0>)
  vendor_request_handler[AIRSPY_SET_LNA_GAIN] = usb_vendor_request_set_lna_gain;
  vendor_request_handler[AIRSPY_SET_MIXER_GAIN] = usb_vendor_request_set_mixer_gain;
  vendor_request_handler[AIRSPY_SET_VGA_GAIN] = usb_vendor_request_set_vga_gain;

  vendor_request_handler[AIRSPY_SET_LNA_AGC] = usb_vendor_request_set_lna_agc;
  vendor_request_handler[AIRSPY_SET_MIXER_AGC] = usb_vendor_request_set_mixer_agc;
2000cb2c:	649a      	str	r2, [r3, #72]	; 0x48
  
  vendor_request_handler[AIRSPY_MS_VENDOR_CMD] = usb_vendor_request_ms_vendor_command;

  vendor_request_handler[AIRSPY_SET_RF_BIAS_CMD] = usb_vendor_request_set_rf_bias_command;

  vendor_request_handler[AIRSPY_GPIO_WRITE] = usb_vendor_request_write_gpio_command;
2000cb2e:	4a21      	ldr	r2, [pc, #132]	; (2000cbb4 <airspy_usb_req_init+0xe4>)
  vendor_request_handler[AIRSPY_SET_VGA_GAIN] = usb_vendor_request_set_vga_gain;

  vendor_request_handler[AIRSPY_SET_LNA_AGC] = usb_vendor_request_set_lna_agc;
  vendor_request_handler[AIRSPY_SET_MIXER_AGC] = usb_vendor_request_set_mixer_agc;
  
  vendor_request_handler[AIRSPY_MS_VENDOR_CMD] = usb_vendor_request_ms_vendor_command;
2000cb30:	64d8      	str	r0, [r3, #76]	; 0x4c

  vendor_request_handler[AIRSPY_SET_RF_BIAS_CMD] = usb_vendor_request_set_rf_bias_command;
2000cb32:	6519      	str	r1, [r3, #80]	; 0x50

  vendor_request_handler[AIRSPY_GPIO_WRITE] = usb_vendor_request_write_gpio_command;
  vendor_request_handler[AIRSPY_GPIO_READ] = usb_vendor_request_read_gpio_command;
2000cb34:	4820      	ldr	r0, [pc, #128]	; (2000cbb8 <airspy_usb_req_init+0xe8>)

  vendor_request_handler[AIRSPY_GPIODIR_WRITE] = usb_vendor_request_gpiodir_write_command;
2000cb36:	4921      	ldr	r1, [pc, #132]	; (2000cbbc <airspy_usb_req_init+0xec>)
  
  vendor_request_handler[AIRSPY_MS_VENDOR_CMD] = usb_vendor_request_ms_vendor_command;

  vendor_request_handler[AIRSPY_SET_RF_BIAS_CMD] = usb_vendor_request_set_rf_bias_command;

  vendor_request_handler[AIRSPY_GPIO_WRITE] = usb_vendor_request_write_gpio_command;
2000cb38:	655a      	str	r2, [r3, #84]	; 0x54
  vendor_request_handler[AIRSPY_GPIO_READ] = usb_vendor_request_read_gpio_command;

  vendor_request_handler[AIRSPY_GPIODIR_WRITE] = usb_vendor_request_gpiodir_write_command;
  vendor_request_handler[AIRSPY_GPIODIR_READ] = usb_vendor_request_gpiodir_read_command;
2000cb3a:	4a21      	ldr	r2, [pc, #132]	; (2000cbc0 <airspy_usb_req_init+0xf0>)
  vendor_request_handler[AIRSPY_MS_VENDOR_CMD] = usb_vendor_request_ms_vendor_command;

  vendor_request_handler[AIRSPY_SET_RF_BIAS_CMD] = usb_vendor_request_set_rf_bias_command;

  vendor_request_handler[AIRSPY_GPIO_WRITE] = usb_vendor_request_write_gpio_command;
  vendor_request_handler[AIRSPY_GPIO_READ] = usb_vendor_request_read_gpio_command;
2000cb3c:	6598      	str	r0, [r3, #88]	; 0x58

  vendor_request_handler[AIRSPY_GPIODIR_WRITE] = usb_vendor_request_gpiodir_write_command;
2000cb3e:	65d9      	str	r1, [r3, #92]	; 0x5c
  vendor_request_handler[AIRSPY_GPIODIR_READ] = usb_vendor_request_gpiodir_read_command;
2000cb40:	661a      	str	r2, [r3, #96]	; 0x60

  vendor_request_handler[AIRSPY_GET_SAMPLERATES] = usb_vendor_request_get_samplerates_command;
2000cb42:	4820      	ldr	r0, [pc, #128]	; (2000cbc4 <airspy_usb_req_init+0xf4>)
  vendor_request_handler[AIRSPY_SET_PACKING] = usb_vendor_request_set_packing_command;
2000cb44:	4920      	ldr	r1, [pc, #128]	; (2000cbc8 <airspy_usb_req_init+0xf8>)

  vendor_request_handler[AIRSPY_SPIFLASH_ERASE_SECTOR] = usb_vendor_request_erase_sector_spiflash;
2000cb46:	4a21      	ldr	r2, [pc, #132]	; (2000cbcc <airspy_usb_req_init+0xfc>)
  vendor_request_handler[AIRSPY_GPIO_READ] = usb_vendor_request_read_gpio_command;

  vendor_request_handler[AIRSPY_GPIODIR_WRITE] = usb_vendor_request_gpiodir_write_command;
  vendor_request_handler[AIRSPY_GPIODIR_READ] = usb_vendor_request_gpiodir_read_command;

  vendor_request_handler[AIRSPY_GET_SAMPLERATES] = usb_vendor_request_get_samplerates_command;
2000cb48:	6658      	str	r0, [r3, #100]	; 0x64
  vendor_request_handler[AIRSPY_SET_PACKING] = usb_vendor_request_set_packing_command;
2000cb4a:	6699      	str	r1, [r3, #104]	; 0x68

  vendor_request_handler[AIRSPY_SPIFLASH_ERASE_SECTOR] = usb_vendor_request_erase_sector_spiflash;
2000cb4c:	66da      	str	r2, [r3, #108]	; 0x6c
}
2000cb4e:	4770      	bx	lr
2000cb50:	2000f500 	.word	0x2000f500
2000cb54:	2000f388 	.word	0x2000f388
2000cb58:	05f5e100 	.word	0x05f5e100
2000cb5c:	2000f390 	.word	0x2000f390
2000cb60:	2000c329 	.word	0x2000c329
2000cb64:	2000c9dd 	.word	0x2000c9dd
2000cb68:	2000c9b1 	.word	0x2000c9b1
2000cb6c:	2000c97d 	.word	0x2000c97d
2000cb70:	2000c945 	.word	0x2000c945
2000cb74:	2000c905 	.word	0x2000c905
2000cb78:	2000c3a5 	.word	0x2000c3a5
2000cb7c:	2000c88d 	.word	0x2000c88d
2000cb80:	2000c801 	.word	0x2000c801
2000cb84:	2000c4c1 	.word	0x2000c4c1
2000cb88:	2000c7a1 	.word	0x2000c7a1
2000cb8c:	2000c741 	.word	0x2000c741
2000cb90:	2000c62d 	.word	0x2000c62d
2000cb94:	2000c5f5 	.word	0x2000c5f5
2000cb98:	2000c5c5 	.word	0x2000c5c5
2000cb9c:	2000c595 	.word	0x2000c595
2000cba0:	2000c565 	.word	0x2000c565
2000cba4:	2000c535 	.word	0x2000c535
2000cba8:	2000c505 	.word	0x2000c505
2000cbac:	2000c479 	.word	0x2000c479
2000cbb0:	2000c4e1 	.word	0x2000c4e1
2000cbb4:	2000ca05 	.word	0x2000ca05
2000cbb8:	2000ca4d 	.word	0x2000ca4d
2000cbbc:	2000c361 	.word	0x2000c361
2000cbc0:	2000c42d 	.word	0x2000c42d
2000cbc4:	2000c3c1 	.word	0x2000c3c1
2000cbc8:	2000c6ed 	.word	0x2000c6ed
2000cbcc:	2000c337 	.word	0x2000c337

2000cbd0 <usb_descriptor_fill_string_serial_number>:
};

static const uint8_t htoa[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};

void usb_descriptor_fill_string_serial_number(usb_descriptor_serial_number_t serial_number)
{
2000cbd0:	b5f0      	push	{r4, r5, r6, r7, lr}
  for(i=0; i<2; i++)
  {
    data_u32 = serial_number.sn_32b[i];

    data_u8 = (data_u32 & 0xFF000000) >> 24;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cbd2:	4b2d      	ldr	r3, [pc, #180]	; (2000cc88 <usb_descriptor_fill_string_serial_number+0xb8>)
  j = 0;
  for(i=0; i<2; i++)
  {
    data_u32 = serial_number.sn_32b[i];

    data_u8 = (data_u32 & 0xFF000000) >> 24;
2000cbd4:	0e05      	lsrs	r5, r0, #24
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cbd6:	092c      	lsrs	r4, r5, #4
2000cbd8:	5d1e      	ldrb	r6, [r3, r4]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cbda:	240f      	movs	r4, #15
2000cbdc:	4025      	ands	r5, r4
  for(i=0; i<2; i++)
  {
    data_u32 = serial_number.sn_32b[i];

    data_u8 = (data_u32 & 0xFF000000) >> 24;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cbde:	4a2b      	ldr	r2, [pc, #172]	; (2000cc8c <usb_descriptor_fill_string_serial_number+0xbc>)
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cbe0:	5d5f      	ldrb	r7, [r3, r5]
    j+=2;

    data_u8 = (data_u32 & 0x00FF0000) >> 16;
2000cbe2:	25ff      	movs	r5, #255	; 0xff
  for(i=0; i<2; i++)
  {
    data_u32 = serial_number.sn_32b[i];

    data_u8 = (data_u32 & 0xFF000000) >> 24;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cbe4:	7596      	strb	r6, [r2, #22]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cbe6:	7617      	strb	r7, [r2, #24]
    j+=2;

    data_u8 = (data_u32 & 0x00FF0000) >> 16;
2000cbe8:	042e      	lsls	r6, r5, #16
2000cbea:	1c07      	adds	r7, r0, #0
2000cbec:	4037      	ands	r7, r6
2000cbee:	0c3d      	lsrs	r5, r7, #16
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cbf0:	092f      	lsrs	r7, r5, #4
2000cbf2:	5ddf      	ldrb	r7, [r3, r7]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cbf4:	4025      	ands	r5, r4
2000cbf6:	5d5d      	ldrb	r5, [r3, r5]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
    j+=2;

    data_u8 = (data_u32 & 0x00FF0000) >> 16;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cbf8:	7697      	strb	r7, [r2, #26]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
    j+=2;

    data_u8 = (data_u32 & 0x0000FF00) >> 8;
2000cbfa:	27ff      	movs	r7, #255	; 0xff
    j+=2;

    data_u8 = (data_u32 & 0x00FF0000) >> 16;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cbfc:	7715      	strb	r5, [r2, #28]
    j+=2;

    data_u8 = (data_u32 & 0x0000FF00) >> 8;
2000cbfe:	023d      	lsls	r5, r7, #8
2000cc00:	4005      	ands	r5, r0
2000cc02:	0a2f      	lsrs	r7, r5, #8
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc04:	093d      	lsrs	r5, r7, #4
2000cc06:	5d5d      	ldrb	r5, [r3, r5]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc08:	4027      	ands	r7, r4
2000cc0a:	46bc      	mov	ip, r7
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
    j+=2;

    data_u8 = (data_u32 & 0x0000FF00) >> 8;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc0c:	7795      	strb	r5, [r2, #30]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc0e:	4665      	mov	r5, ip
2000cc10:	5d5d      	ldrb	r5, [r3, r5]
2000cc12:	1c57      	adds	r7, r2, #1
2000cc14:	77fd      	strb	r5, [r7, #31]
    j+=2;

    data_u8 = (data_u32 & 0x000000FF);
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc16:	b2c7      	uxtb	r7, r0
2000cc18:	093d      	lsrs	r5, r7, #4
2000cc1a:	5d5d      	ldrb	r5, [r3, r5]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc1c:	4020      	ands	r0, r4
2000cc1e:	5c18      	ldrb	r0, [r3, r0]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
    j+=2;

    data_u8 = (data_u32 & 0x000000FF);
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc20:	1cd7      	adds	r7, r2, #3
2000cc22:	77fd      	strb	r5, [r7, #31]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc24:	1d57      	adds	r7, r2, #5
2000cc26:	77f8      	strb	r0, [r7, #31]
  j = 0;
  for(i=0; i<2; i++)
  {
    data_u32 = serial_number.sn_32b[i];

    data_u8 = (data_u32 & 0xFF000000) >> 24;
2000cc28:	0e08      	lsrs	r0, r1, #24
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc2a:	0905      	lsrs	r5, r0, #4
2000cc2c:	5d5d      	ldrb	r5, [r3, r5]
2000cc2e:	1dd7      	adds	r7, r2, #7
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc30:	4020      	ands	r0, r4
2000cc32:	5c18      	ldrb	r0, [r3, r0]
  for(i=0; i<2; i++)
  {
    data_u32 = serial_number.sn_32b[i];

    data_u8 = (data_u32 & 0xFF000000) >> 24;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc34:	77fd      	strb	r5, [r7, #31]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
    j+=2;

    data_u8 = (data_u32 & 0x00FF0000) >> 16;
2000cc36:	400e      	ands	r6, r1
    data_u32 = serial_number.sn_32b[i];

    data_u8 = (data_u32 & 0xFF000000) >> 24;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc38:	1c17      	adds	r7, r2, #0
    j+=2;

    data_u8 = (data_u32 & 0x00FF0000) >> 16;
2000cc3a:	0c35      	lsrs	r5, r6, #16
    data_u32 = serial_number.sn_32b[i];

    data_u8 = (data_u32 & 0xFF000000) >> 24;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc3c:	3728      	adds	r7, #40	; 0x28
2000cc3e:	7038      	strb	r0, [r7, #0]
    j+=2;

    data_u8 = (data_u32 & 0x00FF0000) >> 16;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc40:	092f      	lsrs	r7, r5, #4
2000cc42:	5dd8      	ldrb	r0, [r3, r7]
2000cc44:	1c16      	adds	r6, r2, #0
2000cc46:	362a      	adds	r6, #42	; 0x2a
2000cc48:	7030      	strb	r0, [r6, #0]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc4a:	4025      	ands	r5, r4
    j+=2;

    data_u8 = (data_u32 & 0x0000FF00) >> 8;
2000cc4c:	26ff      	movs	r6, #255	; 0xff
    j+=2;

    data_u8 = (data_u32 & 0x00FF0000) >> 16;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc4e:	5d5d      	ldrb	r5, [r3, r5]
2000cc50:	1c17      	adds	r7, r2, #0
    j+=2;

    data_u8 = (data_u32 & 0x0000FF00) >> 8;
2000cc52:	0230      	lsls	r0, r6, #8
2000cc54:	4008      	ands	r0, r1
    j+=2;

    data_u8 = (data_u32 & 0x00FF0000) >> 16;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc56:	372c      	adds	r7, #44	; 0x2c
2000cc58:	703d      	strb	r5, [r7, #0]
    j+=2;

    data_u8 = (data_u32 & 0x0000FF00) >> 8;
2000cc5a:	0a07      	lsrs	r7, r0, #8
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc5c:	093e      	lsrs	r6, r7, #4
2000cc5e:	5d98      	ldrb	r0, [r3, r6]
2000cc60:	1c15      	adds	r5, r2, #0
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc62:	4027      	ands	r7, r4
2000cc64:	5ddf      	ldrb	r7, [r3, r7]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
    j+=2;

    data_u8 = (data_u32 & 0x0000FF00) >> 8;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc66:	352e      	adds	r5, #46	; 0x2e
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc68:	1c16      	adds	r6, r2, #0
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
    j+=2;

    data_u8 = (data_u32 & 0x0000FF00) >> 8;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc6a:	7028      	strb	r0, [r5, #0]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc6c:	3630      	adds	r6, #48	; 0x30
    j+=2;

    data_u8 = (data_u32 & 0x000000FF);
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc6e:	b2cd      	uxtb	r5, r1
    j+=2;

    data_u8 = (data_u32 & 0x0000FF00) >> 8;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc70:	7037      	strb	r7, [r6, #0]
    j+=2;

    data_u8 = (data_u32 & 0x000000FF);
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc72:	400c      	ands	r4, r1
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
    j+=2;

    data_u8 = (data_u32 & 0x000000FF);
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc74:	092e      	lsrs	r6, r5, #4
2000cc76:	5d9f      	ldrb	r7, [r3, r6]
2000cc78:	1c10      	adds	r0, r2, #0
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc7a:	5d19      	ldrb	r1, [r3, r4]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
    j+=2;

    data_u8 = (data_u32 & 0x000000FF);
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc7c:	3032      	adds	r0, #50	; 0x32
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc7e:	3234      	adds	r2, #52	; 0x34
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
    j+=2;

    data_u8 = (data_u32 & 0x000000FF);
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0xF0) >> 4];
2000cc80:	7007      	strb	r7, [r0, #0]
    j+=2;
    usb_descriptor_string_serial_number[USB_DESCRIPTOR_SN_POS + j] = htoa[(data_u8 & 0x0F)];
2000cc82:	7011      	strb	r1, [r2, #0]
    j+=2;
  }
}
2000cc84:	bdf0      	pop	{r4, r5, r6, r7, pc}
2000cc86:	46c0      	nop			; (mov r8, r8)
2000cc88:	2000e9a0 	.word	0x2000e9a0
2000cc8c:	2000ecd7 	.word	0x2000ecd7

2000cc90 <delay>:

void delay(uint32_t duration)
{
  uint32_t i;

  for (i = 0; i < duration; i++)
2000cc90:	2300      	movs	r3, #0
2000cc92:	4283      	cmp	r3, r0
2000cc94:	d002      	beq.n	2000cc9c <delay+0xc>
    __asm__("nop");
2000cc96:	46c0      	nop			; (mov r8, r8)

void delay(uint32_t duration)
{
  uint32_t i;

  for (i = 0; i < duration; i++)
2000cc98:	3301      	adds	r3, #1
2000cc9a:	e7fa      	b.n	2000cc92 <delay+0x2>
    __asm__("nop");
}
2000cc9c:	4770      	bx	lr
	...

2000cca0 <cpu_reset>:

void cpu_reset(void)
{
  RESET_CTRL0 = RESET_CTRL0_CORE_RST;
2000cca0:	4b01      	ldr	r3, [pc, #4]	; (2000cca8 <cpu_reset+0x8>)
2000cca2:	2201      	movs	r2, #1
2000cca4:	601a      	str	r2, [r3, #0]
2000cca6:	e7fe      	b.n	2000cca6 <cpu_reset+0x6>
2000cca8:	40053100 	.word	0x40053100

2000ccac <enable_biast_power>:
  /* Wait after PowerOn (stabilization of LDO & Internal Init of R820T) */
  delay(WAIT_R820T_POWER_ON_DELAY);
}

void enable_biast_power(void)
{
2000ccac:	b508      	push	{r3, lr}
  gpio_set(PORT_EN_BIAST, PIN_EN_BIAST);
2000ccae:	2180      	movs	r1, #128	; 0x80
2000ccb0:	4802      	ldr	r0, [pc, #8]	; (2000ccbc <enable_biast_power+0x10>)
2000ccb2:	0189      	lsls	r1, r1, #6
2000ccb4:	f7ff fef6 	bl	2000caa4 <gpio_set>
}
2000ccb8:	bd08      	pop	{r3, pc}
2000ccba:	46c0      	nop			; (mov r8, r8)
2000ccbc:	400f6004 	.word	0x400f6004

2000ccc0 <disable_biast_power>:

void disable_biast_power(void)
{
2000ccc0:	b508      	push	{r3, lr}
  gpio_clear(PORT_EN_BIAST, PIN_EN_BIAST);
2000ccc2:	2180      	movs	r1, #128	; 0x80
2000ccc4:	4802      	ldr	r0, [pc, #8]	; (2000ccd0 <disable_biast_power+0x10>)
2000ccc6:	0189      	lsls	r1, r1, #6
2000ccc8:	f7ff fef1 	bl	2000caae <gpio_clear>
}
2000cccc:	bd08      	pop	{r3, pc}
2000ccce:	46c0      	nop			; (mov r8, r8)
2000ccd0:	400f6004 	.word	0x400f6004

2000ccd4 <hard_fault_handler>:
/* Code Compatible with CortexM0, M3, M4 (R4 & R5 are modified for ARCH 6M) */
__attribute__((naked))
void hard_fault_handler(void)
{
#if defined(__ARM_ARCH_6M__)
  __asm__("MOVS R4, #4");
2000ccd4:	2404      	movs	r4, #4
  __asm__("MOV  R5, LR");
2000ccd6:	4675      	mov	r5, lr
  __asm__("TST R4, R5");
2000ccd8:	422c      	tst	r4, r5
  __asm__("BEQ _MSP");
2000ccda:	d002      	beq.n	2000cce2 <_MSP>
  __asm__("MRS R0, PSP");
2000ccdc:	f3ef 8009 	mrs	r0, PSP
  __asm__("B hard_fault_handler_c");
2000cce0:	e002      	b.n	2000cce8 <hard_fault_handler_c>

2000cce2 <_MSP>:
  __asm__("_MSP:");
  __asm__("MRS R0, MSP");
2000cce2:	f3ef 8008 	mrs	r0, MSP
  __asm__("B hard_fault_handler_c");
2000cce6:	e7ff      	b.n	2000cce8 <hard_fault_handler_c>

2000cce8 <hard_fault_handler_c>:
volatile hard_fault_stack_t* hard_fault_stack_pt;

__attribute__((used)) void hard_fault_handler_c(uint32_t* args)
{
  /* hard_fault_stack_pt contains registers saved before the hard fault */
  hard_fault_stack_pt = (hard_fault_stack_t*)args;
2000cce8:	4b01      	ldr	r3, [pc, #4]	; (2000ccf0 <hard_fault_handler_c+0x8>)
2000ccea:	6018      	str	r0, [r3, #0]
      if( SCB->CFSR & CSCB_CFSR_BFSR_PRECISERR ) {
      }
    }
  }
  */
  __asm("BKPT #0\n") ; // Break into the debugger
2000ccec:	be00      	bkpt	0x0000
2000ccee:	e7fe      	b.n	2000ccee <hard_fault_handler_c+0x6>
2000ccf0:	2000f740 	.word	0x2000f740

2000ccf4 <si5351c_write_single>:
}


/* write to single register */
void si5351c_write_single(uint8_t reg, uint8_t val)
{
2000ccf4:	b538      	push	{r3, r4, r5, lr}
2000ccf6:	1c0c      	adds	r4, r1, #0
2000ccf8:	1c05      	adds	r5, r0, #0
  i2c0_tx_start();
2000ccfa:	f001 fa9d 	bl	2000e238 <i2c0_tx_start>
  i2c0_tx_byte(SI5351C_I2C_ADDR | I2C_WRITE);
2000ccfe:	20c0      	movs	r0, #192	; 0xc0
2000cd00:	f001 fada 	bl	2000e2b8 <i2c0_tx_byte>
  i2c0_tx_byte(reg);
2000cd04:	1c28      	adds	r0, r5, #0
2000cd06:	f001 fad7 	bl	2000e2b8 <i2c0_tx_byte>
  i2c0_tx_byte(val);
2000cd0a:	1c20      	adds	r0, r4, #0
2000cd0c:	f001 fad4 	bl	2000e2b8 <i2c0_tx_byte>
  i2c0_stop();
2000cd10:	f001 fb72 	bl	2000e3f8 <i2c0_stop>
}
2000cd14:	bd38      	pop	{r3, r4, r5, pc}

2000cd16 <si5351c_read_single>:

/* read single register */
uint8_t si5351c_read_single(uint8_t reg)
{
2000cd16:	b510      	push	{r4, lr}
2000cd18:	1c04      	adds	r4, r0, #0
  uint8_t val;

  /* set register address with write */
  i2c0_tx_start();
2000cd1a:	f001 fa8d 	bl	2000e238 <i2c0_tx_start>
  i2c0_tx_byte(SI5351C_I2C_ADDR | I2C_WRITE);
2000cd1e:	20c0      	movs	r0, #192	; 0xc0
2000cd20:	f001 faca 	bl	2000e2b8 <i2c0_tx_byte>
  i2c0_tx_byte(reg);
2000cd24:	1c20      	adds	r0, r4, #0
2000cd26:	f001 fac7 	bl	2000e2b8 <i2c0_tx_byte>

  /* read the value */
  i2c0_tx_start();
2000cd2a:	f001 fa85 	bl	2000e238 <i2c0_tx_start>
  i2c0_tx_byte(SI5351C_I2C_ADDR | I2C_READ);
2000cd2e:	20c1      	movs	r0, #193	; 0xc1
2000cd30:	f001 fac2 	bl	2000e2b8 <i2c0_tx_byte>
  val = i2c0_rx_byte();
2000cd34:	f001 fb0c 	bl	2000e350 <i2c0_rx_byte>
2000cd38:	1c04      	adds	r4, r0, #0
  i2c0_stop();
2000cd3a:	f001 fb5d 	bl	2000e3f8 <i2c0_stop>

  return val;
}
2000cd3e:	1c20      	adds	r0, r4, #0
2000cd40:	bd10      	pop	{r4, pc}
	...

2000cd44 <airspy_r820t_write_direct>:
    r820t_write_reg(priv, 0x0B, b);
}

/* write to single register but do not update priv (return 0 if success) */
static void airspy_r820t_write_direct(uint8_t reg, uint8_t val)
{
2000cd44:	b538      	push	{r3, r4, r5, lr}

  port_num = PORT_EN_R820T;
  pin_num = PIN_EN_R820T;

  /* GPIO DIR is set to OUT read the GPIO_SET reg */
  value = ((GPIO_SET(port_num) & pin_num) != 0);
2000cd46:	4b0c      	ldr	r3, [pc, #48]	; (2000cd78 <airspy_r820t_write_direct+0x34>)
    r820t_write_reg(priv, 0x0B, b);
}

/* write to single register but do not update priv (return 0 if success) */
static void airspy_r820t_write_direct(uint8_t reg, uint8_t val)
{
2000cd48:	1c05      	adds	r5, r0, #0

  port_num = PORT_EN_R820T;
  pin_num = PIN_EN_R820T;

  /* GPIO DIR is set to OUT read the GPIO_SET reg */
  value = ((GPIO_SET(port_num) & pin_num) != 0);
2000cd4a:	6818      	ldr	r0, [r3, #0]
    r820t_write_reg(priv, 0x0B, b);
}

/* write to single register but do not update priv (return 0 if success) */
static void airspy_r820t_write_direct(uint8_t reg, uint8_t val)
{
2000cd4c:	1c0c      	adds	r4, r1, #0
  port_num = PORT_EN_R820T;
  pin_num = PIN_EN_R820T;

  /* GPIO DIR is set to OUT read the GPIO_SET reg */
  value = ((GPIO_SET(port_num) & pin_num) != 0);
  if(value == 1)
2000cd4e:	0602      	lsls	r2, r0, #24
2000cd50:	d510      	bpl.n	2000cd74 <airspy_r820t_write_direct+0x30>
  {
    if(r820t_state_standby == 0)
2000cd52:	490a      	ldr	r1, [pc, #40]	; (2000cd7c <airspy_r820t_write_direct+0x38>)
2000cd54:	780a      	ldrb	r2, [r1, #0]
2000cd56:	2a00      	cmp	r2, #0
2000cd58:	d10c      	bne.n	2000cd74 <airspy_r820t_write_direct+0x30>
/* write to single register but do not update priv (return 0 if success) */
static void airspy_r820t_write_direct(uint8_t reg, uint8_t val)
{
  if(r820t_is_power_enabled() == true)
  {
    i2c1_tx_start();
2000cd5a:	f001 fa8d 	bl	2000e278 <i2c1_tx_start>
    i2c1_tx_byte(R820T_I2C_ADDR | I2C_WRITE);
2000cd5e:	2034      	movs	r0, #52	; 0x34
2000cd60:	f001 fad0 	bl	2000e304 <i2c1_tx_byte>
    i2c1_tx_byte(reg);
2000cd64:	1c28      	adds	r0, r5, #0
2000cd66:	f001 facd 	bl	2000e304 <i2c1_tx_byte>
    i2c1_tx_byte(val);
2000cd6a:	1c20      	adds	r0, r4, #0
2000cd6c:	f001 faca 	bl	2000e304 <i2c1_tx_byte>
    i2c1_stop();
2000cd70:	f001 fb54 	bl	2000e41c <i2c1_stop>
  }
}
2000cd74:	bd38      	pop	{r3, r4, r5, pc}
2000cd76:	46c0      	nop			; (mov r8, r8)
2000cd78:	400f6204 	.word	0x400f6204
2000cd7c:	2000ef2c 	.word	0x2000ef2c

2000cd80 <r820t_freq_get_idx>:
  uint32_t freq_mhz_fix;

  if(freq_mhz < FREQ_50MHZ)
  {
    /* Frequency Less than 50MHz */
    return FREQ_TO_IDX_0_TO_49MHZ;
2000cd80:	2100      	movs	r1, #0

int r820t_freq_get_idx(uint32_t freq_mhz)
{
  uint32_t freq_mhz_fix;

  if(freq_mhz < FREQ_50MHZ)
2000cd82:	2831      	cmp	r0, #49	; 0x31
2000cd84:	d906      	bls.n	2000cd94 <r820t_freq_get_idx+0x14>
  }else
  {
    /* Frequency Between 50 to 649MHz use table */
    /* Fix the frequency for the table */
    freq_mhz_fix = freq_mhz - FREQ_50MHZ;
    if(freq_mhz_fix < FREQ_TO_IDX_SIZE)
2000cd86:	4a04      	ldr	r2, [pc, #16]	; (2000cd98 <r820t_freq_get_idx+0x18>)
    return FREQ_TO_IDX_0_TO_49MHZ;
  }else
  {
    /* Frequency Between 50 to 649MHz use table */
    /* Fix the frequency for the table */
    freq_mhz_fix = freq_mhz - FREQ_50MHZ;
2000cd88:	3832      	subs	r0, #50	; 0x32

      return freq_to_idx[freq_mhz_fix];
    }else
    {
      /* Frequency Between 650 to 1800MHz */
      return FREQ_TO_IDX_650_TO_1800MHZ;
2000cd8a:	2114      	movs	r1, #20
  }else
  {
    /* Frequency Between 50 to 649MHz use table */
    /* Fix the frequency for the table */
    freq_mhz_fix = freq_mhz - FREQ_50MHZ;
    if(freq_mhz_fix < FREQ_TO_IDX_SIZE)
2000cd8c:	4290      	cmp	r0, r2
2000cd8e:	d801      	bhi.n	2000cd94 <r820t_freq_get_idx+0x14>
    {

      return freq_to_idx[freq_mhz_fix];
2000cd90:	4b02      	ldr	r3, [pc, #8]	; (2000cd9c <r820t_freq_get_idx+0x1c>)
2000cd92:	5c19      	ldrb	r1, [r3, r0]
    {
      /* Frequency Between 650 to 1800MHz */
      return FREQ_TO_IDX_650_TO_1800MHZ;
    }
  }
}
2000cd94:	1c08      	adds	r0, r1, #0
2000cd96:	4770      	bx	lr
2000cd98:	00000257 	.word	0x00000257
2000cd9c:	2000e9c4 	.word	0x2000e9c4

2000cda0 <airspy_r820t_write_init>:

/*
 * Write regs 5 to 32 (R820T_INIT_NB_REGS values) using data parameter and write last reg to 0
 */
void airspy_r820t_write_init(const uint8_t* data)
{
2000cda0:	b538      	push	{r3, r4, r5, lr}

  port_num = PORT_EN_R820T;
  pin_num = PIN_EN_R820T;

  /* GPIO DIR is set to OUT read the GPIO_SET reg */
  value = ((GPIO_SET(port_num) & pin_num) != 0);
2000cda2:	4b0e      	ldr	r3, [pc, #56]	; (2000cddc <airspy_r820t_write_init+0x3c>)

/*
 * Write regs 5 to 32 (R820T_INIT_NB_REGS values) using data parameter and write last reg to 0
 */
void airspy_r820t_write_init(const uint8_t* data)
{
2000cda4:	1c05      	adds	r5, r0, #0

  port_num = PORT_EN_R820T;
  pin_num = PIN_EN_R820T;

  /* GPIO DIR is set to OUT read the GPIO_SET reg */
  value = ((GPIO_SET(port_num) & pin_num) != 0);
2000cda6:	6818      	ldr	r0, [r3, #0]
  if(value == 1)
2000cda8:	0602      	lsls	r2, r0, #24
2000cdaa:	d516      	bpl.n	2000cdda <airspy_r820t_write_init+0x3a>
  {
    if(r820t_state_standby == 0)
2000cdac:	490c      	ldr	r1, [pc, #48]	; (2000cde0 <airspy_r820t_write_init+0x40>)
2000cdae:	780c      	ldrb	r4, [r1, #0]
2000cdb0:	2c00      	cmp	r4, #0
2000cdb2:	d112      	bne.n	2000cdda <airspy_r820t_write_init+0x3a>
{
  uint_fast8_t i;

  if(r820t_is_power_enabled() == true)
  {
    i2c1_tx_start();
2000cdb4:	f001 fa60 	bl	2000e278 <i2c1_tx_start>
    i2c1_tx_byte(R820T_I2C_ADDR | I2C_WRITE);
2000cdb8:	2034      	movs	r0, #52	; 0x34
2000cdba:	f001 faa3 	bl	2000e304 <i2c1_tx_byte>
    i2c1_tx_byte(REG_SHADOW_START); /* Start reg */
2000cdbe:	2005      	movs	r0, #5
2000cdc0:	f001 faa0 	bl	2000e304 <i2c1_tx_byte>

    for (i = 0; i < R820T_INIT_NB_REGS; i++)
      i2c1_tx_byte(data[i]);
2000cdc4:	5d28      	ldrb	r0, [r5, r4]
  {
    i2c1_tx_start();
    i2c1_tx_byte(R820T_I2C_ADDR | I2C_WRITE);
    i2c1_tx_byte(REG_SHADOW_START); /* Start reg */

    for (i = 0; i < R820T_INIT_NB_REGS; i++)
2000cdc6:	3401      	adds	r4, #1
      i2c1_tx_byte(data[i]);
2000cdc8:	f001 fa9c 	bl	2000e304 <i2c1_tx_byte>
  {
    i2c1_tx_start();
    i2c1_tx_byte(R820T_I2C_ADDR | I2C_WRITE);
    i2c1_tx_byte(REG_SHADOW_START); /* Start reg */

    for (i = 0; i < R820T_INIT_NB_REGS; i++)
2000cdcc:	2c1b      	cmp	r4, #27
2000cdce:	d1f9      	bne.n	2000cdc4 <airspy_r820t_write_init+0x24>
      i2c1_tx_byte(data[i]);

    i2c1_tx_byte(0); /* Set last reg to 0 (errata r820t) */
2000cdd0:	2000      	movs	r0, #0
2000cdd2:	f001 fa97 	bl	2000e304 <i2c1_tx_byte>

    i2c1_stop();
2000cdd6:	f001 fb21 	bl	2000e41c <i2c1_stop>
  }
}
2000cdda:	bd38      	pop	{r3, r4, r5, pc}
2000cddc:	400f6204 	.word	0x400f6204
2000cde0:	2000ef2c 	.word	0x2000ef2c

2000cde4 <airspy_r820t_read>:
{
 return (lut[byte & 0xf] << 4) | lut[byte >> 4];
}

void airspy_r820t_read(r820t_priv_t *priv, uint8_t* const data, const uint8_t data_count)
{
2000cde4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  port_num = PORT_EN_R820T;
  pin_num = PIN_EN_R820T;

  /* GPIO DIR is set to OUT read the GPIO_SET reg */
  value = ((GPIO_SET(port_num) & pin_num) != 0);
2000cde6:	4b25      	ldr	r3, [pc, #148]	; (2000ce7c <airspy_r820t_read+0x98>)
{
 return (lut[byte & 0xf] << 4) | lut[byte >> 4];
}

void airspy_r820t_read(r820t_priv_t *priv, uint8_t* const data, const uint8_t data_count)
{
2000cde8:	1c16      	adds	r6, r2, #0

  port_num = PORT_EN_R820T;
  pin_num = PIN_EN_R820T;

  /* GPIO DIR is set to OUT read the GPIO_SET reg */
  value = ((GPIO_SET(port_num) & pin_num) != 0);
2000cdea:	681a      	ldr	r2, [r3, #0]
2000cdec:	2480      	movs	r4, #128	; 0x80
{
 return (lut[byte & 0xf] << 4) | lut[byte >> 4];
}

void airspy_r820t_read(r820t_priv_t *priv, uint8_t* const data, const uint8_t data_count)
{
2000cdee:	1c0d      	adds	r5, r1, #0

  port_num = PORT_EN_R820T;
  pin_num = PIN_EN_R820T;

  /* GPIO DIR is set to OUT read the GPIO_SET reg */
  value = ((GPIO_SET(port_num) & pin_num) != 0);
2000cdf0:	4014      	ands	r4, r2
  if(value == 1)
2000cdf2:	d00c      	beq.n	2000ce0e <airspy_r820t_read+0x2a>
  {
    if(r820t_state_standby == 0)
2000cdf4:	4922      	ldr	r1, [pc, #136]	; (2000ce80 <airspy_r820t_read+0x9c>)
2000cdf6:	2400      	movs	r4, #0
2000cdf8:	780f      	ldrb	r7, [r1, #0]
2000cdfa:	2f00      	cmp	r7, #0
2000cdfc:	d107      	bne.n	2000ce0e <airspy_r820t_read+0x2a>
2000cdfe:	e00c      	b.n	2000ce1a <airspy_r820t_read+0x36>

static int r820t_read_cache_reg(r820t_priv_t *priv, int reg)
{
  reg -= REG_SHADOW_START;

  if (reg >= 0 && reg < NUM_REGS)
2000ce00:	1f67      	subs	r7, r4, #5
2000ce02:	2f1d      	cmp	r7, #29
2000ce04:	d806      	bhi.n	2000ce14 <airspy_r820t_read+0x30>
static uint8_t r82xx_bitrev(uint8_t byte)
{
 return (lut[byte & 0xf] << 4) | lut[byte >> 4];
}

void airspy_r820t_read(r820t_priv_t *priv, uint8_t* const data, const uint8_t data_count)
2000ce06:	1902      	adds	r2, r0, r4
static int r820t_read_cache_reg(r820t_priv_t *priv, int reg)
{
  reg -= REG_SHADOW_START;

  if (reg >= 0 && reg < NUM_REGS)
    return priv->regs[reg];
2000ce08:	79d3      	ldrb	r3, [r2, #7]
  }else
  {
    /* Data cannot be read when R820T is OFF, just read cache */
    for(i=0; i<data_count; i++)
    {
      data[i] = r820t_read_cache_reg(priv, i);
2000ce0a:	552b      	strb	r3, [r5, r4]

    i2c1_stop();
  }else
  {
    /* Data cannot be read when R820T is OFF, just read cache */
    for(i=0; i<data_count; i++)
2000ce0c:	3401      	adds	r4, #1
2000ce0e:	42b4      	cmp	r4, r6
2000ce10:	dbf6      	blt.n	2000ce00 <airspy_r820t_read+0x1c>
2000ce12:	e032      	b.n	2000ce7a <airspy_r820t_read+0x96>
  reg -= REG_SHADOW_START;

  if (reg >= 0 && reg < NUM_REGS)
    return priv->regs[reg];
  else
    return -1;
2000ce14:	2101      	movs	r1, #1
2000ce16:	424b      	negs	r3, r1
2000ce18:	e7f7      	b.n	2000ce0a <airspy_r820t_read+0x26>
  uint32_t val;

  if(r820t_is_power_enabled() == true)
  {
    /* read the value */
    i2c1_tx_start();
2000ce1a:	f001 fa2d 	bl	2000e278 <i2c1_tx_start>
    i2c1_tx_byte(R820T_I2C_ADDR | I2C_READ);
2000ce1e:	2035      	movs	r0, #53	; 0x35
2000ce20:	f001 fa70 	bl	2000e304 <i2c1_tx_byte>
2000ce24:	4c17      	ldr	r4, [pc, #92]	; (2000ce84 <airspy_r820t_read+0xa0>)

    if(data_count > 1)
2000ce26:	2e01      	cmp	r6, #1
2000ce28:	d80e      	bhi.n	2000ce48 <airspy_r820t_read+0x64>
      val = i2c1_rx_byte(0); /* NACK last byte */
      data[i] = r82xx_bitrev(val); /* Swap data bits as they are received LSB to MSB */

    }else
    {
      val = i2c1_rx_byte(0); /* NACK last byte */
2000ce2a:	1c38      	adds	r0, r7, #0
2000ce2c:	f001 fab6 	bl	2000e39c <i2c1_rx_byte>
 const uint8_t lut[16] = { 0x0, 0x8, 0x4, 0xc, 0x2, 0xa, 0x6, 0xe,
      0x1, 0x9, 0x5, 0xd, 0x3, 0xb, 0x7, 0xf };

static uint8_t r82xx_bitrev(uint8_t byte)
{
 return (lut[byte & 0xf] << 4) | lut[byte >> 4];
2000ce30:	260f      	movs	r6, #15
2000ce32:	4006      	ands	r6, r0
2000ce34:	0907      	lsrs	r7, r0, #4
2000ce36:	5da2      	ldrb	r2, [r4, r6]
2000ce38:	b2f8      	uxtb	r0, r7
2000ce3a:	5c24      	ldrb	r4, [r4, r0]
2000ce3c:	0111      	lsls	r1, r2, #4
2000ce3e:	4321      	orrs	r1, r4
      data[i] = r82xx_bitrev(val); /* Swap data bits as they are received LSB to MSB */

    }else
    {
      val = i2c1_rx_byte(0); /* NACK last byte */
      data[0] = r82xx_bitrev(val); /* Swap data bits as they are received LSB to MSB */
2000ce40:	7029      	strb	r1, [r5, #0]
    }

    i2c1_stop();
2000ce42:	f001 faeb 	bl	2000e41c <i2c1_stop>
2000ce46:	e018      	b.n	2000ce7a <airspy_r820t_read+0x96>
  {
    /* read the value */
    i2c1_tx_start();
    i2c1_tx_byte(R820T_I2C_ADDR | I2C_READ);

    if(data_count > 1)
2000ce48:	1c2f      	adds	r7, r5, #0
    {
      for(i = 0; i < (data_count-1); i++)
2000ce4a:	1e73      	subs	r3, r6, #1
static uint8_t r82xx_bitrev(uint8_t byte)
{
 return (lut[byte & 0xf] << 4) | lut[byte >> 4];
}

void airspy_r820t_read(r820t_priv_t *priv, uint8_t* const data, const uint8_t data_count)
2000ce4c:	1b78      	subs	r0, r7, r5
    i2c1_tx_start();
    i2c1_tx_byte(R820T_I2C_ADDR | I2C_READ);

    if(data_count > 1)
    {
      for(i = 0; i < (data_count-1); i++)
2000ce4e:	4298      	cmp	r0, r3
2000ce50:	da0d      	bge.n	2000ce6e <airspy_r820t_read+0x8a>
      {
        val = i2c1_rx_byte(1); /* ACK each byte */
2000ce52:	2001      	movs	r0, #1
2000ce54:	f001 faa2 	bl	2000e39c <i2c1_rx_byte>
 const uint8_t lut[16] = { 0x0, 0x8, 0x4, 0xc, 0x2, 0xa, 0x6, 0xe,
      0x1, 0x9, 0x5, 0xd, 0x3, 0xb, 0x7, 0xf };

static uint8_t r82xx_bitrev(uint8_t byte)
{
 return (lut[byte & 0xf] << 4) | lut[byte >> 4];
2000ce58:	230f      	movs	r3, #15
2000ce5a:	4003      	ands	r3, r0
2000ce5c:	5ce2      	ldrb	r2, [r4, r3]
2000ce5e:	0900      	lsrs	r0, r0, #4
2000ce60:	b2c3      	uxtb	r3, r0
2000ce62:	0111      	lsls	r1, r2, #4
2000ce64:	5ce2      	ldrb	r2, [r4, r3]
2000ce66:	4311      	orrs	r1, r2
    if(data_count > 1)
    {
      for(i = 0; i < (data_count-1); i++)
      {
        val = i2c1_rx_byte(1); /* ACK each byte */
        data[i] = r82xx_bitrev(val); /* Swap data bits as they are received LSB to MSB */
2000ce68:	7039      	strb	r1, [r7, #0]
2000ce6a:	3701      	adds	r7, #1
2000ce6c:	e7ed      	b.n	2000ce4a <airspy_r820t_read+0x66>
      }

      val = i2c1_rx_byte(0); /* NACK last byte */
2000ce6e:	2000      	movs	r0, #0
      data[i] = r82xx_bitrev(val); /* Swap data bits as they are received LSB to MSB */
2000ce70:	19ad      	adds	r5, r5, r6
      {
        val = i2c1_rx_byte(1); /* ACK each byte */
        data[i] = r82xx_bitrev(val); /* Swap data bits as they are received LSB to MSB */
      }

      val = i2c1_rx_byte(0); /* NACK last byte */
2000ce72:	f001 fa93 	bl	2000e39c <i2c1_rx_byte>
      data[i] = r82xx_bitrev(val); /* Swap data bits as they are received LSB to MSB */
2000ce76:	3d01      	subs	r5, #1
2000ce78:	e7da      	b.n	2000ce30 <airspy_r820t_read+0x4c>
    {
      data[i] = r820t_read_cache_reg(priv, i);
    }
  }
  
}
2000ce7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2000ce7c:	400f6204 	.word	0x400f6204
2000ce80:	2000ef2c 	.word	0x2000ef2c
2000ce84:	2000ec5b 	.word	0x2000ec5b

2000ce88 <airspy_r820t_write_single>:

  port_num = PORT_EN_R820T;
  pin_num = PIN_EN_R820T;

  /* GPIO DIR is set to OUT read the GPIO_SET reg */
  value = ((GPIO_SET(port_num) & pin_num) != 0);
2000ce88:	4b0e      	ldr	r3, [pc, #56]	; (2000cec4 <airspy_r820t_write_single+0x3c>)
  
}

/* write to single register (return 0 if success) */
void airspy_r820t_write_single(r820t_priv_t *priv, uint8_t reg, uint8_t val)
{
2000ce8a:	b570      	push	{r4, r5, r6, lr}
2000ce8c:	1c06      	adds	r6, r0, #0

  port_num = PORT_EN_R820T;
  pin_num = PIN_EN_R820T;

  /* GPIO DIR is set to OUT read the GPIO_SET reg */
  value = ((GPIO_SET(port_num) & pin_num) != 0);
2000ce8e:	6818      	ldr	r0, [r3, #0]
  
}

/* write to single register (return 0 if success) */
void airspy_r820t_write_single(r820t_priv_t *priv, uint8_t reg, uint8_t val)
{
2000ce90:	1c0d      	adds	r5, r1, #0
2000ce92:	1c14      	adds	r4, r2, #0
  port_num = PORT_EN_R820T;
  pin_num = PIN_EN_R820T;

  /* GPIO DIR is set to OUT read the GPIO_SET reg */
  value = ((GPIO_SET(port_num) & pin_num) != 0);
  if(value == 1)
2000ce94:	0602      	lsls	r2, r0, #24
2000ce96:	d503      	bpl.n	2000cea0 <airspy_r820t_write_single+0x18>
  {
    if(r820t_state_standby == 0)
2000ce98:	490b      	ldr	r1, [pc, #44]	; (2000cec8 <airspy_r820t_write_single+0x40>)
2000ce9a:	780a      	ldrb	r2, [r1, #0]
2000ce9c:	2a00      	cmp	r2, #0
2000ce9e:	d002      	beq.n	2000cea6 <airspy_r820t_write_single+0x1e>
    i2c1_tx_byte(R820T_I2C_ADDR | I2C_WRITE);
    i2c1_tx_byte(reg);
    i2c1_tx_byte(val);
    i2c1_stop();
  }
  priv->regs[reg - REG_SHADOW_START] = val;
2000cea0:	1976      	adds	r6, r6, r5
2000cea2:	71f4      	strb	r4, [r6, #7]
}
2000cea4:	bd70      	pop	{r4, r5, r6, pc}
/* write to single register (return 0 if success) */
void airspy_r820t_write_single(r820t_priv_t *priv, uint8_t reg, uint8_t val)
{
  if(r820t_is_power_enabled() == true)
  {
    i2c1_tx_start();
2000cea6:	f001 f9e7 	bl	2000e278 <i2c1_tx_start>
    i2c1_tx_byte(R820T_I2C_ADDR | I2C_WRITE);
2000ceaa:	2034      	movs	r0, #52	; 0x34
2000ceac:	f001 fa2a 	bl	2000e304 <i2c1_tx_byte>
    i2c1_tx_byte(reg);
2000ceb0:	1c28      	adds	r0, r5, #0
2000ceb2:	f001 fa27 	bl	2000e304 <i2c1_tx_byte>
    i2c1_tx_byte(val);
2000ceb6:	1c20      	adds	r0, r4, #0
2000ceb8:	f001 fa24 	bl	2000e304 <i2c1_tx_byte>
    i2c1_stop();
2000cebc:	f001 faae 	bl	2000e41c <i2c1_stop>
2000cec0:	e7ee      	b.n	2000cea0 <airspy_r820t_write_single+0x18>
2000cec2:	46c0      	nop			; (mov r8, r8)
2000cec4:	400f6204 	.word	0x400f6204
2000cec8:	2000ef2c 	.word	0x2000ef2c

2000cecc <r820t_write_reg>:
  val = r820t_read_data[reg];
  return val;
}

static int r820t_write_reg(r820t_priv_t *priv, uint8_t reg, uint8_t val)
{
2000cecc:	b508      	push	{r3, lr}
  return 0;
}

static int r820t_read_cache_reg(r820t_priv_t *priv, int reg)
{
  reg -= REG_SHADOW_START;
2000cece:	1f4b      	subs	r3, r1, #5

  if (reg >= 0 && reg < NUM_REGS)
2000ced0:	2b1d      	cmp	r3, #29
2000ced2:	d802      	bhi.n	2000ceda <r820t_write_reg+0xe>
    return priv->regs[reg];
2000ced4:	18c3      	adds	r3, r0, r3
2000ced6:	7b1b      	ldrb	r3, [r3, #12]
2000ced8:	e001      	b.n	2000cede <r820t_write_reg+0x12>
  else
    return -1;
2000ceda:	2301      	movs	r3, #1
2000cedc:	425b      	negs	r3, r3
  return val;
}

static int r820t_write_reg(r820t_priv_t *priv, uint8_t reg, uint8_t val)
{
  if (r820t_read_cache_reg(priv, reg) == val)
2000cede:	4293      	cmp	r3, r2
2000cee0:	d001      	beq.n	2000cee6 <r820t_write_reg+0x1a>
    return 0;
  airspy_r820t_write_single(priv, reg, val);
2000cee2:	f7ff ffd1 	bl	2000ce88 <airspy_r820t_write_single>
  return 0;
}
2000cee6:	2000      	movs	r0, #0
2000cee8:	bd08      	pop	{r3, pc}

2000ceea <r820t_write_reg_mask>:
  else
    return -1;
}

static int r820t_write_reg_mask(r820t_priv_t *priv, uint8_t reg, uint8_t val, uint8_t bit_mask)
{
2000ceea:	b510      	push	{r4, lr}
  return 0;
}

static int r820t_read_cache_reg(r820t_priv_t *priv, int reg)
{
  reg -= REG_SHADOW_START;
2000ceec:	1f4c      	subs	r4, r1, #5

  if (reg >= 0 && reg < NUM_REGS)
2000ceee:	2c1d      	cmp	r4, #29
2000cef0:	d808      	bhi.n	2000cf04 <r820t_write_reg_mask+0x1a>
    return priv->regs[reg];
2000cef2:	1904      	adds	r4, r0, r4
  int rc = r820t_read_cache_reg(priv, reg);

  if (rc < 0)
    return rc;

  val = (rc & ~bit_mask) | (val & bit_mask);
2000cef4:	7b24      	ldrb	r4, [r4, #12]
2000cef6:	439c      	bics	r4, r3
2000cef8:	4013      	ands	r3, r2

  return r820t_write_reg(priv, reg, val);
2000cefa:	1c22      	adds	r2, r4, #0
2000cefc:	431a      	orrs	r2, r3
2000cefe:	f7ff ffe5 	bl	2000cecc <r820t_write_reg>
2000cf02:	e001      	b.n	2000cf08 <r820t_write_reg_mask+0x1e>

static int r820t_read_cache_reg(r820t_priv_t *priv, int reg)
{
  reg -= REG_SHADOW_START;

  if (reg >= 0 && reg < NUM_REGS)
2000cf04:	2001      	movs	r0, #1
2000cf06:	4240      	negs	r0, r0
    return rc;

  val = (rc & ~bit_mask) | (val & bit_mask);

  return r820t_write_reg(priv, reg, val);
}
2000cf08:	bd10      	pop	{r4, pc}
	...

2000cf0c <airspy_r820t_read_single>:
  priv->regs[reg - REG_SHADOW_START] = val;
}

/* read single register */
uint8_t airspy_r820t_read_single(r820t_priv_t *priv, uint8_t reg)
{
2000cf0c:	b538      	push	{r3, r4, r5, lr}
  uint8_t val;

  /* read the value */
  airspy_r820t_read(priv, r820t_read_data, reg+1);
2000cf0e:	4d04      	ldr	r5, [pc, #16]	; (2000cf20 <airspy_r820t_read_single+0x14>)
2000cf10:	1c4a      	adds	r2, r1, #1
  priv->regs[reg - REG_SHADOW_START] = val;
}

/* read single register */
uint8_t airspy_r820t_read_single(r820t_priv_t *priv, uint8_t reg)
{
2000cf12:	1c0c      	adds	r4, r1, #0
  uint8_t val;

  /* read the value */
  airspy_r820t_read(priv, r820t_read_data, reg+1);
2000cf14:	b2d2      	uxtb	r2, r2
2000cf16:	1c29      	adds	r1, r5, #0
2000cf18:	f7ff ff64 	bl	2000cde4 <airspy_r820t_read>
  val = r820t_read_data[reg];
  return val;
2000cf1c:	5d28      	ldrb	r0, [r5, r4]
}
2000cf1e:	bd38      	pop	{r3, r4, r5, pc}
2000cf20:	2000f744 	.word	0x2000f744

2000cf24 <r820t_set_pll>:

  return rc;
}

int r820t_set_pll(r820t_priv_t *priv, uint32_t freq)
{
2000cf24:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  const uint32_t vco_min = 1770000000;
  const uint32_t vco_max = 3900000000;
  uint32_t pll_ref = (priv->xtal_freq >> 1);
2000cf26:	6805      	ldr	r5, [r0, #0]

  return rc;
}

int r820t_set_pll(r820t_priv_t *priv, uint32_t freq)
{
2000cf28:	1c04      	adds	r4, r0, #0
2000cf2a:	1c0e      	adds	r6, r1, #0
  uint8_t ni;
  uint8_t si;
  uint8_t nint;

  /* Calculate divider */
  for (div_num = 0; div_num < 5; div_num++)
2000cf2c:	2300      	movs	r3, #0
  {
    vco_exact = freq << (div_num + 1);
2000cf2e:	1c5f      	adds	r7, r3, #1
2000cf30:	1c31      	adds	r1, r6, #0
    if (vco_exact >= vco_min && vco_exact <= vco_max)
2000cf32:	4a2f      	ldr	r2, [pc, #188]	; (2000cff0 <r820t_set_pll+0xcc>)
  uint8_t nint;

  /* Calculate divider */
  for (div_num = 0; div_num < 5; div_num++)
  {
    vco_exact = freq << (div_num + 1);
2000cf34:	40b9      	lsls	r1, r7
    if (vco_exact >= vco_min && vco_exact <= vco_max)
2000cf36:	1888      	adds	r0, r1, r2
2000cf38:	492e      	ldr	r1, [pc, #184]	; (2000cff4 <r820t_set_pll+0xd0>)
2000cf3a:	4288      	cmp	r0, r1
2000cf3c:	d903      	bls.n	2000cf46 <r820t_set_pll+0x22>
  uint8_t ni;
  uint8_t si;
  uint8_t nint;

  /* Calculate divider */
  for (div_num = 0; div_num < 5; div_num++)
2000cf3e:	1e3b      	subs	r3, r7, #0
2000cf40:	2b05      	cmp	r3, #5
2000cf42:	d1f4      	bne.n	2000cf2e <r820t_set_pll+0xa>
2000cf44:	e000      	b.n	2000cf48 <r820t_set_pll+0x24>
  {
    vco_exact = freq << (div_num + 1);
    if (vco_exact >= vco_min && vco_exact <= vco_max)
2000cf46:	1c1f      	adds	r7, r3, #0
  nint -= 13;
  ni = (nint >> 2);
  si = nint - (ni << 2);

  /* Set the phase splitter */
  rc = r820t_write_reg_mask(priv, 0x10, (uint8_t) (div_num << 5), 0xe0);
2000cf48:	017a      	lsls	r2, r7, #5
2000cf4a:	b2d2      	uxtb	r2, r2
2000cf4c:	1c20      	adds	r0, r4, #0
2000cf4e:	2110      	movs	r1, #16
2000cf50:	23e0      	movs	r3, #224	; 0xe0
2000cf52:	f7ff ffca 	bl	2000ceea <r820t_write_reg_mask>
  if(rc < 0)
2000cf56:	2800      	cmp	r0, #0
2000cf58:	db48      	blt.n	2000cfec <r820t_set_pll+0xc8>
    {
      break;
    }
  }

  vco_exact = freq << (div_num + 1);
2000cf5a:	3701      	adds	r7, #1
  nint = (uint8_t) ((vco_exact + (pll_ref >> 16)) / pll_ref_2x);
2000cf5c:	0c69      	lsrs	r1, r5, #17

int r820t_set_pll(r820t_priv_t *priv, uint32_t freq)
{
  const uint32_t vco_min = 1770000000;
  const uint32_t vco_max = 3900000000;
  uint32_t pll_ref = (priv->xtal_freq >> 1);
2000cf5e:	0868      	lsrs	r0, r5, #1
    {
      break;
    }
  }

  vco_exact = freq << (div_num + 1);
2000cf60:	40be      	lsls	r6, r7

int r820t_set_pll(r820t_priv_t *priv, uint32_t freq)
{
  const uint32_t vco_min = 1770000000;
  const uint32_t vco_max = 3900000000;
  uint32_t pll_ref = (priv->xtal_freq >> 1);
2000cf62:	9001      	str	r0, [sp, #4]
      break;
    }
  }

  vco_exact = freq << (div_num + 1);
  nint = (uint8_t) ((vco_exact + (pll_ref >> 16)) / pll_ref_2x);
2000cf64:	9100      	str	r1, [sp, #0]
2000cf66:	1870      	adds	r0, r6, r1
2000cf68:	1c29      	adds	r1, r5, #0
2000cf6a:	f001 fbcd 	bl	2000e708 <__aeabi_uidiv>
  vco_frac = vco_exact - pll_ref_2x * nint;

  nint -= 13;
2000cf6e:	1c03      	adds	r3, r0, #0
2000cf70:	3b0d      	subs	r3, #13
2000cf72:	b2da      	uxtb	r2, r3
      break;
    }
  }

  vco_exact = freq << (div_num + 1);
  nint = (uint8_t) ((vco_exact + (pll_ref >> 16)) / pll_ref_2x);
2000cf74:	1c07      	adds	r7, r0, #0
  vco_frac = vco_exact - pll_ref_2x * nint;

  nint -= 13;
  ni = (nint >> 2);
2000cf76:	0890      	lsrs	r0, r2, #2
  si = nint - (ni << 2);
2000cf78:	0081      	lsls	r1, r0, #2
2000cf7a:	1a53      	subs	r3, r2, r1
  rc = r820t_write_reg_mask(priv, 0x10, (uint8_t) (div_num << 5), 0xe0);
  if(rc < 0)
    return rc;

  /* Set the rough VCO frequency */
  rc = r820t_write_reg(priv, 0x14, (uint8_t) (ni + (si << 6)));
2000cf7c:	019a      	lsls	r2, r3, #6
2000cf7e:	1880      	adds	r0, r0, r2
2000cf80:	b2c2      	uxtb	r2, r0
2000cf82:	2114      	movs	r1, #20
2000cf84:	1c20      	adds	r0, r4, #0
2000cf86:	f7ff ffa1 	bl	2000cecc <r820t_write_reg>
  if(rc < 0)
2000cf8a:	2800      	cmp	r0, #0
2000cf8c:	db2e      	blt.n	2000cfec <r820t_set_pll+0xc8>
    }
  }

  vco_exact = freq << (div_num + 1);
  nint = (uint8_t) ((vco_exact + (pll_ref >> 16)) / pll_ref_2x);
  vco_frac = vco_exact - pll_ref_2x * nint;
2000cf8e:	b2ff      	uxtb	r7, r7
2000cf90:	437d      	muls	r5, r7
2000cf92:	1b76      	subs	r6, r6, r5
  /* Set the rough VCO frequency */
  rc = r820t_write_reg(priv, 0x14, (uint8_t) (ni + (si << 6)));
  if(rc < 0)
    return rc;

  if (vco_frac == 0)
2000cf94:	d104      	bne.n	2000cfa0 <r820t_set_pll+0x7c>
  {
    /* Disable frac pll */
    rc = r820t_write_reg_mask(priv, 0x12, 0x08, 0x08);
2000cf96:	2208      	movs	r2, #8
2000cf98:	1c20      	adds	r0, r4, #0
2000cf9a:	2112      	movs	r1, #18
2000cf9c:	1c13      	adds	r3, r2, #0
2000cf9e:	e023      	b.n	2000cfe8 <r820t_set_pll+0xc4>
    if(rc < 0)
      return rc;
  }
  else
  {
    vco_frac += pll_ref >> 16;
2000cfa0:	9d00      	ldr	r5, [sp, #0]
    sdm = 0;
2000cfa2:	2700      	movs	r7, #0
    if(rc < 0)
      return rc;
  }
  else
  {
    vco_frac += pll_ref >> 16;
2000cfa4:	1976      	adds	r6, r6, r5
    sdm = 0;
    for(n_sdm = 0; n_sdm < 16; n_sdm++)
2000cfa6:	1c3b      	adds	r3, r7, #0
    {
        con_frac = pll_ref >> n_sdm;
2000cfa8:	9a01      	ldr	r2, [sp, #4]
2000cfaa:	40da      	lsrs	r2, r3
        if (vco_frac >= con_frac)
2000cfac:	4296      	cmp	r6, r2
2000cfae:	d306      	bcc.n	2000cfbe <r820t_set_pll+0x9a>
        {
            sdm |= (uint16_t) (0x8000 >> n_sdm);
2000cfb0:	2180      	movs	r1, #128	; 0x80
2000cfb2:	0208      	lsls	r0, r1, #8
2000cfb4:	4118      	asrs	r0, r3
2000cfb6:	4307      	orrs	r7, r0
2000cfb8:	b2bf      	uxth	r7, r7
            vco_frac -= con_frac;
2000cfba:	1ab6      	subs	r6, r6, r2
            if (vco_frac == 0)
2000cfbc:	d002      	beq.n	2000cfc4 <r820t_set_pll+0xa0>
  }
  else
  {
    vco_frac += pll_ref >> 16;
    sdm = 0;
    for(n_sdm = 0; n_sdm < 16; n_sdm++)
2000cfbe:	3301      	adds	r3, #1
2000cfc0:	2b10      	cmp	r3, #16
2000cfc2:	d1f1      	bne.n	2000cfa8 <r820t_set_pll+0x84>
    if (actual_freq != freq)
    {
      fprintf(stderr,"Tunning delta: %d Hz", delta);
    }
*/
    rc = r820t_write_reg(priv, 0x15, (uint8_t)(sdm & 0xff));
2000cfc4:	b2fa      	uxtb	r2, r7
2000cfc6:	1c20      	adds	r0, r4, #0
2000cfc8:	2115      	movs	r1, #21
2000cfca:	f7ff ff7f 	bl	2000cecc <r820t_write_reg>
    if (rc < 0)
2000cfce:	2800      	cmp	r0, #0
2000cfd0:	db0c      	blt.n	2000cfec <r820t_set_pll+0xc8>
      return rc;

    rc = r820t_write_reg(priv, 0x16, (uint8_t)(sdm >> 8));
2000cfd2:	0a3a      	lsrs	r2, r7, #8
2000cfd4:	1c20      	adds	r0, r4, #0
2000cfd6:	2116      	movs	r1, #22
2000cfd8:	f7ff ff78 	bl	2000cecc <r820t_write_reg>
    if (rc < 0)
2000cfdc:	2800      	cmp	r0, #0
2000cfde:	db05      	blt.n	2000cfec <r820t_set_pll+0xc8>
      return rc;

    /* Enable frac pll */
    rc = r820t_write_reg_mask(priv, 0x12, 0x00, 0x08);
2000cfe0:	1c20      	adds	r0, r4, #0
2000cfe2:	2112      	movs	r1, #18
2000cfe4:	2200      	movs	r2, #0
2000cfe6:	2308      	movs	r3, #8
2000cfe8:	f7ff ff7f 	bl	2000ceea <r820t_write_reg_mask>
    if (rc < 0)
      return rc;
  }
  return rc;
}
2000cfec:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
2000cfee:	46c0      	nop			; (mov r8, r8)
2000cff0:	967ff180 	.word	0x967ff180
2000cff4:	7ef53880 	.word	0x7ef53880

2000cff8 <r820t_set_freq>:

int r820t_set_freq(r820t_priv_t *priv, uint32_t freq)
{
2000cff8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int freq_idx;
  int rc = 0;

  /* Get the proper frequency range in MHz instead of Hz */
  /* Fast divide freq by 1000000 */
  freq = (uint32_t)((uint64_t)freq * 4295 >> 32);
2000cffa:	4b26      	ldr	r3, [pc, #152]	; (2000d094 <r820t_set_freq+0x9c>)
2000cffc:	4a24      	ldr	r2, [pc, #144]	; (2000d090 <r820t_set_freq+0x98>)
  }
  return rc;
}

int r820t_set_freq(r820t_priv_t *priv, uint32_t freq)
{
2000cffe:	1c04      	adds	r4, r0, #0
2000d000:	1c0d      	adds	r5, r1, #0
  int rc;
  uint32_t lo_freq = freq + priv->if_freq;
2000d002:	6887      	ldr	r7, [r0, #8]
  int freq_idx;
  int rc = 0;

  /* Get the proper frequency range in MHz instead of Hz */
  /* Fast divide freq by 1000000 */
  freq = (uint32_t)((uint64_t)freq * 4295 >> 32);
2000d004:	1c08      	adds	r0, r1, #0
2000d006:	2100      	movs	r1, #0
2000d008:	f001 fbce 	bl	2000e7a8 <__aeabi_lmul>

  freq_idx = r820t_freq_get_idx(freq);
2000d00c:	1c08      	adds	r0, r1, #0
2000d00e:	f7ff feb7 	bl	2000cd80 <r820t_freq_get_idx>
  range = &freq_ranges[freq_idx];
2000d012:	2603      	movs	r6, #3
2000d014:	4370      	muls	r0, r6
2000d016:	4920      	ldr	r1, [pc, #128]	; (2000d098 <r820t_set_freq+0xa0>)
#ifdef OPTIM_SET_MUX
  if(freq_idx != r820t_set_mux_freq_idx)
  {
#endif
    /* Open Drain */
    rc = r820t_write_reg_mask(priv, 0x17, range->open_d, 0x08);
2000d018:	2308      	movs	r3, #8
  /* Get the proper frequency range in MHz instead of Hz */
  /* Fast divide freq by 1000000 */
  freq = (uint32_t)((uint64_t)freq * 4295 >> 32);

  freq_idx = r820t_freq_get_idx(freq);
  range = &freq_ranges[freq_idx];
2000d01a:	180e      	adds	r6, r1, r0
#ifdef OPTIM_SET_MUX
  if(freq_idx != r820t_set_mux_freq_idx)
  {
#endif
    /* Open Drain */
    rc = r820t_write_reg_mask(priv, 0x17, range->open_d, 0x08);
2000d01c:	7832      	ldrb	r2, [r6, #0]
2000d01e:	1c20      	adds	r0, r4, #0
2000d020:	2117      	movs	r1, #23
2000d022:	f7ff ff62 	bl	2000ceea <r820t_write_reg_mask>
    if (rc < 0)
2000d026:	2800      	cmp	r0, #0
2000d028:	db2e      	blt.n	2000d088 <r820t_set_freq+0x90>
      return rc;

    /* RF_MUX,Polymux */
    rc = r820t_write_reg_mask(priv, 0x1a, range->rf_mux_ploy, 0xc3);
2000d02a:	7872      	ldrb	r2, [r6, #1]
2000d02c:	1c20      	adds	r0, r4, #0
2000d02e:	211a      	movs	r1, #26
2000d030:	23c3      	movs	r3, #195	; 0xc3
2000d032:	f7ff ff5a 	bl	2000ceea <r820t_write_reg_mask>
    if (rc < 0)
2000d036:	2800      	cmp	r0, #0
2000d038:	db26      	blt.n	2000d088 <r820t_set_freq+0x90>
      return rc;

    /* TF BAND */
    rc = r820t_write_reg(priv, 0x1b, range->tf_c);
2000d03a:	78b2      	ldrb	r2, [r6, #2]
2000d03c:	1c20      	adds	r0, r4, #0
2000d03e:	211b      	movs	r1, #27
2000d040:	f7ff ff44 	bl	2000cecc <r820t_write_reg>
    if (rc < 0)
2000d044:	2800      	cmp	r0, #0
2000d046:	db1f      	blt.n	2000d088 <r820t_set_freq+0x90>
      return rc;

    /* XTAL CAP & Drive */
    rc = r820t_write_reg_mask(priv, 0x10, 0x08, 0x0b);
2000d048:	1c20      	adds	r0, r4, #0
2000d04a:	2110      	movs	r1, #16
2000d04c:	2208      	movs	r2, #8
2000d04e:	230b      	movs	r3, #11
2000d050:	f7ff ff4b 	bl	2000ceea <r820t_write_reg_mask>
    if (rc < 0)
2000d054:	2800      	cmp	r0, #0
2000d056:	db17      	blt.n	2000d088 <r820t_set_freq+0x90>
      return rc;

    rc = r820t_write_reg_mask(priv, 0x08, 0x00, 0x3f);
2000d058:	1c20      	adds	r0, r4, #0
2000d05a:	2108      	movs	r1, #8
2000d05c:	2200      	movs	r2, #0
2000d05e:	233f      	movs	r3, #63	; 0x3f
2000d060:	f7ff ff43 	bl	2000ceea <r820t_write_reg_mask>
    if (rc < 0)
2000d064:	2800      	cmp	r0, #0
2000d066:	db0f      	blt.n	2000d088 <r820t_set_freq+0x90>
      return rc;

    rc = r820t_write_reg_mask(priv, 0x09, 0x00, 0x3f);
2000d068:	1c20      	adds	r0, r4, #0
2000d06a:	2109      	movs	r1, #9
2000d06c:	2200      	movs	r2, #0
2000d06e:	233f      	movs	r3, #63	; 0x3f
2000d070:	f7ff ff3b 	bl	2000ceea <r820t_write_reg_mask>
{
  int rc;
  uint32_t lo_freq = freq + priv->if_freq;

  rc = r820t_set_tf(priv, freq);
  if (rc < 0)
2000d074:	2800      	cmp	r0, #0
2000d076:	db07      	blt.n	2000d088 <r820t_set_freq+0x90>
}

int r820t_set_freq(r820t_priv_t *priv, uint32_t freq)
{
  int rc;
  uint32_t lo_freq = freq + priv->if_freq;
2000d078:	19e9      	adds	r1, r5, r7

  rc = r820t_set_tf(priv, freq);
  if (rc < 0)
    return rc;

  rc = r820t_set_pll(priv, lo_freq);
2000d07a:	1c20      	adds	r0, r4, #0
2000d07c:	f7ff ff52 	bl	2000cf24 <r820t_set_pll>
  if (rc < 0)
2000d080:	2800      	cmp	r0, #0
2000d082:	db01      	blt.n	2000d088 <r820t_set_freq+0x90>
    return rc;

  priv->freq = freq;
2000d084:	6065      	str	r5, [r4, #4]

  return 0;
2000d086:	2000      	movs	r0, #0
}
2000d088:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2000d08a:	46c0      	nop			; (mov r8, r8)
2000d08c:	46c0      	nop			; (mov r8, r8)
2000d08e:	46c0      	nop			; (mov r8, r8)
2000d090:	000010c7 	.word	0x000010c7
2000d094:	00000000 	.word	0x00000000
2000d098:	2000ec1c 	.word	0x2000ec1c
2000d09c:	46c0      	nop			; (mov r8, r8)
2000d09e:	46c0      	nop			; (mov r8, r8)

2000d0a0 <r820t_set_lna_gain>:

int r820t_set_lna_gain(r820t_priv_t *priv, uint8_t gain_index)
{
2000d0a0:	b508      	push	{r3, lr}
2000d0a2:	1c0a      	adds	r2, r1, #0
  return r820t_write_reg_mask(priv, 0x05, gain_index, 0x0f);
2000d0a4:	230f      	movs	r3, #15
2000d0a6:	2105      	movs	r1, #5
2000d0a8:	f7ff ff1f 	bl	2000ceea <r820t_write_reg_mask>
}
2000d0ac:	bd08      	pop	{r3, pc}

2000d0ae <r820t_set_mixer_gain>:

int r820t_set_mixer_gain(r820t_priv_t *priv, uint8_t gain_index)
{
2000d0ae:	b508      	push	{r3, lr}
2000d0b0:	1c0a      	adds	r2, r1, #0
  return r820t_write_reg_mask(priv, 0x07, gain_index, 0x0f);
2000d0b2:	230f      	movs	r3, #15
2000d0b4:	2107      	movs	r1, #7
2000d0b6:	f7ff ff18 	bl	2000ceea <r820t_write_reg_mask>
}
2000d0ba:	bd08      	pop	{r3, pc}

2000d0bc <r820t_set_vga_gain>:

int r820t_set_vga_gain(r820t_priv_t *priv, uint8_t gain_index)
{
2000d0bc:	b508      	push	{r3, lr}
2000d0be:	1c0a      	adds	r2, r1, #0
  return r820t_write_reg_mask(priv, 0x0c, gain_index, 0x0f);
2000d0c0:	230f      	movs	r3, #15
2000d0c2:	210c      	movs	r1, #12
2000d0c4:	f7ff ff11 	bl	2000ceea <r820t_write_reg_mask>
}
2000d0c8:	bd08      	pop	{r3, pc}

2000d0ca <r820t_set_lna_agc>:

int r820t_set_lna_agc(r820t_priv_t *priv, uint8_t value)
{
2000d0ca:	b508      	push	{r3, lr}
  value = value != 0 ? 0x00 : 0x10;
2000d0cc:	424a      	negs	r2, r1
2000d0ce:	414a      	adcs	r2, r1
2000d0d0:	0112      	lsls	r2, r2, #4
  return r820t_write_reg_mask(priv, 0x05, value, 0x10);
2000d0d2:	2105      	movs	r1, #5
2000d0d4:	2310      	movs	r3, #16
2000d0d6:	f7ff ff08 	bl	2000ceea <r820t_write_reg_mask>
}
2000d0da:	bd08      	pop	{r3, pc}

2000d0dc <r820t_set_mixer_agc>:

int r820t_set_mixer_agc(r820t_priv_t *priv, uint8_t value)
{
2000d0dc:	b508      	push	{r3, lr}
2000d0de:	1e0a      	subs	r2, r1, #0
  value = value != 0 ? 0x10 : 0x00;
2000d0e0:	d000      	beq.n	2000d0e4 <r820t_set_mixer_agc+0x8>
2000d0e2:	2210      	movs	r2, #16
  return r820t_write_reg_mask(priv, 0x07, value, 0x10);
2000d0e4:	2107      	movs	r1, #7
2000d0e6:	2310      	movs	r3, #16
2000d0e8:	f7ff feff 	bl	2000ceea <r820t_write_reg_mask>
}
2000d0ec:	bd08      	pop	{r3, pc}
	...

2000d0f0 <r820t_calibrate>:
"inspired by Mauro Carvalho Chehab calibration technique"
https://stuff.mit.edu/afs/sipb/contrib/linux/drivers/media/tuners/r820t.c
part of r820t_set_tv_standard()
*/
int r820t_calibrate(r820t_priv_t *priv)
{
2000d0f0:	b537      	push	{r0, r1, r2, r4, r5, lr}
2000d0f2:	1c04      	adds	r4, r0, #0
2000d0f4:	2505      	movs	r5, #5
  uint8_t data[5];

  for (i = 0; i < 5; i++)
  {
    /* Set filt_cap */
    rc = r820t_write_reg_mask(priv, 0x0b, 0x08, 0x60);
2000d0f6:	1c20      	adds	r0, r4, #0
2000d0f8:	210b      	movs	r1, #11
2000d0fa:	2208      	movs	r2, #8
2000d0fc:	2360      	movs	r3, #96	; 0x60
2000d0fe:	f7ff fef4 	bl	2000ceea <r820t_write_reg_mask>
    if (rc < 0)
2000d102:	2800      	cmp	r0, #0
2000d104:	db43      	blt.n	2000d18e <r820t_calibrate+0x9e>
      return rc;

    /* set cali clk =on */
    rc = r820t_write_reg_mask(priv, 0x0f, 0x04, 0x04);
2000d106:	2204      	movs	r2, #4
2000d108:	1c20      	adds	r0, r4, #0
2000d10a:	210f      	movs	r1, #15
2000d10c:	1c13      	adds	r3, r2, #0
2000d10e:	f7ff feec 	bl	2000ceea <r820t_write_reg_mask>
    if (rc < 0)
2000d112:	2800      	cmp	r0, #0
2000d114:	db3b      	blt.n	2000d18e <r820t_calibrate+0x9e>
      return rc;

    /* X'tal cap 0pF for PLL */
    rc = r820t_write_reg_mask(priv, 0x10, 0x00, 0x03);
2000d116:	1c20      	adds	r0, r4, #0
2000d118:	2110      	movs	r1, #16
2000d11a:	2200      	movs	r2, #0
2000d11c:	2303      	movs	r3, #3
2000d11e:	f7ff fee4 	bl	2000ceea <r820t_write_reg_mask>
    if (rc < 0)
2000d122:	2800      	cmp	r0, #0
2000d124:	db33      	blt.n	2000d18e <r820t_calibrate+0x9e>
      return rc;

    rc = r820t_set_pll(priv, CALIBRATION_LO * 1000);
2000d126:	1c20      	adds	r0, r4, #0
2000d128:	4919      	ldr	r1, [pc, #100]	; (2000d190 <r820t_calibrate+0xa0>)
2000d12a:	f7ff fefb 	bl	2000cf24 <r820t_set_pll>
    if (rc < 0)
2000d12e:	2800      	cmp	r0, #0
2000d130:	db2d      	blt.n	2000d18e <r820t_calibrate+0x9e>
      return rc;

    /* Start Trigger */
    rc = r820t_write_reg_mask(priv, 0x0b, 0x10, 0x10);
2000d132:	2210      	movs	r2, #16
2000d134:	1c20      	adds	r0, r4, #0
2000d136:	210b      	movs	r1, #11
2000d138:	1c13      	adds	r3, r2, #0
2000d13a:	f7ff fed6 	bl	2000ceea <r820t_write_reg_mask>
    if (rc < 0)
2000d13e:	2800      	cmp	r0, #0
2000d140:	db25      	blt.n	2000d18e <r820t_calibrate+0x9e>
      return rc;

    delay(10000);
2000d142:	4814      	ldr	r0, [pc, #80]	; (2000d194 <r820t_calibrate+0xa4>)
2000d144:	f7ff fda4 	bl	2000cc90 <delay>

    /* Stop Trigger */
    rc = r820t_write_reg_mask(priv, 0x0b, 0x00, 0x10);
2000d148:	1c20      	adds	r0, r4, #0
2000d14a:	210b      	movs	r1, #11
2000d14c:	2200      	movs	r2, #0
2000d14e:	2310      	movs	r3, #16
2000d150:	f7ff fecb 	bl	2000ceea <r820t_write_reg_mask>
    if (rc < 0)
2000d154:	2800      	cmp	r0, #0
2000d156:	db1a      	blt.n	2000d18e <r820t_calibrate+0x9e>
      return rc;

    /* set cali clk =off */
    rc = r820t_write_reg_mask(priv, 0x0f, 0x00, 0x04);
2000d158:	1c20      	adds	r0, r4, #0
2000d15a:	210f      	movs	r1, #15
2000d15c:	2200      	movs	r2, #0
2000d15e:	2304      	movs	r3, #4
2000d160:	f7ff fec3 	bl	2000ceea <r820t_write_reg_mask>
    if (rc < 0)
2000d164:	2800      	cmp	r0, #0
2000d166:	db12      	blt.n	2000d18e <r820t_calibrate+0x9e>
}

static int r820t_read(r820t_priv_t *priv, uint8_t *val, int len)
{
  /* reg not used and assumed to be always 0 because start from reg0 to reg0+len */
  airspy_r820t_read(priv, val, len);
2000d168:	1c20      	adds	r0, r4, #0
2000d16a:	2205      	movs	r2, #5
2000d16c:	4669      	mov	r1, sp
2000d16e:	f7ff fe39 	bl	2000cde4 <airspy_r820t_read>
    /* Check if calibration worked */
    rc = r820t_read(priv, data, sizeof(data));
    if (rc < 0)
      return rc;

    cal_code = data[4] & 0x0f;
2000d172:	466b      	mov	r3, sp
2000d174:	791a      	ldrb	r2, [r3, #4]
2000d176:	200f      	movs	r0, #15
2000d178:	4010      	ands	r0, r2
    if (cal_code && cal_code != 0x0f)
2000d17a:	d001      	beq.n	2000d180 <r820t_calibrate+0x90>
2000d17c:	280f      	cmp	r0, #15
2000d17e:	d105      	bne.n	2000d18c <r820t_calibrate+0x9c>
2000d180:	3d01      	subs	r5, #1
int r820t_calibrate(r820t_priv_t *priv)
{
  int i, rc, cal_code;
  uint8_t data[5];

  for (i = 0; i < 5; i++)
2000d182:	2d00      	cmp	r5, #0
2000d184:	d1b7      	bne.n	2000d0f6 <r820t_calibrate+0x6>
    cal_code = data[4] & 0x0f;
    if (cal_code && cal_code != 0x0f)
      return 0;
  }

  return -1;
2000d186:	2101      	movs	r1, #1
2000d188:	4248      	negs	r0, r1
2000d18a:	e000      	b.n	2000d18e <r820t_calibrate+0x9e>
    if (rc < 0)
      return rc;

    cal_code = data[4] & 0x0f;
    if (cal_code && cal_code != 0x0f)
      return 0;
2000d18c:	2000      	movs	r0, #0
  }

  return -1;
}
2000d18e:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
2000d190:	053ec600 	.word	0x053ec600
2000d194:	00002710 	.word	0x00002710

2000d198 <r820t_init>:

int r820t_init(r820t_priv_t *priv, const uint32_t if_freq)
{
2000d198:	b538      	push	{r3, r4, r5, lr}
  int rc;
  uint32_t saved_freq;

  r820t_state_standby = 0;
2000d19a:	4b0e      	ldr	r3, [pc, #56]	; (2000d1d4 <r820t_init+0x3c>)

  return -1;
}

int r820t_init(r820t_priv_t *priv, const uint32_t if_freq)
{
2000d19c:	1c04      	adds	r4, r0, #0
  int rc;
  uint32_t saved_freq;

  r820t_state_standby = 0;
2000d19e:	2200      	movs	r2, #0
  priv->if_freq = if_freq;
2000d1a0:	6081      	str	r1, [r0, #8]
  /* Initialize registers */
  airspy_r820t_write_init(priv->regs);
2000d1a2:	300c      	adds	r0, #12
int r820t_init(r820t_priv_t *priv, const uint32_t if_freq)
{
  int rc;
  uint32_t saved_freq;

  r820t_state_standby = 0;
2000d1a4:	701a      	strb	r2, [r3, #0]
  priv->if_freq = if_freq;
  /* Initialize registers */
  airspy_r820t_write_init(priv->regs);
2000d1a6:	f7ff fdfb 	bl	2000cda0 <airspy_r820t_write_init>

  r820t_set_freq(priv, priv->freq);
2000d1aa:	6861      	ldr	r1, [r4, #4]
2000d1ac:	1c20      	adds	r0, r4, #0
2000d1ae:	f7ff ff23 	bl	2000cff8 <r820t_set_freq>

  /* Calibrate the IF filter */
  saved_freq = priv->freq;
  rc = r820t_calibrate(priv);
2000d1b2:	1c20      	adds	r0, r4, #0
  airspy_r820t_write_init(priv->regs);

  r820t_set_freq(priv, priv->freq);

  /* Calibrate the IF filter */
  saved_freq = priv->freq;
2000d1b4:	6865      	ldr	r5, [r4, #4]
  rc = r820t_calibrate(priv);
2000d1b6:	f7ff ff9b 	bl	2000d0f0 <r820t_calibrate>
  priv->freq = saved_freq;
2000d1ba:	6065      	str	r5, [r4, #4]
  if (rc < 0)
2000d1bc:	2800      	cmp	r0, #0
2000d1be:	da03      	bge.n	2000d1c8 <r820t_init+0x30>
  {
    saved_freq = priv->freq;
    r820t_calibrate(priv);
2000d1c0:	1c20      	adds	r0, r4, #0
2000d1c2:	f7ff ff95 	bl	2000d0f0 <r820t_calibrate>
    priv->freq = saved_freq;
2000d1c6:	6065      	str	r5, [r4, #4]
  }

  /* Restore freq as it has been modified by r820t_calibrate() */
  rc = r820t_set_freq(priv, priv->freq);
2000d1c8:	1c29      	adds	r1, r5, #0
2000d1ca:	1c20      	adds	r0, r4, #0
2000d1cc:	f7ff ff14 	bl	2000cff8 <r820t_set_freq>
  return rc;
}
2000d1d0:	bd38      	pop	{r3, r4, r5, pc}
2000d1d2:	46c0      	nop			; (mov r8, r8)
2000d1d4:	2000ef2c 	.word	0x2000ef2c

2000d1d8 <r820t_set_if_bandwidth>:
  /* Enter in Standby mode */
  r820t_standby();
}

void r820t_set_if_bandwidth(r820t_priv_t *priv, uint8_t bw)
{
2000d1d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    const uint8_t modes[] = { 0xE0, 0x80, 0x60, 0x00 };
2000d1da:	4f11      	ldr	r7, [pc, #68]	; (2000d220 <r820t_set_if_bandwidth+0x48>)
  /* Enter in Standby mode */
  r820t_standby();
}

void r820t_set_if_bandwidth(r820t_priv_t *priv, uint8_t bw)
{
2000d1dc:	b087      	sub	sp, #28
    const uint8_t modes[] = { 0xE0, 0x80, 0x60, 0x00 };
2000d1de:	ae01      	add	r6, sp, #4
  /* Enter in Standby mode */
  r820t_standby();
}

void r820t_set_if_bandwidth(r820t_priv_t *priv, uint8_t bw)
{
2000d1e0:	1c04      	adds	r4, r0, #0
2000d1e2:	1c0d      	adds	r5, r1, #0
    const uint8_t modes[] = { 0xE0, 0x80, 0x60, 0x00 };
2000d1e4:	1c30      	adds	r0, r6, #0
2000d1e6:	1c39      	adds	r1, r7, #0
2000d1e8:	2204      	movs	r2, #4
2000d1ea:	f001 faff 	bl	2000e7ec <memcpy>
    const uint8_t opt[] = { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
2000d1ee:	1d39      	adds	r1, r7, #4
2000d1f0:	a802      	add	r0, sp, #8
2000d1f2:	2210      	movs	r2, #16
2000d1f4:	f001 fafa 	bl	2000e7ec <memcpy>
    uint8_t a = 0xB0 | opt[bw & 0x0F];
    uint8_t b = 0x0F | modes[bw >> 4];
2000d1f8:	200f      	movs	r0, #15
2000d1fa:	092b      	lsrs	r3, r5, #4

void r820t_set_if_bandwidth(r820t_priv_t *priv, uint8_t bw)
{
    const uint8_t modes[] = { 0xE0, 0x80, 0x60, 0x00 };
    const uint8_t opt[] = { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
    uint8_t a = 0xB0 | opt[bw & 0x0F];
2000d1fc:	a902      	add	r1, sp, #8
2000d1fe:	4005      	ands	r5, r0
    uint8_t b = 0x0F | modes[bw >> 4];
2000d200:	5cf6      	ldrb	r6, [r6, r3]

void r820t_set_if_bandwidth(r820t_priv_t *priv, uint8_t bw)
{
    const uint8_t modes[] = { 0xE0, 0x80, 0x60, 0x00 };
    const uint8_t opt[] = { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
    uint8_t a = 0xB0 | opt[bw & 0x0F];
2000d202:	5d4a      	ldrb	r2, [r1, r5]
2000d204:	25b0      	movs	r5, #176	; 0xb0
    uint8_t b = 0x0F | modes[bw >> 4];
2000d206:	4306      	orrs	r6, r0
    r820t_write_reg(priv, 0x0A, a);
2000d208:	432a      	orrs	r2, r5
2000d20a:	1c20      	adds	r0, r4, #0
2000d20c:	210a      	movs	r1, #10
2000d20e:	f7ff fe5d 	bl	2000cecc <r820t_write_reg>
    r820t_write_reg(priv, 0x0B, b);
2000d212:	1c20      	adds	r0, r4, #0
2000d214:	210b      	movs	r1, #11
2000d216:	1c32      	adds	r2, r6, #0
2000d218:	f7ff fe58 	bl	2000cecc <r820t_write_reg>
}
2000d21c:	b007      	add	sp, #28
2000d21e:	bdf0      	pop	{r4, r5, r6, r7, pc}
2000d220:	2000e9b0 	.word	0x2000e9b0

2000d224 <r820t_standby>:
    i2c1_stop();
  }
}

int r820t_standby(void)
{
2000d224:	b508      	push	{r3, lr}
  airspy_r820t_write_direct(0x05, 0xA0);
2000d226:	2005      	movs	r0, #5
2000d228:	21a0      	movs	r1, #160	; 0xa0
2000d22a:	f7ff fd8b 	bl	2000cd44 <airspy_r820t_write_direct>
  airspy_r820t_write_direct(0x06, 0xD0);
2000d22e:	2006      	movs	r0, #6
2000d230:	21d0      	movs	r1, #208	; 0xd0
2000d232:	f7ff fd87 	bl	2000cd44 <airspy_r820t_write_direct>
  airspy_r820t_write_direct(0x07, 0x00);
2000d236:	2007      	movs	r0, #7
2000d238:	2100      	movs	r1, #0
2000d23a:	f7ff fd83 	bl	2000cd44 <airspy_r820t_write_direct>
  airspy_r820t_write_direct(0x08, 0x40);
2000d23e:	2008      	movs	r0, #8
2000d240:	2140      	movs	r1, #64	; 0x40
2000d242:	f7ff fd7f 	bl	2000cd44 <airspy_r820t_write_direct>
  airspy_r820t_write_direct(0x09, 0xC0);
2000d246:	2009      	movs	r0, #9
2000d248:	21c0      	movs	r1, #192	; 0xc0
2000d24a:	f7ff fd7b 	bl	2000cd44 <airspy_r820t_write_direct>
  airspy_r820t_write_direct(0x0a, 0x70);
2000d24e:	200a      	movs	r0, #10
2000d250:	2170      	movs	r1, #112	; 0x70
2000d252:	f7ff fd77 	bl	2000cd44 <airspy_r820t_write_direct>
  airspy_r820t_write_direct(0x0c, 0xA0);
2000d256:	200c      	movs	r0, #12
2000d258:	21a0      	movs	r1, #160	; 0xa0
2000d25a:	f7ff fd73 	bl	2000cd44 <airspy_r820t_write_direct>
  airspy_r820t_write_direct(0x0f, 0x2A);
2000d25e:	200f      	movs	r0, #15
2000d260:	212a      	movs	r1, #42	; 0x2a
2000d262:	f7ff fd6f 	bl	2000cd44 <airspy_r820t_write_direct>
  airspy_r820t_write_direct(0x11, 0x03);
2000d266:	2011      	movs	r0, #17
2000d268:	2103      	movs	r1, #3
2000d26a:	f7ff fd6b 	bl	2000cd44 <airspy_r820t_write_direct>
  airspy_r820t_write_direct(0x17, 0xF4);
2000d26e:	2017      	movs	r0, #23
2000d270:	21f4      	movs	r1, #244	; 0xf4
2000d272:	f7ff fd67 	bl	2000cd44 <airspy_r820t_write_direct>
  airspy_r820t_write_direct(0x19, 0x0C);
2000d276:	2019      	movs	r0, #25
2000d278:	210c      	movs	r1, #12
2000d27a:	f7ff fd63 	bl	2000cd44 <airspy_r820t_write_direct>
  r820t_state_standby = 1;
2000d27e:	4b02      	ldr	r3, [pc, #8]	; (2000d288 <r820t_standby+0x64>)
2000d280:	2201      	movs	r2, #1

  return 0;
}
2000d282:	2000      	movs	r0, #0
  airspy_r820t_write_direct(0x0c, 0xA0);
  airspy_r820t_write_direct(0x0f, 0x2A);
  airspy_r820t_write_direct(0x11, 0x03);
  airspy_r820t_write_direct(0x17, 0xF4);
  airspy_r820t_write_direct(0x19, 0x0C);
  r820t_state_standby = 1;
2000d284:	701a      	strb	r2, [r3, #0]

  return 0;
}
2000d286:	bd08      	pop	{r3, pc}
2000d288:	2000ef2c 	.word	0x2000ef2c

2000d28c <r820t_startup>:
  rc = r820t_set_freq(priv, priv->freq);
  return rc;
}

void r820t_startup(r820t_priv_t *priv)
{
2000d28c:	b508      	push	{r3, lr}
  r820t_state_standby = 0;
2000d28e:	4b04      	ldr	r3, [pc, #16]	; (2000d2a0 <r820t_startup+0x14>)
2000d290:	2200      	movs	r2, #0
  /* Initialize registers */
  airspy_r820t_write_init(priv->regs);
2000d292:	300c      	adds	r0, #12
  return rc;
}

void r820t_startup(r820t_priv_t *priv)
{
  r820t_state_standby = 0;
2000d294:	701a      	strb	r2, [r3, #0]
  /* Initialize registers */
  airspy_r820t_write_init(priv->regs);
2000d296:	f7ff fd83 	bl	2000cda0 <airspy_r820t_write_init>
  /* Enter in Standby mode */
  r820t_standby();
2000d29a:	f7ff ffc3 	bl	2000d224 <r820t_standby>
}
2000d29e:	bd08      	pop	{r3, pc}
2000d2a0:	2000ef2c 	.word	0x2000ef2c

2000d2a4 <w25q80bv_get_status>:
    device_id = w25q80bv_get_device_id();
  }
}

uint8_t w25q80bv_get_status(void)
{
2000d2a4:	b570      	push	{r4, r5, r6, lr}
  uint8_t value;

  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d2a6:	4d0b      	ldr	r5, [pc, #44]	; (2000d2d4 <w25q80bv_get_status+0x30>)
2000d2a8:	2480      	movs	r4, #128	; 0x80
2000d2aa:	0124      	lsls	r4, r4, #4
2000d2ac:	1c28      	adds	r0, r5, #0
2000d2ae:	1c21      	adds	r1, r4, #0
2000d2b0:	f7ff fbfd 	bl	2000caae <gpio_clear>
  ssp_transfer(SSP0_NUM, W25Q80BV_READ_STATUS1);
2000d2b4:	2105      	movs	r1, #5
2000d2b6:	2000      	movs	r0, #0
2000d2b8:	f001 f922 	bl	2000e500 <ssp_transfer>
  value = ssp_transfer(SSP0_NUM, 0xFF);
2000d2bc:	21ff      	movs	r1, #255	; 0xff
2000d2be:	2000      	movs	r0, #0
2000d2c0:	f001 f91e 	bl	2000e500 <ssp_transfer>
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d2c4:	1c21      	adds	r1, r4, #0
{
  uint8_t value;

  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
  ssp_transfer(SSP0_NUM, W25Q80BV_READ_STATUS1);
  value = ssp_transfer(SSP0_NUM, 0xFF);
2000d2c6:	1c06      	adds	r6, r0, #0
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d2c8:	1c28      	adds	r0, r5, #0
2000d2ca:	f7ff fbeb 	bl	2000caa4 <gpio_set>

  return value;
2000d2ce:	b2f0      	uxtb	r0, r6
}
2000d2d0:	bd70      	pop	{r4, r5, r6, pc}
2000d2d2:	46c0      	nop			; (mov r8, r8)
2000d2d4:	400f6014 	.word	0x400f6014

2000d2d8 <w25q80bv_get_device_id>:

/* Release power down / Device ID */  
uint8_t w25q80bv_get_device_id(void)
{
2000d2d8:	b570      	push	{r4, r5, r6, lr}
  uint8_t value;

  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d2da:	4d11      	ldr	r5, [pc, #68]	; (2000d320 <w25q80bv_get_device_id+0x48>)
2000d2dc:	2480      	movs	r4, #128	; 0x80
2000d2de:	0124      	lsls	r4, r4, #4
2000d2e0:	1c28      	adds	r0, r5, #0
2000d2e2:	1c21      	adds	r1, r4, #0
2000d2e4:	f7ff fbe3 	bl	2000caae <gpio_clear>
  ssp_transfer(SSP0_NUM, W25Q80BV_DEVICE_ID);
2000d2e8:	21ab      	movs	r1, #171	; 0xab
2000d2ea:	2000      	movs	r0, #0
2000d2ec:	f001 f908 	bl	2000e500 <ssp_transfer>

  /* Read 3 dummy bytes */
  value = ssp_transfer(SSP0_NUM, 0xFF);
2000d2f0:	21ff      	movs	r1, #255	; 0xff
2000d2f2:	2000      	movs	r0, #0
2000d2f4:	f001 f904 	bl	2000e500 <ssp_transfer>
  value = ssp_transfer(SSP0_NUM, 0xFF);
2000d2f8:	21ff      	movs	r1, #255	; 0xff
2000d2fa:	2000      	movs	r0, #0
2000d2fc:	f001 f900 	bl	2000e500 <ssp_transfer>
  value = ssp_transfer(SSP0_NUM, 0xFF);
2000d300:	21ff      	movs	r1, #255	; 0xff
2000d302:	2000      	movs	r0, #0
2000d304:	f001 f8fc 	bl	2000e500 <ssp_transfer>
  /* Read Device ID shall return 0x13 for W25Q80BV */
  value = ssp_transfer(SSP0_NUM, 0xFF);
2000d308:	21ff      	movs	r1, #255	; 0xff
2000d30a:	2000      	movs	r0, #0
2000d30c:	f001 f8f8 	bl	2000e500 <ssp_transfer>
  
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d310:	1c21      	adds	r1, r4, #0
  /* Read 3 dummy bytes */
  value = ssp_transfer(SSP0_NUM, 0xFF);
  value = ssp_transfer(SSP0_NUM, 0xFF);
  value = ssp_transfer(SSP0_NUM, 0xFF);
  /* Read Device ID shall return 0x13 for W25Q80BV */
  value = ssp_transfer(SSP0_NUM, 0xFF);
2000d312:	1c06      	adds	r6, r0, #0
  
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d314:	1c28      	adds	r0, r5, #0
2000d316:	f7ff fbc5 	bl	2000caa4 <gpio_set>

  return value;
2000d31a:	b2f0      	uxtb	r0, r6
}
2000d31c:	bd70      	pop	{r4, r5, r6, pc}
2000d31e:	46c0      	nop			; (mov r8, r8)
2000d320:	400f6014 	.word	0x400f6014

2000d324 <w25q80bv_setup>:
* Set up pins for GPIO and SPI control, configure SSP0 peripheral for SPI.
* SSP0_SSEL is controlled by GPIO in order to handle various transfer lengths.
*/

void w25q80bv_setup(void)
{
2000d324:	b5f0      	push	{r4, r5, r6, r7, lr}
  const uint8_t serial_clock_rate = 2;
  const uint8_t clock_prescale_rate = 2;

  /* Reset SPIFI peripheral before to Erase/Write SPIFI memory through SPI */
  RESET_CTRL1 = RESET_CTRL1_SPIFI_RST;
2000d326:	2280      	movs	r2, #128	; 0x80
2000d328:	4b31      	ldr	r3, [pc, #196]	; (2000d3f0 <w25q80bv_setup+0xcc>)
2000d32a:	0390      	lsls	r0, r2, #14
* Set up pins for GPIO and SPI control, configure SSP0 peripheral for SPI.
* SSP0_SSEL is controlled by GPIO in order to handle various transfer lengths.
*/

void w25q80bv_setup(void)
{
2000d32c:	b087      	sub	sp, #28
  const uint8_t serial_clock_rate = 2;
  const uint8_t clock_prescale_rate = 2;

  /* Reset SPIFI peripheral before to Erase/Write SPIFI memory through SPI */
  RESET_CTRL1 = RESET_CTRL1_SPIFI_RST;
2000d32e:	6018      	str	r0, [r3, #0]
  
  /* Init SPIFI GPIO to Normal GPIO */
  scu_pinmux(P3_3, (SCU_SSP_IO | SCU_CONF_FUNCTION2));    // P3_3 SPIFI_SCK => SSP0_SCK
2000d330:	21f2      	movs	r1, #242	; 0xf2
2000d332:	4830      	ldr	r0, [pc, #192]	; (2000d3f4 <w25q80bv_setup+0xd0>)
2000d334:	f000 ff48 	bl	2000e1c8 <scu_pinmux>
  scu_pinmux(P3_4, (SCU_GPIO_FAST | SCU_CONF_FUNCTION0)); // P3_4 SPIFI SPIFI_SIO3 IO3 => GPIO1[14]
2000d338:	482f      	ldr	r0, [pc, #188]	; (2000d3f8 <w25q80bv_setup+0xd4>)
2000d33a:	21f0      	movs	r1, #240	; 0xf0
2000d33c:	f000 ff44 	bl	2000e1c8 <scu_pinmux>
  scu_pinmux(P3_5, (SCU_GPIO_FAST | SCU_CONF_FUNCTION0)); // P3_5 SPIFI SPIFI_SIO2 IO2 => GPIO1[15]
2000d340:	482e      	ldr	r0, [pc, #184]	; (2000d3fc <w25q80bv_setup+0xd8>)
2000d342:	21f0      	movs	r1, #240	; 0xf0
2000d344:	f000 ff40 	bl	2000e1c8 <scu_pinmux>
  scu_pinmux(P3_6, (SCU_GPIO_FAST | SCU_CONF_FUNCTION0)); // P3_6 SPIFI SPIFI_MISO IO1 => GPIO0[6]
2000d348:	482d      	ldr	r0, [pc, #180]	; (2000d400 <w25q80bv_setup+0xdc>)
2000d34a:	21f0      	movs	r1, #240	; 0xf0
2000d34c:	f000 ff3c 	bl	2000e1c8 <scu_pinmux>
  scu_pinmux(P3_7, (SCU_GPIO_FAST | SCU_CONF_FUNCTION4)); // P3_7 SPIFI SPIFI_MOSI IO0 => GPIO5[10]
2000d350:	482c      	ldr	r0, [pc, #176]	; (2000d404 <w25q80bv_setup+0xe0>)
2000d352:	21f4      	movs	r1, #244	; 0xf4
2000d354:	f000 ff38 	bl	2000e1c8 <scu_pinmux>
  scu_pinmux(P3_8, (SCU_GPIO_FAST | SCU_CONF_FUNCTION4)); // P3_8 SPIFI SPIFI_CS => GPIO5[11]
2000d358:	482b      	ldr	r0, [pc, #172]	; (2000d408 <w25q80bv_setup+0xe4>)
2000d35a:	21f4      	movs	r1, #244	; 0xf4
2000d35c:	f000 ff34 	bl	2000e1c8 <scu_pinmux>
  
  /* configure SSP pins */
  scu_pinmux(SCU_SSP0_MISO, (SCU_SSP_IO | SCU_CONF_FUNCTION5));
2000d360:	4827      	ldr	r0, [pc, #156]	; (2000d400 <w25q80bv_setup+0xdc>)
2000d362:	21f5      	movs	r1, #245	; 0xf5
2000d364:	f000 ff30 	bl	2000e1c8 <scu_pinmux>
  scu_pinmux(SCU_SSP0_MOSI, (SCU_SSP_IO | SCU_CONF_FUNCTION5));
2000d368:	4826      	ldr	r0, [pc, #152]	; (2000d404 <w25q80bv_setup+0xe0>)
2000d36a:	21f5      	movs	r1, #245	; 0xf5
2000d36c:	f000 ff2c 	bl	2000e1c8 <scu_pinmux>
  scu_pinmux(SCU_SSP0_SCK,  (SCU_SSP_IO | SCU_CONF_FUNCTION2));
2000d370:	4820      	ldr	r0, [pc, #128]	; (2000d3f4 <w25q80bv_setup+0xd0>)
2000d372:	21f2      	movs	r1, #242	; 0xf2
2000d374:	f000 ff28 	bl	2000e1c8 <scu_pinmux>

  /* configure GPIO pins */
  scu_pinmux(SCU_FLASH_HOLD, SCU_GPIO_FAST);
2000d378:	481f      	ldr	r0, [pc, #124]	; (2000d3f8 <w25q80bv_setup+0xd4>)
2000d37a:	21f0      	movs	r1, #240	; 0xf0
2000d37c:	f000 ff24 	bl	2000e1c8 <scu_pinmux>
  scu_pinmux(SCU_FLASH_WP, SCU_GPIO_FAST);
  scu_pinmux(SCU_SSP0_SSEL, (SCU_GPIO_FAST | SCU_CONF_FUNCTION4));

  /* drive SSEL, HOLD, and WP pins high */
  gpio_set(PORT_FLASH, (PIN_FLASH_HOLD | PIN_FLASH_WP));
2000d380:	4d22      	ldr	r5, [pc, #136]	; (2000d40c <w25q80bv_setup+0xe8>)
  scu_pinmux(SCU_SSP0_MOSI, (SCU_SSP_IO | SCU_CONF_FUNCTION5));
  scu_pinmux(SCU_SSP0_SCK,  (SCU_SSP_IO | SCU_CONF_FUNCTION2));

  /* configure GPIO pins */
  scu_pinmux(SCU_FLASH_HOLD, SCU_GPIO_FAST);
  scu_pinmux(SCU_FLASH_WP, SCU_GPIO_FAST);
2000d382:	481e      	ldr	r0, [pc, #120]	; (2000d3fc <w25q80bv_setup+0xd8>)
2000d384:	21f0      	movs	r1, #240	; 0xf0
  scu_pinmux(SCU_SSP0_SSEL, (SCU_GPIO_FAST | SCU_CONF_FUNCTION4));

  /* drive SSEL, HOLD, and WP pins high */
  gpio_set(PORT_FLASH, (PIN_FLASH_HOLD | PIN_FLASH_WP));
2000d386:	27c0      	movs	r7, #192	; 0xc0
  scu_pinmux(SCU_SSP0_MOSI, (SCU_SSP_IO | SCU_CONF_FUNCTION5));
  scu_pinmux(SCU_SSP0_SCK,  (SCU_SSP_IO | SCU_CONF_FUNCTION2));

  /* configure GPIO pins */
  scu_pinmux(SCU_FLASH_HOLD, SCU_GPIO_FAST);
  scu_pinmux(SCU_FLASH_WP, SCU_GPIO_FAST);
2000d388:	f000 ff1e 	bl	2000e1c8 <scu_pinmux>
  scu_pinmux(SCU_SSP0_SSEL, (SCU_GPIO_FAST | SCU_CONF_FUNCTION4));

  /* drive SSEL, HOLD, and WP pins high */
  gpio_set(PORT_FLASH, (PIN_FLASH_HOLD | PIN_FLASH_WP));
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d38c:	4c20      	ldr	r4, [pc, #128]	; (2000d410 <w25q80bv_setup+0xec>)
  scu_pinmux(SCU_SSP0_SCK,  (SCU_SSP_IO | SCU_CONF_FUNCTION2));

  /* configure GPIO pins */
  scu_pinmux(SCU_FLASH_HOLD, SCU_GPIO_FAST);
  scu_pinmux(SCU_FLASH_WP, SCU_GPIO_FAST);
  scu_pinmux(SCU_SSP0_SSEL, (SCU_GPIO_FAST | SCU_CONF_FUNCTION4));
2000d38e:	481e      	ldr	r0, [pc, #120]	; (2000d408 <w25q80bv_setup+0xe4>)
2000d390:	21f4      	movs	r1, #244	; 0xf4

  /* drive SSEL, HOLD, and WP pins high */
  gpio_set(PORT_FLASH, (PIN_FLASH_HOLD | PIN_FLASH_WP));
2000d392:	023f      	lsls	r7, r7, #8
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d394:	2680      	movs	r6, #128	; 0x80
  scu_pinmux(SCU_SSP0_SCK,  (SCU_SSP_IO | SCU_CONF_FUNCTION2));

  /* configure GPIO pins */
  scu_pinmux(SCU_FLASH_HOLD, SCU_GPIO_FAST);
  scu_pinmux(SCU_FLASH_WP, SCU_GPIO_FAST);
  scu_pinmux(SCU_SSP0_SSEL, (SCU_GPIO_FAST | SCU_CONF_FUNCTION4));
2000d396:	f000 ff17 	bl	2000e1c8 <scu_pinmux>

  /* drive SSEL, HOLD, and WP pins high */
  gpio_set(PORT_FLASH, (PIN_FLASH_HOLD | PIN_FLASH_WP));
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d39a:	0136      	lsls	r6, r6, #4
  scu_pinmux(SCU_FLASH_HOLD, SCU_GPIO_FAST);
  scu_pinmux(SCU_FLASH_WP, SCU_GPIO_FAST);
  scu_pinmux(SCU_SSP0_SSEL, (SCU_GPIO_FAST | SCU_CONF_FUNCTION4));

  /* drive SSEL, HOLD, and WP pins high */
  gpio_set(PORT_FLASH, (PIN_FLASH_HOLD | PIN_FLASH_WP));
2000d39c:	1c28      	adds	r0, r5, #0
2000d39e:	1c39      	adds	r1, r7, #0
2000d3a0:	f7ff fb80 	bl	2000caa4 <gpio_set>
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d3a4:	1c31      	adds	r1, r6, #0
2000d3a6:	1c20      	adds	r0, r4, #0
2000d3a8:	f7ff fb7c 	bl	2000caa4 <gpio_set>

  /* Set GPIO pins as outputs. */
  GPIO1_DIR |= (PIN_FLASH_HOLD | PIN_FLASH_WP);
2000d3ac:	6829      	ldr	r1, [r5, #0]
  GPIO5_DIR |= PIN_SSP0_SSEL;
  
  /* initialize SSP0 */
  ssp_init(SSP0_NUM,
2000d3ae:	2002      	movs	r0, #2
  /* drive SSEL, HOLD, and WP pins high */
  gpio_set(PORT_FLASH, (PIN_FLASH_HOLD | PIN_FLASH_WP));
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);

  /* Set GPIO pins as outputs. */
  GPIO1_DIR |= (PIN_FLASH_HOLD | PIN_FLASH_WP);
2000d3b0:	430f      	orrs	r7, r1
2000d3b2:	602f      	str	r7, [r5, #0]
  GPIO5_DIR |= PIN_SSP0_SSEL;
2000d3b4:	6822      	ldr	r2, [r4, #0]
  
  /* initialize SSP0 */
  ssp_init(SSP0_NUM,
2000d3b6:	2500      	movs	r5, #0
  gpio_set(PORT_FLASH, (PIN_FLASH_HOLD | PIN_FLASH_WP));
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);

  /* Set GPIO pins as outputs. */
  GPIO1_DIR |= (PIN_FLASH_HOLD | PIN_FLASH_WP);
  GPIO5_DIR |= PIN_SSP0_SSEL;
2000d3b8:	4316      	orrs	r6, r2
2000d3ba:	6026      	str	r6, [r4, #0]
  
  /* initialize SSP0 */
  ssp_init(SSP0_NUM,
2000d3bc:	1c2b      	adds	r3, r5, #0
2000d3be:	9000      	str	r0, [sp, #0]
2000d3c0:	9001      	str	r0, [sp, #4]
2000d3c2:	9502      	str	r5, [sp, #8]
2000d3c4:	9503      	str	r5, [sp, #12]
2000d3c6:	9504      	str	r5, [sp, #16]
2000d3c8:	1c28      	adds	r0, r5, #0
2000d3ca:	2107      	movs	r1, #7
2000d3cc:	1c2a      	adds	r2, r5, #0
2000d3ce:	f001 f837 	bl	2000e440 <ssp_init>
  clock_prescale_rate,
  SSP_MODE_NORMAL,
  SSP_MASTER,
  SSP_SLAVE_OUT_ENABLE);

  device_id = 0;
2000d3d2:	4b10      	ldr	r3, [pc, #64]	; (2000d414 <w25q80bv_setup+0xf0>)
2000d3d4:	701d      	strb	r5, [r3, #0]
2000d3d6:	1c1f      	adds	r7, r3, #0

  while(1)
  {
    if(device_id == W25Q80BV_DEVICE_ID_RES)
2000d3d8:	783c      	ldrb	r4, [r7, #0]
2000d3da:	2c13      	cmp	r4, #19
2000d3dc:	d005      	beq.n	2000d3ea <w25q80bv_setup+0xc6>
    break;

    if(device_id == S25FL032P_DEVICE_ID_RES)
2000d3de:	2c15      	cmp	r4, #21
2000d3e0:	d003      	beq.n	2000d3ea <w25q80bv_setup+0xc6>
    break;

    device_id = w25q80bv_get_device_id();
2000d3e2:	f7ff ff79 	bl	2000d2d8 <w25q80bv_get_device_id>
2000d3e6:	7038      	strb	r0, [r7, #0]
  }
2000d3e8:	e7f6      	b.n	2000d3d8 <w25q80bv_setup+0xb4>
}
2000d3ea:	b007      	add	sp, #28
2000d3ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
2000d3ee:	46c0      	nop			; (mov r8, r8)
2000d3f0:	40053104 	.word	0x40053104
2000d3f4:	4008618c 	.word	0x4008618c
2000d3f8:	40086190 	.word	0x40086190
2000d3fc:	40086194 	.word	0x40086194
2000d400:	40086198 	.word	0x40086198
2000d404:	4008619c 	.word	0x4008619c
2000d408:	400861a0 	.word	0x400861a0
2000d40c:	400f6004 	.word	0x400f6004
2000d410:	400f6014 	.word	0x400f6014
2000d414:	2000f764 	.word	0x2000f764

2000d418 <w25q80bv_get_unique_id>:
{
  int i;
  uint8_t value;
  uint32_t addr;

  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d418:	2180      	movs	r1, #128	; 0x80

  return value;
}

void w25q80bv_get_unique_id(w25q80bv_unique_id_t* unique_id)
{
2000d41a:	b538      	push	{r3, r4, r5, lr}
  int i;
  uint8_t value;
  uint32_t addr;

  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d41c:	0109      	lsls	r1, r1, #4

  return value;
}

void w25q80bv_get_unique_id(w25q80bv_unique_id_t* unique_id)
{
2000d41e:	1c05      	adds	r5, r0, #0
  int i;
  uint8_t value;
  uint32_t addr;

  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d420:	4820      	ldr	r0, [pc, #128]	; (2000d4a4 <w25q80bv_get_unique_id+0x8c>)
2000d422:	f7ff fb44 	bl	2000caae <gpio_clear>

  if(device_id == W25Q80BV_DEVICE_ID_RES)
2000d426:	4b20      	ldr	r3, [pc, #128]	; (2000d4a8 <w25q80bv_get_unique_id+0x90>)
2000d428:	7818      	ldrb	r0, [r3, #0]
2000d42a:	2813      	cmp	r0, #19
2000d42c:	d119      	bne.n	2000d462 <w25q80bv_get_unique_id+0x4a>
  {
    ssp_transfer(SSP0_NUM, W25Q80BV_UNIQUE_ID);
2000d42e:	2000      	movs	r0, #0
2000d430:	214b      	movs	r1, #75	; 0x4b
2000d432:	f001 f865 	bl	2000e500 <ssp_transfer>
2000d436:	2404      	movs	r4, #4

    /* Read 4 dummy bytes */
    for(i=0; i<4; i++)
    value = ssp_transfer(SSP0_NUM, 0xFF);
2000d438:	2000      	movs	r0, #0
2000d43a:	21ff      	movs	r1, #255	; 0xff
2000d43c:	3c01      	subs	r4, #1
2000d43e:	f001 f85f 	bl	2000e500 <ssp_transfer>
  if(device_id == W25Q80BV_DEVICE_ID_RES)
  {
    ssp_transfer(SSP0_NUM, W25Q80BV_UNIQUE_ID);

    /* Read 4 dummy bytes */
    for(i=0; i<4; i++)
2000d442:	2c00      	cmp	r4, #0
2000d444:	d1f8      	bne.n	2000d438 <w25q80bv_get_unique_id+0x20>
    value = ssp_transfer(SSP0_NUM, 0xFF);

    /* Read Unique ID 64bits (8*8) */
    for(i=0; i<8; i++)
    {
      value = ssp_transfer(SSP0_NUM, 0xFF);
2000d446:	2000      	movs	r0, #0
2000d448:	21ff      	movs	r1, #255	; 0xff
2000d44a:	f001 f859 	bl	2000e500 <ssp_transfer>
2000d44e:	5528      	strb	r0, [r5, r4]
    /* Read 4 dummy bytes */
    for(i=0; i<4; i++)
    value = ssp_transfer(SSP0_NUM, 0xFF);

    /* Read Unique ID 64bits (8*8) */
    for(i=0; i<8; i++)
2000d450:	3401      	adds	r4, #1
2000d452:	2c08      	cmp	r4, #8
2000d454:	d1f7      	bne.n	2000d446 <w25q80bv_get_unique_id+0x2e>
    {
      value = ssp_transfer(SSP0_NUM, 0xFF);
      unique_id->id_8b[i]  = value;
    }
  }
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d456:	2280      	movs	r2, #128	; 0x80
2000d458:	4812      	ldr	r0, [pc, #72]	; (2000d4a4 <w25q80bv_get_unique_id+0x8c>)
2000d45a:	0111      	lsls	r1, r2, #4
2000d45c:	f7ff fb22 	bl	2000caa4 <gpio_set>
}
2000d460:	bd38      	pop	{r3, r4, r5, pc}
    for(i=0; i<8; i++)
    {
      value = ssp_transfer(SSP0_NUM, 0xFF);
      unique_id->id_8b[i]  = value;
    }
  }else if(device_id == S25FL032P_DEVICE_ID_RES)
2000d462:	2815      	cmp	r0, #21
2000d464:	d1f7      	bne.n	2000d456 <w25q80bv_get_unique_id+0x3e>
  {
    addr = S25FL032P_OTP_SN1_ADDR;
    ssp_transfer(SSP0_NUM, S25FL032P_READ_OTP);
2000d466:	214b      	movs	r1, #75	; 0x4b
2000d468:	2000      	movs	r0, #0
2000d46a:	f001 f849 	bl	2000e500 <ssp_transfer>
    ssp_transfer(SSP0_NUM, (addr & 0xFF0000) >> 16);
2000d46e:	2000      	movs	r0, #0
2000d470:	1c01      	adds	r1, r0, #0
2000d472:	f001 f845 	bl	2000e500 <ssp_transfer>
    ssp_transfer(SSP0_NUM, (addr & 0xFF00) >> 8);
2000d476:	2101      	movs	r1, #1
2000d478:	2000      	movs	r0, #0
2000d47a:	f001 f841 	bl	2000e500 <ssp_transfer>
    ssp_transfer(SSP0_NUM, addr & 0xFF);
2000d47e:	2102      	movs	r1, #2
2000d480:	2000      	movs	r0, #0
2000d482:	f001 f83d 	bl	2000e500 <ssp_transfer>
    ssp_transfer(SSP0_NUM, 0xFF); /* Dummy byte */
2000d486:	2000      	movs	r0, #0
2000d488:	21ff      	movs	r1, #255	; 0xff
2000d48a:	f001 f839 	bl	2000e500 <ssp_transfer>
    
    /* Read Unique ID 64bits (8*8) */
    for(i=0; i<8; i++)
2000d48e:	2400      	movs	r4, #0
    {
      value = ssp_transfer(SSP0_NUM, 0xFF);
2000d490:	2000      	movs	r0, #0
2000d492:	21ff      	movs	r1, #255	; 0xff
2000d494:	f001 f834 	bl	2000e500 <ssp_transfer>
2000d498:	5528      	strb	r0, [r5, r4]
    ssp_transfer(SSP0_NUM, (addr & 0xFF00) >> 8);
    ssp_transfer(SSP0_NUM, addr & 0xFF);
    ssp_transfer(SSP0_NUM, 0xFF); /* Dummy byte */
    
    /* Read Unique ID 64bits (8*8) */
    for(i=0; i<8; i++)
2000d49a:	3401      	adds	r4, #1
2000d49c:	2c08      	cmp	r4, #8
2000d49e:	d1f7      	bne.n	2000d490 <w25q80bv_get_unique_id+0x78>
2000d4a0:	e7d9      	b.n	2000d456 <w25q80bv_get_unique_id+0x3e>
2000d4a2:	46c0      	nop			; (mov r8, r8)
2000d4a4:	400f6014 	.word	0x400f6014
2000d4a8:	2000f764 	.word	0x2000f764

2000d4ac <w25q80bv_wait_while_busy>:
  }
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
}

void w25q80bv_wait_while_busy(void)
{
2000d4ac:	b508      	push	{r3, lr}
  while (w25q80bv_get_status() & W25Q80BV_STATUS_BUSY);
2000d4ae:	f7ff fef9 	bl	2000d2a4 <w25q80bv_get_status>
2000d4b2:	07c3      	lsls	r3, r0, #31
2000d4b4:	d4fb      	bmi.n	2000d4ae <w25q80bv_wait_while_busy+0x2>
}
2000d4b6:	bd08      	pop	{r3, pc}

2000d4b8 <w25q80bv_write_enable>:

void w25q80bv_write_enable(void)
{
2000d4b8:	b538      	push	{r3, r4, r5, lr}
  w25q80bv_wait_while_busy();
  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d4ba:	4d09      	ldr	r5, [pc, #36]	; (2000d4e0 <w25q80bv_write_enable+0x28>)
2000d4bc:	2480      	movs	r4, #128	; 0x80
2000d4be:	0124      	lsls	r4, r4, #4
  while (w25q80bv_get_status() & W25Q80BV_STATUS_BUSY);
}

void w25q80bv_write_enable(void)
{
  w25q80bv_wait_while_busy();
2000d4c0:	f7ff fff4 	bl	2000d4ac <w25q80bv_wait_while_busy>
  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d4c4:	1c28      	adds	r0, r5, #0
2000d4c6:	1c21      	adds	r1, r4, #0
2000d4c8:	f7ff faf1 	bl	2000caae <gpio_clear>
  ssp_transfer(SSP0_NUM, W25Q80BV_WRITE_ENABLE);
2000d4cc:	2106      	movs	r1, #6
2000d4ce:	2000      	movs	r0, #0
2000d4d0:	f001 f816 	bl	2000e500 <ssp_transfer>
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d4d4:	1c28      	adds	r0, r5, #0
2000d4d6:	1c21      	adds	r1, r4, #0
2000d4d8:	f7ff fae4 	bl	2000caa4 <gpio_set>
}
2000d4dc:	bd38      	pop	{r3, r4, r5, pc}
2000d4de:	46c0      	nop			; (mov r8, r8)
2000d4e0:	400f6014 	.word	0x400f6014

2000d4e4 <w25q80bv_sector_erase>:
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
}

/* 64KB sector erase */
void w25q80bv_sector_erase(const uint32_t addr)
{
2000d4e4:	b538      	push	{r3, r4, r5, lr}
  device_id = 0;
2000d4e6:	4d17      	ldr	r5, [pc, #92]	; (2000d544 <w25q80bv_sector_erase+0x60>)
2000d4e8:	2300      	movs	r3, #0
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
}

/* 64KB sector erase */
void w25q80bv_sector_erase(const uint32_t addr)
{
2000d4ea:	1c04      	adds	r4, r0, #0
  device_id = 0;
2000d4ec:	702b      	strb	r3, [r5, #0]
  while(1)
  {
    if(device_id == W25Q80BV_DEVICE_ID_RES)
2000d4ee:	7828      	ldrb	r0, [r5, #0]
2000d4f0:	2813      	cmp	r0, #19
2000d4f2:	d005      	beq.n	2000d500 <w25q80bv_sector_erase+0x1c>
    break;

    if(device_id == S25FL032P_DEVICE_ID_RES)
2000d4f4:	2815      	cmp	r0, #21
2000d4f6:	d003      	beq.n	2000d500 <w25q80bv_sector_erase+0x1c>
    break;

    device_id = w25q80bv_get_device_id();
2000d4f8:	f7ff feee 	bl	2000d2d8 <w25q80bv_get_device_id>
2000d4fc:	7028      	strb	r0, [r5, #0]
  }
2000d4fe:	e7f6      	b.n	2000d4ee <w25q80bv_sector_erase+0xa>

  w25q80bv_write_enable();
2000d500:	f7ff ffda 	bl	2000d4b8 <w25q80bv_write_enable>
  w25q80bv_wait_while_busy();
2000d504:	f7ff ffd2 	bl	2000d4ac <w25q80bv_wait_while_busy>
  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d508:	2180      	movs	r1, #128	; 0x80
2000d50a:	480f      	ldr	r0, [pc, #60]	; (2000d548 <w25q80bv_sector_erase+0x64>)
2000d50c:	0109      	lsls	r1, r1, #4
2000d50e:	f7ff face 	bl	2000caae <gpio_clear>
  ssp_transfer(SSP0_NUM, W25Q80BV_SECTOR_ERASE);
2000d512:	21d8      	movs	r1, #216	; 0xd8
2000d514:	2000      	movs	r0, #0
2000d516:	f000 fff3 	bl	2000e500 <ssp_transfer>
  ssp_transfer(SSP0_NUM, (addr & 0xFF0000) >> 16);
2000d51a:	0222      	lsls	r2, r4, #8
2000d51c:	0e11      	lsrs	r1, r2, #24
  ssp_transfer(SSP0_NUM, (addr & 0xFF00) >> 8);
2000d51e:	0425      	lsls	r5, r4, #16

  w25q80bv_write_enable();
  w25q80bv_wait_while_busy();
  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
  ssp_transfer(SSP0_NUM, W25Q80BV_SECTOR_ERASE);
  ssp_transfer(SSP0_NUM, (addr & 0xFF0000) >> 16);
2000d520:	2000      	movs	r0, #0
2000d522:	f000 ffed 	bl	2000e500 <ssp_transfer>
  ssp_transfer(SSP0_NUM, (addr & 0xFF00) >> 8);
2000d526:	0e29      	lsrs	r1, r5, #24
2000d528:	2000      	movs	r0, #0
2000d52a:	f000 ffe9 	bl	2000e500 <ssp_transfer>
  ssp_transfer(SSP0_NUM, addr & 0xFF);
2000d52e:	b2e1      	uxtb	r1, r4
2000d530:	2000      	movs	r0, #0
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d532:	2480      	movs	r4, #128	; 0x80
  w25q80bv_wait_while_busy();
  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
  ssp_transfer(SSP0_NUM, W25Q80BV_SECTOR_ERASE);
  ssp_transfer(SSP0_NUM, (addr & 0xFF0000) >> 16);
  ssp_transfer(SSP0_NUM, (addr & 0xFF00) >> 8);
  ssp_transfer(SSP0_NUM, addr & 0xFF);
2000d534:	f000 ffe4 	bl	2000e500 <ssp_transfer>
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d538:	4803      	ldr	r0, [pc, #12]	; (2000d548 <w25q80bv_sector_erase+0x64>)
2000d53a:	0121      	lsls	r1, r4, #4
2000d53c:	f7ff fab2 	bl	2000caa4 <gpio_set>
}
2000d540:	bd38      	pop	{r3, r4, r5, pc}
2000d542:	46c0      	nop			; (mov r8, r8)
2000d544:	2000f764 	.word	0x2000f764
2000d548:	400f6014 	.word	0x400f6014

2000d54c <w25q80bv_page_program>:

/* write up to 256 byte page or partial page */
void w25q80bv_page_program(const uint32_t addr, const uint16_t len, const uint8_t* data)
{
2000d54c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int i;

  /* do nothing if asked to write beyond a page boundary */
  if (((addr & 0xFF) + len) > W25Q80BV_PAGE_LEN)
2000d54e:	b2c7      	uxtb	r7, r0
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
}

/* write up to 256 byte page or partial page */
void w25q80bv_page_program(const uint32_t addr, const uint16_t len, const uint8_t* data)
{
2000d550:	1c16      	adds	r6, r2, #0
  int i;

  /* do nothing if asked to write beyond a page boundary */
  if (((addr & 0xFF) + len) > W25Q80BV_PAGE_LEN)
2000d552:	2380      	movs	r3, #128	; 0x80
2000d554:	19ca      	adds	r2, r1, r7
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
}

/* write up to 256 byte page or partial page */
void w25q80bv_page_program(const uint32_t addr, const uint16_t len, const uint8_t* data)
{
2000d556:	1c04      	adds	r4, r0, #0
2000d558:	1c0d      	adds	r5, r1, #0
  int i;

  /* do nothing if asked to write beyond a page boundary */
  if (((addr & 0xFF) + len) > W25Q80BV_PAGE_LEN)
2000d55a:	0058      	lsls	r0, r3, #1
2000d55c:	4282      	cmp	r2, r0
2000d55e:	d82e      	bhi.n	2000d5be <w25q80bv_page_program+0x72>
  return;

  /* do nothing if we would overflow the flash */
  if (addr > (W25Q80BV_NUM_BYTES - len))
2000d560:	2180      	movs	r1, #128	; 0x80
2000d562:	034a      	lsls	r2, r1, #13
2000d564:	1b53      	subs	r3, r2, r5
2000d566:	429c      	cmp	r4, r3
2000d568:	d829      	bhi.n	2000d5be <w25q80bv_page_program+0x72>
  return;

  w25q80bv_write_enable();
2000d56a:	f7ff ffa5 	bl	2000d4b8 <w25q80bv_write_enable>
  w25q80bv_wait_while_busy();
2000d56e:	f7ff ff9d 	bl	2000d4ac <w25q80bv_wait_while_busy>

  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d572:	2180      	movs	r1, #128	; 0x80
2000d574:	4812      	ldr	r0, [pc, #72]	; (2000d5c0 <w25q80bv_page_program+0x74>)
2000d576:	0109      	lsls	r1, r1, #4
2000d578:	f7ff fa99 	bl	2000caae <gpio_clear>
  ssp_transfer(SSP0_NUM, W25Q80BV_PAGE_PROGRAM);
2000d57c:	2102      	movs	r1, #2
2000d57e:	2000      	movs	r0, #0
2000d580:	f000 ffbe 	bl	2000e500 <ssp_transfer>
  ssp_transfer(SSP0_NUM, (addr & 0xFF0000) >> 16);
2000d584:	0220      	lsls	r0, r4, #8
2000d586:	0e01      	lsrs	r1, r0, #24
  ssp_transfer(SSP0_NUM, (addr & 0xFF00) >> 8);
2000d588:	0424      	lsls	r4, r4, #16
  w25q80bv_write_enable();
  w25q80bv_wait_while_busy();

  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
  ssp_transfer(SSP0_NUM, W25Q80BV_PAGE_PROGRAM);
  ssp_transfer(SSP0_NUM, (addr & 0xFF0000) >> 16);
2000d58a:	2000      	movs	r0, #0
2000d58c:	f000 ffb8 	bl	2000e500 <ssp_transfer>
  ssp_transfer(SSP0_NUM, (addr & 0xFF00) >> 8);
2000d590:	0e21      	lsrs	r1, r4, #24
2000d592:	2000      	movs	r0, #0
2000d594:	f000 ffb4 	bl	2000e500 <ssp_transfer>
  ssp_transfer(SSP0_NUM, addr & 0xFF);
2000d598:	b2b9      	uxth	r1, r7
2000d59a:	2000      	movs	r0, #0
2000d59c:	f000 ffb0 	bl	2000e500 <ssp_transfer>
  for (i = 0; i < len; i++)
2000d5a0:	1c34      	adds	r4, r6, #0
  ssp_transfer(SSP0_NUM, addr & 0xFF);
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
}

/* write up to 256 byte page or partial page */
void w25q80bv_page_program(const uint32_t addr, const uint16_t len, const uint8_t* data)
2000d5a2:	1ba7      	subs	r7, r4, r6
  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
  ssp_transfer(SSP0_NUM, W25Q80BV_PAGE_PROGRAM);
  ssp_transfer(SSP0_NUM, (addr & 0xFF0000) >> 16);
  ssp_transfer(SSP0_NUM, (addr & 0xFF00) >> 8);
  ssp_transfer(SSP0_NUM, addr & 0xFF);
  for (i = 0; i < len; i++)
2000d5a4:	42af      	cmp	r7, r5
2000d5a6:	da05      	bge.n	2000d5b4 <w25q80bv_page_program+0x68>
  ssp_transfer(SSP0_NUM, data[i]);
2000d5a8:	7821      	ldrb	r1, [r4, #0]
2000d5aa:	2000      	movs	r0, #0
2000d5ac:	f000 ffa8 	bl	2000e500 <ssp_transfer>
2000d5b0:	3401      	adds	r4, #1
2000d5b2:	e7f6      	b.n	2000d5a2 <w25q80bv_page_program+0x56>

  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d5b4:	2580      	movs	r5, #128	; 0x80
2000d5b6:	4802      	ldr	r0, [pc, #8]	; (2000d5c0 <w25q80bv_page_program+0x74>)
2000d5b8:	0129      	lsls	r1, r5, #4
2000d5ba:	f7ff fa73 	bl	2000caa4 <gpio_set>
}
2000d5be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2000d5c0:	400f6014 	.word	0x400f6014

2000d5c4 <w25q80bv_program>:

/* write an arbitrary number of bytes */
void w25q80bv_program(uint32_t addr, uint32_t len, const uint8_t* data)
{
2000d5c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000d5c6:	1c04      	adds	r4, r0, #0
2000d5c8:	1c0d      	adds	r5, r1, #0
2000d5ca:	1c17      	adds	r7, r2, #0
    break;

    if(device_id == S25FL032P_DEVICE_ID_RES)
    break;

    device_id = w25q80bv_get_device_id();
2000d5cc:	f7ff fe84 	bl	2000d2d8 <w25q80bv_get_device_id>
  uint8_t device_id;

  device_id = 0;
  while(1)
  {
    if(device_id == W25Q80BV_DEVICE_ID_RES)
2000d5d0:	2813      	cmp	r0, #19
2000d5d2:	d001      	beq.n	2000d5d8 <w25q80bv_program+0x14>
    break;

    if(device_id == S25FL032P_DEVICE_ID_RES)
2000d5d4:	2815      	cmp	r0, #21
2000d5d6:	d1f9      	bne.n	2000d5cc <w25q80bv_program+0x8>

    device_id = w25q80bv_get_device_id();
  }
  
  /* do nothing if we would overflow the flash */
  if ((len > W25Q80BV_NUM_BYTES) || (addr > W25Q80BV_NUM_BYTES)
2000d5d8:	2380      	movs	r3, #128	; 0x80
2000d5da:	0358      	lsls	r0, r3, #13
2000d5dc:	4285      	cmp	r5, r0
2000d5de:	d82f      	bhi.n	2000d640 <w25q80bv_program+0x7c>
2000d5e0:	4284      	cmp	r4, r0
2000d5e2:	d82d      	bhi.n	2000d640 <w25q80bv_program+0x7c>
      || ((addr + len) > W25Q80BV_NUM_BYTES))
2000d5e4:	192a      	adds	r2, r5, r4
2000d5e6:	4282      	cmp	r2, r0
2000d5e8:	d82a      	bhi.n	2000d640 <w25q80bv_program+0x7c>
  return;

  /* handle start not at page boundary */
  first_block_len = W25Q80BV_PAGE_LEN - (addr % W25Q80BV_PAGE_LEN);
2000d5ea:	2680      	movs	r6, #128	; 0x80
2000d5ec:	0073      	lsls	r3, r6, #1
2000d5ee:	b2e1      	uxtb	r1, r4
2000d5f0:	1a58      	subs	r0, r3, r1
2000d5f2:	b286      	uxth	r6, r0
  if (len < first_block_len)
2000d5f4:	42b5      	cmp	r5, r6
2000d5f6:	d202      	bcs.n	2000d5fe <w25q80bv_program+0x3a>
  first_block_len = len;
2000d5f8:	b2ae      	uxth	r6, r5
  if (first_block_len) {
2000d5fa:	2e00      	cmp	r6, #0
2000d5fc:	d007      	beq.n	2000d60e <w25q80bv_program+0x4a>
    w25q80bv_page_program(addr, first_block_len, data);
2000d5fe:	1c20      	adds	r0, r4, #0
2000d600:	1c3a      	adds	r2, r7, #0
2000d602:	1c31      	adds	r1, r6, #0
2000d604:	f7ff ffa2 	bl	2000d54c <w25q80bv_page_program>
    addr += first_block_len;
2000d608:	19a4      	adds	r4, r4, r6
    data += first_block_len;
2000d60a:	19bf      	adds	r7, r7, r6
    len -= first_block_len;
2000d60c:	1bad      	subs	r5, r5, r6
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
}

/* write an arbitrary number of bytes */
void w25q80bv_program(uint32_t addr, uint32_t len, const uint8_t* data)
{
2000d60e:	1c26      	adds	r6, r4, #0

  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
}

/* write an arbitrary number of bytes */
void w25q80bv_program(uint32_t addr, uint32_t len, const uint8_t* data)
2000d610:	1b3a      	subs	r2, r7, r4
2000d612:	1961      	adds	r1, r4, r5
2000d614:	1992      	adds	r2, r2, r6
    data += first_block_len;
    len -= first_block_len;
  }

  /* one page at a time on boundaries */
  while (len >= W25Q80BV_PAGE_LEN) {
2000d616:	1b8b      	subs	r3, r1, r6
2000d618:	2bff      	cmp	r3, #255	; 0xff
2000d61a:	d907      	bls.n	2000d62c <w25q80bv_program+0x68>
    w25q80bv_page_program(addr, W25Q80BV_PAGE_LEN, data);
2000d61c:	2180      	movs	r1, #128	; 0x80
2000d61e:	1c30      	adds	r0, r6, #0
2000d620:	0049      	lsls	r1, r1, #1
    addr += W25Q80BV_PAGE_LEN;
2000d622:	3601      	adds	r6, #1
    len -= first_block_len;
  }

  /* one page at a time on boundaries */
  while (len >= W25Q80BV_PAGE_LEN) {
    w25q80bv_page_program(addr, W25Q80BV_PAGE_LEN, data);
2000d624:	f7ff ff92 	bl	2000d54c <w25q80bv_page_program>
    addr += W25Q80BV_PAGE_LEN;
2000d628:	36ff      	adds	r6, #255	; 0xff
2000d62a:	e7f1      	b.n	2000d610 <w25q80bv_program+0x4c>

  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
}

/* write an arbitrary number of bytes */
void w25q80bv_program(uint32_t addr, uint32_t len, const uint8_t* data)
2000d62c:	0a28      	lsrs	r0, r5, #8
2000d62e:	0206      	lsls	r6, r0, #8
2000d630:	b2ed      	uxtb	r5, r5
2000d632:	1930      	adds	r0, r6, r4
2000d634:	19ba      	adds	r2, r7, r6
    data += W25Q80BV_PAGE_LEN;
    len -= W25Q80BV_PAGE_LEN;
  }

  /* handle end not at page boundary */
  if (len) {
2000d636:	2d00      	cmp	r5, #0
2000d638:	d002      	beq.n	2000d640 <w25q80bv_program+0x7c>
    w25q80bv_page_program(addr, len, data);
2000d63a:	b2a9      	uxth	r1, r5
2000d63c:	f7ff ff86 	bl	2000d54c <w25q80bv_page_program>
  }
}
2000d640:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

2000d644 <w25q80bv_read>:

/* read data */
void w25q80bv_read(uint32_t addr, uint32_t len, uint8_t* const data)
{
2000d644:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t i;

  /* do nothing if we would overflow the flash */
  if ((len > W25Q80BV_NUM_BYTES) || (addr > W25Q80BV_NUM_BYTES)
2000d646:	2380      	movs	r3, #128	; 0x80
  }
}

/* read data */
void w25q80bv_read(uint32_t addr, uint32_t len, uint8_t* const data)
{
2000d648:	1c05      	adds	r5, r0, #0
2000d64a:	1c0e      	adds	r6, r1, #0
2000d64c:	1c14      	adds	r4, r2, #0
  uint32_t i;

  /* do nothing if we would overflow the flash */
  if ((len > W25Q80BV_NUM_BYTES) || (addr > W25Q80BV_NUM_BYTES)
2000d64e:	0358      	lsls	r0, r3, #13
2000d650:	4281      	cmp	r1, r0
2000d652:	d831      	bhi.n	2000d6b8 <w25q80bv_read+0x74>
2000d654:	4285      	cmp	r5, r0
2000d656:	d82f      	bhi.n	2000d6b8 <w25q80bv_read+0x74>
      || ((addr + len) > W25Q80BV_NUM_BYTES))
2000d658:	194a      	adds	r2, r1, r5
2000d65a:	4282      	cmp	r2, r0
2000d65c:	d82c      	bhi.n	2000d6b8 <w25q80bv_read+0x74>
    return;

  w25q80bv_wait_while_busy();
2000d65e:	f7ff ff25 	bl	2000d4ac <w25q80bv_wait_while_busy>

  gpio_clear(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d662:	2180      	movs	r1, #128	; 0x80
2000d664:	4815      	ldr	r0, [pc, #84]	; (2000d6bc <w25q80bv_read+0x78>)
2000d666:	0109      	lsls	r1, r1, #4
2000d668:	f7ff fa21 	bl	2000caae <gpio_clear>
  ssp_transfer(SSP0_NUM, W25Q80BV_FAST_READ);
2000d66c:	210b      	movs	r1, #11
2000d66e:	2000      	movs	r0, #0
2000d670:	f000 ff46 	bl	2000e500 <ssp_transfer>
  ssp_transfer(SSP0_NUM, (addr >> 16) & 0xFF);
2000d674:	0c29      	lsrs	r1, r5, #16
2000d676:	2000      	movs	r0, #0
2000d678:	f000 ff42 	bl	2000e500 <ssp_transfer>
  ssp_transfer(SSP0_NUM, (addr >>  8) & 0xFF);
2000d67c:	27ff      	movs	r7, #255	; 0xff
2000d67e:	0a29      	lsrs	r1, r5, #8
2000d680:	4039      	ands	r1, r7
2000d682:	2000      	movs	r0, #0
2000d684:	f000 ff3c 	bl	2000e500 <ssp_transfer>
  ssp_transfer(SSP0_NUM, (addr >>  0) & 0xFF);
2000d688:	1c29      	adds	r1, r5, #0
2000d68a:	4039      	ands	r1, r7
2000d68c:	2000      	movs	r0, #0
2000d68e:	f000 ff37 	bl	2000e500 <ssp_transfer>
  ssp_transfer(SSP0_NUM, 0xFF); // Dummy byte
2000d692:	2000      	movs	r0, #0
2000d694:	1c39      	adds	r1, r7, #0
2000d696:	f000 ff33 	bl	2000e500 <ssp_transfer>
    w25q80bv_page_program(addr, len, data);
  }
}

/* read data */
void w25q80bv_read(uint32_t addr, uint32_t len, uint8_t* const data)
2000d69a:	19a5      	adds	r5, r4, r6
  ssp_transfer(SSP0_NUM, W25Q80BV_FAST_READ);
  ssp_transfer(SSP0_NUM, (addr >> 16) & 0xFF);
  ssp_transfer(SSP0_NUM, (addr >>  8) & 0xFF);
  ssp_transfer(SSP0_NUM, (addr >>  0) & 0xFF);
  ssp_transfer(SSP0_NUM, 0xFF); // Dummy byte
  for (i = 0; i < len; i++)
2000d69c:	42ac      	cmp	r4, r5
2000d69e:	d006      	beq.n	2000d6ae <w25q80bv_read+0x6a>
    data[i] = ssp_transfer(SSP0_NUM, 0xFF);
2000d6a0:	2000      	movs	r0, #0
2000d6a2:	21ff      	movs	r1, #255	; 0xff
2000d6a4:	f000 ff2c 	bl	2000e500 <ssp_transfer>
2000d6a8:	7020      	strb	r0, [r4, #0]
2000d6aa:	3401      	adds	r4, #1
2000d6ac:	e7f6      	b.n	2000d69c <w25q80bv_read+0x58>
  gpio_set(PORT_SSP0_SSEL, PIN_SSP0_SSEL);
2000d6ae:	2480      	movs	r4, #128	; 0x80
2000d6b0:	4802      	ldr	r0, [pc, #8]	; (2000d6bc <w25q80bv_read+0x78>)
2000d6b2:	0121      	lsls	r1, r4, #4
2000d6b4:	f7ff f9f6 	bl	2000caa4 <gpio_set>
}
2000d6b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2000d6ba:	46c0      	nop			; (mov r8, r8)
2000d6bc:	400f6014 	.word	0x400f6014

2000d6c0 <iap_is_implemented>:
'0' on flashless parts. */

bool iap_is_implemented(void)
{
  bool res;
  if( *((uint32_t*)ROM_IAP_ADDR) != ROM_IAP_UNDEF_ADDR )
2000d6c0:	4b03      	ldr	r3, [pc, #12]	; (2000d6d0 <iap_is_implemented+0x10>)
2000d6c2:	4904      	ldr	r1, [pc, #16]	; (2000d6d4 <iap_is_implemented+0x14>)
2000d6c4:	6818      	ldr	r0, [r3, #0]
2000d6c6:	1840      	adds	r0, r0, r1
    res = true;
  }else
  {
    res = false;
  }
  return res;
2000d6c8:	1e43      	subs	r3, r0, #1
2000d6ca:	4198      	sbcs	r0, r3
}
2000d6cc:	4770      	bx	lr
2000d6ce:	46c0      	nop			; (mov r8, r8)
2000d6d0:	10400100 	.word	0x10400100
2000d6d4:	edcba988 	.word	0xedcba988

2000d6d8 <iap_cmd_call>:

isp_iap_ret_code_t iap_cmd_call(iap_cmd_res_t* iap_cmd_res) 
{
2000d6d8:	b538      	push	{r3, r4, r5, lr}
2000d6da:	1c04      	adds	r4, r0, #0
  uint32_t* p_u32_data;
  
  if( iap_is_implemented() )
2000d6dc:	f7ff fff0 	bl	2000d6c0 <iap_is_implemented>
2000d6e0:	1e05      	subs	r5, r0, #0
2000d6e2:	d006      	beq.n	2000d6f2 <iap_cmd_call+0x1a>
  {
    pROM_API->IAP( (uint32_t*)&iap_cmd_res->cmd_param, (uint32_t*)&iap_cmd_res->status_res);
2000d6e4:	4d10      	ldr	r5, [pc, #64]	; (2000d728 <iap_cmd_call+0x50>)
2000d6e6:	1c21      	adds	r1, r4, #0
2000d6e8:	3118      	adds	r1, #24
2000d6ea:	682a      	ldr	r2, [r5, #0]
2000d6ec:	1c20      	adds	r0, r4, #0
2000d6ee:	4790      	blx	r2
2000d6f0:	e018      	b.n	2000d724 <iap_cmd_call+0x4c>
  {
    /* 
      Alternative way to retrieve Part Id on MCU with no IAP 
      Read Serial No => Read Unique ID in SPIFI (only compatible with W25Q80BV)
    */
    w25q80bv_setup();
2000d6f2:	f7ff fe17 	bl	2000d324 <w25q80bv_setup>

    switch(iap_cmd_res->cmd_param.command_code)
2000d6f6:	7823      	ldrb	r3, [r4, #0]
2000d6f8:	2b36      	cmp	r3, #54	; 0x36
2000d6fa:	d008      	beq.n	2000d70e <iap_cmd_call+0x36>
2000d6fc:	2b3a      	cmp	r3, #58	; 0x3a
2000d6fe:	d10e      	bne.n	2000d71e <iap_cmd_call+0x46>
      
      case IAP_CMD_READ_SERIAL_NO:
        /* Only 64bits used */
        iap_cmd_res->status_res.iap_result[0] = 0;
        iap_cmd_res->status_res.iap_result[1] = 0;
        w25q80bv_get_unique_id( (w25q80bv_unique_id_t*)&iap_cmd_res->status_res.iap_result[2] );
2000d700:	1c20      	adds	r0, r4, #0
        iap_cmd_res->status_res.status_ret = CMD_SUCCESS;
      break;
      
      case IAP_CMD_READ_SERIAL_NO:
        /* Only 64bits used */
        iap_cmd_res->status_res.iap_result[0] = 0;
2000d702:	61e5      	str	r5, [r4, #28]
        iap_cmd_res->status_res.iap_result[1] = 0;
2000d704:	6225      	str	r5, [r4, #32]
        w25q80bv_get_unique_id( (w25q80bv_unique_id_t*)&iap_cmd_res->status_res.iap_result[2] );
2000d706:	3024      	adds	r0, #36	; 0x24
2000d708:	f7ff fe86 	bl	2000d418 <w25q80bv_get_unique_id>
2000d70c:	e005      	b.n	2000d71a <iap_cmd_call+0x42>

    switch(iap_cmd_res->cmd_param.command_code)
    {
      case IAP_CMD_READ_PART_ID_NO:
        p_u32_data = (uint32_t*)CHIP_PART_ID;
        iap_cmd_res->status_res.iap_result[0] = p_u32_data[0];
2000d70e:	4a07      	ldr	r2, [pc, #28]	; (2000d72c <iap_cmd_call+0x54>)
        p_u32_data = (uint32_t*)ROM_OTP_PART_ID_ADDR;
        iap_cmd_res->status_res.iap_result[1] = p_u32_data[0];
2000d710:	4807      	ldr	r0, [pc, #28]	; (2000d730 <iap_cmd_call+0x58>)

    switch(iap_cmd_res->cmd_param.command_code)
    {
      case IAP_CMD_READ_PART_ID_NO:
        p_u32_data = (uint32_t*)CHIP_PART_ID;
        iap_cmd_res->status_res.iap_result[0] = p_u32_data[0];
2000d712:	6813      	ldr	r3, [r2, #0]
2000d714:	61e3      	str	r3, [r4, #28]
        p_u32_data = (uint32_t*)ROM_OTP_PART_ID_ADDR;
        iap_cmd_res->status_res.iap_result[1] = p_u32_data[0];
2000d716:	6801      	ldr	r1, [r0, #0]
2000d718:	6221      	str	r1, [r4, #32]
      case IAP_CMD_READ_SERIAL_NO:
        /* Only 64bits used */
        iap_cmd_res->status_res.iap_result[0] = 0;
        iap_cmd_res->status_res.iap_result[1] = 0;
        w25q80bv_get_unique_id( (w25q80bv_unique_id_t*)&iap_cmd_res->status_res.iap_result[2] );
        iap_cmd_res->status_res.status_ret = CMD_SUCCESS;
2000d71a:	8325      	strh	r5, [r4, #24]
      break;
2000d71c:	e002      	b.n	2000d724 <iap_cmd_call+0x4c>
      
      default:
        iap_cmd_res->status_res.status_ret = ERROR_IAP_NOT_IMPLEMENTED;
2000d71e:	2080      	movs	r0, #128	; 0x80
2000d720:	0041      	lsls	r1, r0, #1
2000d722:	8321      	strh	r1, [r4, #24]
      break;
    }
  }
  return iap_cmd_res->status_res.status_ret;
2000d724:	8b20      	ldrh	r0, [r4, #24]
}
2000d726:	bd38      	pop	{r3, r4, r5, pc}
2000d728:	10400100 	.word	0x10400100
2000d72c:	40043200 	.word	0x40043200
2000d730:	40045000 	.word	0x40045000

2000d734 <usb_clear_pending_interrupts>:
  CREG_CREG0 &= ~CREG_CREG0_USB0PHY;
}

static void usb_clear_pending_interrupts(const uint32_t mask)
{
  USB0_ENDPTNAK = mask;
2000d734:	4b07      	ldr	r3, [pc, #28]	; (2000d754 <usb_clear_pending_interrupts+0x20>)
  USB0_ENDPTNAKEN = mask;
2000d736:	4908      	ldr	r1, [pc, #32]	; (2000d758 <usb_clear_pending_interrupts+0x24>)
  USB0_USBSTS_D = mask;
2000d738:	4a08      	ldr	r2, [pc, #32]	; (2000d75c <usb_clear_pending_interrupts+0x28>)
  CREG_CREG0 &= ~CREG_CREG0_USB0PHY;
}

static void usb_clear_pending_interrupts(const uint32_t mask)
{
  USB0_ENDPTNAK = mask;
2000d73a:	6018      	str	r0, [r3, #0]
  USB0_ENDPTNAKEN = mask;
  USB0_USBSTS_D = mask;
  USB0_ENDPTSETUPSTAT = USB0_ENDPTSETUPSTAT & mask;
2000d73c:	4b08      	ldr	r3, [pc, #32]	; (2000d760 <usb_clear_pending_interrupts+0x2c>)
}

static void usb_clear_pending_interrupts(const uint32_t mask)
{
  USB0_ENDPTNAK = mask;
  USB0_ENDPTNAKEN = mask;
2000d73e:	6008      	str	r0, [r1, #0]
  USB0_USBSTS_D = mask;
2000d740:	6010      	str	r0, [r2, #0]
  USB0_ENDPTSETUPSTAT = USB0_ENDPTSETUPSTAT & mask;
2000d742:	6819      	ldr	r1, [r3, #0]
2000d744:	4001      	ands	r1, r0
2000d746:	6019      	str	r1, [r3, #0]
  USB0_ENDPTCOMPLETE = USB0_ENDPTCOMPLETE & mask;
2000d748:	4b06      	ldr	r3, [pc, #24]	; (2000d764 <usb_clear_pending_interrupts+0x30>)
2000d74a:	681a      	ldr	r2, [r3, #0]
2000d74c:	4010      	ands	r0, r2
2000d74e:	6018      	str	r0, [r3, #0]
}
2000d750:	4770      	bx	lr
2000d752:	46c0      	nop			; (mov r8, r8)
2000d754:	40006178 	.word	0x40006178
2000d758:	4000617c 	.word	0x4000617c
2000d75c:	40006144 	.word	0x40006144
2000d760:	400061ac 	.word	0x400061ac
2000d764:	400061bc 	.word	0x400061bc

2000d768 <usb_flush_primed_endpoints>:

static void usb_wait_for_endpoint_priming_to_finish(const uint32_t mask)
{
  // Wait until controller has parsed new transfer descriptors and prepared
  // receive buffers.
  while( USB0_ENDPTPRIME & mask );
2000d768:	4b04      	ldr	r3, [pc, #16]	; (2000d77c <usb_flush_primed_endpoints+0x14>)
2000d76a:	6819      	ldr	r1, [r3, #0]
2000d76c:	4201      	tst	r1, r0
2000d76e:	d1fb      	bne.n	2000d768 <usb_flush_primed_endpoints>

static void usb_flush_endpoints(const uint32_t mask)
{
  // Clear any primed buffers. If a packet is in progress, that transfer
  // will continue until completion.
  USB0_ENDPTFLUSH = mask;
2000d770:	4b03      	ldr	r3, [pc, #12]	; (2000d780 <usb_flush_primed_endpoints+0x18>)
2000d772:	6018      	str	r0, [r3, #0]

static void usb_wait_for_endpoint_flushing_to_finish(const uint32_t mask)
{
  // Wait until controller has flushed all endpoints / cleared any primed
  // buffers.
  while( USB0_ENDPTFLUSH & mask );
2000d774:	681a      	ldr	r2, [r3, #0]
2000d776:	4202      	tst	r2, r0
2000d778:	d1fc      	bne.n	2000d774 <usb_flush_primed_endpoints+0xc>
static void usb_flush_primed_endpoints(const uint32_t mask)
{
  usb_wait_for_endpoint_priming_to_finish(mask);
  usb_flush_endpoints(mask);
  usb_wait_for_endpoint_flushing_to_finish(mask);
}
2000d77a:	4770      	bx	lr
2000d77c:	400061b0 	.word	0x400061b0
2000d780:	400061b4 	.word	0x400061b4

2000d784 <usb_disable_all_endpoints>:
}

static void usb_disable_all_endpoints(void)
{
  // Endpoint 0 is always enabled. TODO: So why set ENDPTCTRL0?
  USB0_ENDPTCTRL0 &= ~(USB0_ENDPTCTRL0_RXE | USB0_ENDPTCTRL0_TXE);
2000d784:	4a0c      	ldr	r2, [pc, #48]	; (2000d7b8 <usb_disable_all_endpoints+0x34>)
2000d786:	4b0d      	ldr	r3, [pc, #52]	; (2000d7bc <usb_disable_all_endpoints+0x38>)
2000d788:	6811      	ldr	r1, [r2, #0]
  USB0_ENDPTCTRL1 &= ~(USB0_ENDPTCTRL1_RXE | USB0_ENDPTCTRL1_TXE);
2000d78a:	480d      	ldr	r0, [pc, #52]	; (2000d7c0 <usb_disable_all_endpoints+0x3c>)
}

static void usb_disable_all_endpoints(void)
{
  // Endpoint 0 is always enabled. TODO: So why set ENDPTCTRL0?
  USB0_ENDPTCTRL0 &= ~(USB0_ENDPTCTRL0_RXE | USB0_ENDPTCTRL0_TXE);
2000d78c:	4019      	ands	r1, r3
2000d78e:	6011      	str	r1, [r2, #0]
  USB0_ENDPTCTRL1 &= ~(USB0_ENDPTCTRL1_RXE | USB0_ENDPTCTRL1_TXE);
2000d790:	6802      	ldr	r2, [r0, #0]
2000d792:	401a      	ands	r2, r3
2000d794:	6002      	str	r2, [r0, #0]
  USB0_ENDPTCTRL2 &= ~(USB0_ENDPTCTRL2_RXE | USB0_ENDPTCTRL2_TXE);
2000d796:	480b      	ldr	r0, [pc, #44]	; (2000d7c4 <usb_disable_all_endpoints+0x40>)
  USB0_ENDPTCTRL3 &= ~(USB0_ENDPTCTRL3_RXE | USB0_ENDPTCTRL3_TXE);
2000d798:	4a0b      	ldr	r2, [pc, #44]	; (2000d7c8 <usb_disable_all_endpoints+0x44>)
static void usb_disable_all_endpoints(void)
{
  // Endpoint 0 is always enabled. TODO: So why set ENDPTCTRL0?
  USB0_ENDPTCTRL0 &= ~(USB0_ENDPTCTRL0_RXE | USB0_ENDPTCTRL0_TXE);
  USB0_ENDPTCTRL1 &= ~(USB0_ENDPTCTRL1_RXE | USB0_ENDPTCTRL1_TXE);
  USB0_ENDPTCTRL2 &= ~(USB0_ENDPTCTRL2_RXE | USB0_ENDPTCTRL2_TXE);
2000d79a:	6801      	ldr	r1, [r0, #0]
2000d79c:	4019      	ands	r1, r3
2000d79e:	6001      	str	r1, [r0, #0]
  USB0_ENDPTCTRL3 &= ~(USB0_ENDPTCTRL3_RXE | USB0_ENDPTCTRL3_TXE);
2000d7a0:	6810      	ldr	r0, [r2, #0]
2000d7a2:	4018      	ands	r0, r3
2000d7a4:	6010      	str	r0, [r2, #0]
  USB0_ENDPTCTRL4 &= ~(USB0_ENDPTCTRL4_RXE | USB0_ENDPTCTRL4_TXE);
2000d7a6:	4a09      	ldr	r2, [pc, #36]	; (2000d7cc <usb_disable_all_endpoints+0x48>)
  USB0_ENDPTCTRL5 &= ~(USB0_ENDPTCTRL5_RXE | USB0_ENDPTCTRL5_TXE);
2000d7a8:	4809      	ldr	r0, [pc, #36]	; (2000d7d0 <usb_disable_all_endpoints+0x4c>)
  // Endpoint 0 is always enabled. TODO: So why set ENDPTCTRL0?
  USB0_ENDPTCTRL0 &= ~(USB0_ENDPTCTRL0_RXE | USB0_ENDPTCTRL0_TXE);
  USB0_ENDPTCTRL1 &= ~(USB0_ENDPTCTRL1_RXE | USB0_ENDPTCTRL1_TXE);
  USB0_ENDPTCTRL2 &= ~(USB0_ENDPTCTRL2_RXE | USB0_ENDPTCTRL2_TXE);
  USB0_ENDPTCTRL3 &= ~(USB0_ENDPTCTRL3_RXE | USB0_ENDPTCTRL3_TXE);
  USB0_ENDPTCTRL4 &= ~(USB0_ENDPTCTRL4_RXE | USB0_ENDPTCTRL4_TXE);
2000d7aa:	6811      	ldr	r1, [r2, #0]
2000d7ac:	4019      	ands	r1, r3
2000d7ae:	6011      	str	r1, [r2, #0]
  USB0_ENDPTCTRL5 &= ~(USB0_ENDPTCTRL5_RXE | USB0_ENDPTCTRL5_TXE);
2000d7b0:	6802      	ldr	r2, [r0, #0]
2000d7b2:	4013      	ands	r3, r2
2000d7b4:	6003      	str	r3, [r0, #0]
}
2000d7b6:	4770      	bx	lr
2000d7b8:	400061c0 	.word	0x400061c0
2000d7bc:	ff7fff7f 	.word	0xff7fff7f
2000d7c0:	400061c4 	.word	0x400061c4
2000d7c4:	400061c8 	.word	0x400061c8
2000d7c8:	400061cc 	.word	0x400061cc
2000d7cc:	400061d0 	.word	0x400061d0
2000d7d0:	400061d4 	.word	0x400061d4

2000d7d4 <usb_queue_head>:

#define USB_QH_INDEX(endpoint_address) (((endpoint_address & 0xF) * 2) + ((endpoint_address >> 7) & 1))

usb_queue_head_t* usb_queue_head(const uint_fast8_t endpoint_address)
{
  return &usb_qh[USB_QH_INDEX(endpoint_address)];
2000d7d4:	220f      	movs	r2, #15
2000d7d6:	0603      	lsls	r3, r0, #24
2000d7d8:	4010      	ands	r0, r2
2000d7da:	0fd9      	lsrs	r1, r3, #31
2000d7dc:	0040      	lsls	r0, r0, #1
2000d7de:	180b      	adds	r3, r1, r0
2000d7e0:	4a01      	ldr	r2, [pc, #4]	; (2000d7e8 <usb_queue_head+0x14>)
2000d7e2:	0199      	lsls	r1, r3, #6
2000d7e4:	1888      	adds	r0, r1, r2
}
2000d7e6:	4770      	bx	lr
2000d7e8:	2000f800 	.word	0x2000f800

2000d7ec <usb_peripheral_reset>:
  return (endpoint_address & 0xF);
}

void usb_peripheral_reset(void)
{
  RESET_CTRL0 = RESET_CTRL0_USB0_RST;
2000d7ec:	4a05      	ldr	r2, [pc, #20]	; (2000d804 <usb_peripheral_reset+0x18>)
2000d7ee:	2380      	movs	r3, #128	; 0x80
2000d7f0:	0298      	lsls	r0, r3, #10
  RESET_CTRL0 = 0;
2000d7f2:	2100      	movs	r1, #0
  return (endpoint_address & 0xF);
}

void usb_peripheral_reset(void)
{
  RESET_CTRL0 = RESET_CTRL0_USB0_RST;
2000d7f4:	6010      	str	r0, [r2, #0]
  RESET_CTRL0 = 0;
2000d7f6:	6011      	str	r1, [r2, #0]

  while( (RESET_ACTIVE_STATUS0 & RESET_CTRL0_USB0_RST) == 0 );
2000d7f8:	4a03      	ldr	r2, [pc, #12]	; (2000d808 <usb_peripheral_reset+0x1c>)
2000d7fa:	6813      	ldr	r3, [r2, #0]
2000d7fc:	4203      	tst	r3, r0
2000d7fe:	d0fb      	beq.n	2000d7f8 <usb_peripheral_reset+0xc>
}
2000d800:	4770      	bx	lr
2000d802:	46c0      	nop			; (mov r8, r8)
2000d804:	40053100 	.word	0x40053100
2000d808:	40053150 	.word	0x40053150

2000d80c <usb_endpoint_prime>:
}

void usb_endpoint_prime(
  const usb_endpoint_t* const endpoint,
  usb_transfer_descriptor_t* const first_td)
{
2000d80c:	b538      	push	{r3, r4, r5, lr}
  usb_queue_head_t* const qh = usb_queue_head(endpoint->address);
2000d80e:	6904      	ldr	r4, [r0, #16]
}

void usb_endpoint_prime(
  const usb_endpoint_t* const endpoint,
  usb_transfer_descriptor_t* const first_td)
{
2000d810:	1c0d      	adds	r5, r1, #0
  usb_queue_head_t* const qh = usb_queue_head(endpoint->address);
2000d812:	1c20      	adds	r0, r4, #0
2000d814:	f7ff ffde 	bl	2000d7d4 <usb_queue_head>

  qh->next_dtd_pointer = first_td;
  qh->total_bytes &= ~( USB_TD_DTD_TOKEN_STATUS_ACTIVE | USB_TD_DTD_TOKEN_STATUS_HALTED );
2000d818:	68c3      	ldr	r3, [r0, #12]
2000d81a:	22c0      	movs	r2, #192	; 0xc0
2000d81c:	4393      	bics	r3, r2
  const usb_endpoint_t* const endpoint,
  usb_transfer_descriptor_t* const first_td)
{
  usb_queue_head_t* const qh = usb_queue_head(endpoint->address);

  qh->next_dtd_pointer = first_td;
2000d81e:	6085      	str	r5, [r0, #8]
  qh->total_bytes &= ~( USB_TD_DTD_TOKEN_STATUS_ACTIVE | USB_TD_DTD_TOKEN_STATUS_HALTED );
2000d820:	60c3      	str	r3, [r0, #12]
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000d822:	200f      	movs	r0, #15
2000d824:	4020      	ands	r0, r4
2000d826:	2101      	movs	r1, #1
  qh->total_bytes &= ~( USB_TD_DTD_TOKEN_STATUS_ACTIVE | USB_TD_DTD_TOKEN_STATUS_HALTED );

  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  if( usb_endpoint_is_in(endpoint->address) )
  {
    USB0_ENDPTPRIME = USB0_ENDPTPRIME_PETB(1 << endpoint_number);
2000d828:	4081      	lsls	r1, r0
2000d82a:	4d03      	ldr	r5, [pc, #12]	; (2000d838 <usb_endpoint_prime+0x2c>)
2000d82c:	1c0b      	adds	r3, r1, #0

  qh->next_dtd_pointer = first_td;
  qh->total_bytes &= ~( USB_TD_DTD_TOKEN_STATUS_ACTIVE | USB_TD_DTD_TOKEN_STATUS_HALTED );

  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  if( usb_endpoint_is_in(endpoint->address) )
2000d82e:	0620      	lsls	r0, r4, #24
2000d830:	d500      	bpl.n	2000d834 <usb_endpoint_prime+0x28>
  {
    USB0_ENDPTPRIME = USB0_ENDPTPRIME_PETB(1 << endpoint_number);
2000d832:	040b      	lsls	r3, r1, #16
  } else {
    USB0_ENDPTPRIME = USB0_ENDPTPRIME_PERB(1 << endpoint_number);
2000d834:	602b      	str	r3, [r5, #0]
  }
}
2000d836:	bd38      	pop	{r3, r4, r5, pc}
2000d838:	400061b0 	.word	0x400061b0

2000d83c <usb_endpoint_flush>:
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000d83c:	6902      	ldr	r2, [r0, #16]
    usb_endpoint_prime(endpoint, new_td);
  }
}

void usb_endpoint_flush(const usb_endpoint_t* const endpoint)
{
2000d83e:	b538      	push	{r3, r4, r5, lr}
2000d840:	1c04      	adds	r4, r0, #0
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000d842:	250f      	movs	r5, #15
2000d844:	4015      	ands	r5, r2
}

void usb_endpoint_flush(const usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  usb_queue_flush_endpoint(endpoint);
2000d846:	f000 fa6d 	bl	2000dd24 <usb_queue_flush_endpoint>
  return ((direction == USB_TRANSFER_DIRECTION_IN) ? 0x80 : 0x00) + number;
}

static bool usb_endpoint_is_in(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0x80) ? true : false;
2000d84a:	6923      	ldr	r3, [r4, #16]
2000d84c:	2001      	movs	r0, #1
void usb_endpoint_flush(const usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  usb_queue_flush_endpoint(endpoint);
  if( usb_endpoint_is_in(endpoint->address) ) {
    usb_flush_primed_endpoints(USB0_ENDPTFLUSH_FETB(1 << endpoint_number));
2000d84e:	40a8      	lsls	r0, r5

void usb_endpoint_flush(const usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  usb_queue_flush_endpoint(endpoint);
  if( usb_endpoint_is_in(endpoint->address) ) {
2000d850:	061a      	lsls	r2, r3, #24
2000d852:	d500      	bpl.n	2000d856 <usb_endpoint_flush+0x1a>
    usb_flush_primed_endpoints(USB0_ENDPTFLUSH_FETB(1 << endpoint_number));
2000d854:	0400      	lsls	r0, r0, #16
  } else {
    usb_flush_primed_endpoints(USB0_ENDPTFLUSH_FERB(1 << endpoint_number));
2000d856:	f7ff ff87 	bl	2000d768 <usb_flush_primed_endpoints>
  }
}
2000d85a:	bd38      	pop	{r3, r4, r5, pc}

2000d85c <usb_endpoint_disable>:
  }
}

void usb_endpoint_disable(const usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
2000d85c:	6903      	ldr	r3, [r0, #16]
    usb_clear_pending_interrupts(USB0_ENDPTCOMPLETE_ERCE(1 << endpoint_number));
  }
}

void usb_endpoint_disable(const usb_endpoint_t* const endpoint)
{
2000d85e:	b510      	push	{r4, lr}
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000d860:	210f      	movs	r1, #15
    usb_clear_pending_interrupts(USB0_ENDPTCOMPLETE_ERCE(1 << endpoint_number));
  }
}

void usb_endpoint_disable(const usb_endpoint_t* const endpoint)
{
2000d862:	1c04      	adds	r4, r0, #0
2000d864:	4810      	ldr	r0, [pc, #64]	; (2000d8a8 <usb_endpoint_disable+0x4c>)
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000d866:	4019      	ands	r1, r3
  return ((direction == USB_TRANSFER_DIRECTION_IN) ? 0x80 : 0x00) + number;
}

static bool usb_endpoint_is_in(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0x80) ? true : false;
2000d868:	2280      	movs	r2, #128	; 0x80
2000d86a:	1809      	adds	r1, r1, r0
}

void usb_endpoint_disable(const usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  if( usb_endpoint_is_in(endpoint->address) )
2000d86c:	4213      	tst	r3, r2
2000d86e:	d005      	beq.n	2000d87c <usb_endpoint_disable+0x20>
  {
    USB0_ENDPTCTRL(endpoint_number) &= ~(USB0_ENDPTCTRL_TXE);
2000d870:	0089      	lsls	r1, r1, #2
2000d872:	6808      	ldr	r0, [r1, #0]
2000d874:	4b0d      	ldr	r3, [pc, #52]	; (2000d8ac <usb_endpoint_disable+0x50>)
2000d876:	4003      	ands	r3, r0
2000d878:	600b      	str	r3, [r1, #0]
2000d87a:	e003      	b.n	2000d884 <usb_endpoint_disable+0x28>
  } else {
    USB0_ENDPTCTRL(endpoint_number) &= ~(USB0_ENDPTCTRL_RXE);
2000d87c:	008b      	lsls	r3, r1, #2
2000d87e:	6818      	ldr	r0, [r3, #0]
2000d880:	4390      	bics	r0, r2
2000d882:	6018      	str	r0, [r3, #0]
  }
  usb_queue_flush_endpoint(endpoint);
2000d884:	1c20      	adds	r0, r4, #0
2000d886:	f000 fa4d 	bl	2000dd24 <usb_queue_flush_endpoint>
  }
}

static void usb_endpoint_clear_pending_interrupts(const usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
2000d88a:	6921      	ldr	r1, [r4, #16]
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000d88c:	220f      	movs	r2, #15
2000d88e:	400a      	ands	r2, r1
2000d890:	2001      	movs	r0, #1

static void usb_endpoint_clear_pending_interrupts(const usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  if( usb_endpoint_is_in(endpoint->address) ) {
    usb_clear_pending_interrupts(USB0_ENDPTCOMPLETE_ETCE(1 << endpoint_number));
2000d892:	4090      	lsls	r0, r2
}

static void usb_endpoint_clear_pending_interrupts(const usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  if( usb_endpoint_is_in(endpoint->address) ) {
2000d894:	0609      	lsls	r1, r1, #24
2000d896:	d500      	bpl.n	2000d89a <usb_endpoint_disable+0x3e>
    usb_clear_pending_interrupts(USB0_ENDPTCOMPLETE_ETCE(1 << endpoint_number));
2000d898:	0400      	lsls	r0, r0, #16
  } else {
    usb_clear_pending_interrupts(USB0_ENDPTCOMPLETE_ERCE(1 << endpoint_number));
2000d89a:	f7ff ff4b 	bl	2000d734 <usb_clear_pending_interrupts>
  } else {
    USB0_ENDPTCTRL(endpoint_number) &= ~(USB0_ENDPTCTRL_RXE);
  }
  usb_queue_flush_endpoint(endpoint);
  usb_endpoint_clear_pending_interrupts(endpoint);
  usb_endpoint_flush(endpoint);
2000d89e:	1c20      	adds	r0, r4, #0
2000d8a0:	f7ff ffcc 	bl	2000d83c <usb_endpoint_flush>
}
2000d8a4:	bd10      	pop	{r4, pc}
2000d8a6:	46c0      	nop			; (mov r8, r8)
2000d8a8:	10001870 	.word	0x10001870
2000d8ac:	ff7fffff 	.word	0xff7fffff

2000d8b0 <usb_endpoint_is_ready>:
    return USB0_ENDPTFLUSH & USB0_ENDPTFLUSH_FERB(1 << endpoint_number);
  }
}
*/
bool usb_endpoint_is_ready(const usb_endpoint_t* const endpoint)
{
2000d8b0:	b510      	push	{r4, lr}
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
2000d8b2:	6904      	ldr	r4, [r0, #16]
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000d8b4:	230f      	movs	r3, #15
2000d8b6:	4023      	ands	r3, r4
2000d8b8:	4907      	ldr	r1, [pc, #28]	; (2000d8d8 <usb_endpoint_is_ready+0x28>)
2000d8ba:	2201      	movs	r2, #1
}
*/
bool usb_endpoint_is_ready(const usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  if( usb_endpoint_is_in(endpoint->address) ) {
2000d8bc:	0620      	lsls	r0, r4, #24
2000d8be:	d503      	bpl.n	2000d8c8 <usb_endpoint_is_ready+0x18>
    return USB0_ENDPTSTAT & USB0_ENDPTSTAT_ETBR(1 << endpoint_number);
2000d8c0:	409a      	lsls	r2, r3
2000d8c2:	6808      	ldr	r0, [r1, #0]
2000d8c4:	0414      	lsls	r4, r2, #16
2000d8c6:	e002      	b.n	2000d8ce <usb_endpoint_is_ready+0x1e>
  } else {
    return USB0_ENDPTSTAT & USB0_ENDPTSTAT_ERBR(1 << endpoint_number);
2000d8c8:	409a      	lsls	r2, r3
2000d8ca:	6808      	ldr	r0, [r1, #0]
2000d8cc:	1c14      	adds	r4, r2, #0
2000d8ce:	4020      	ands	r0, r4
2000d8d0:	1e43      	subs	r3, r0, #1
2000d8d2:	4198      	sbcs	r0, r3
  }
}
2000d8d4:	bd10      	pop	{r4, pc}
2000d8d6:	46c0      	nop			; (mov r8, r8)
2000d8d8:	400061b8 	.word	0x400061b8

2000d8dc <usb_endpoint_schedule_append>:
// for setting the TERMINATE bit of next_dtd_pointer if needed.
void usb_endpoint_schedule_append(
  const usb_endpoint_t* const endpoint,
  usb_transfer_descriptor_t* const tail_td,
  usb_transfer_descriptor_t* const new_td)
{
2000d8dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  }
}

static bool usb_endpoint_is_priming(const usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
2000d8de:	6903      	ldr	r3, [r0, #16]
  usb_transfer_descriptor_t* const tail_td,
  usb_transfer_descriptor_t* const new_td)
{
  bool done;

  tail_td->next_dtd_pointer = new_td;
2000d8e0:	600a      	str	r2, [r1, #0]
// for setting the TERMINATE bit of next_dtd_pointer if needed.
void usb_endpoint_schedule_append(
  const usb_endpoint_t* const endpoint,
  usb_transfer_descriptor_t* const tail_td,
  usb_transfer_descriptor_t* const new_td)
{
2000d8e2:	1c16      	adds	r6, r2, #0
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000d8e4:	220f      	movs	r2, #15
// for setting the TERMINATE bit of next_dtd_pointer if needed.
void usb_endpoint_schedule_append(
  const usb_endpoint_t* const endpoint,
  usb_transfer_descriptor_t* const tail_td,
  usb_transfer_descriptor_t* const new_td)
{
2000d8e6:	1c05      	adds	r5, r0, #0
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000d8e8:	401a      	ands	r2, r3
2000d8ea:	4813      	ldr	r0, [pc, #76]	; (2000d938 <usb_endpoint_schedule_append+0x5c>)
2000d8ec:	2101      	movs	r1, #1
}

static bool usb_endpoint_is_priming(const usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  if( usb_endpoint_is_in(endpoint->address) ) {
2000d8ee:	061c      	lsls	r4, r3, #24
2000d8f0:	d503      	bpl.n	2000d8fa <usb_endpoint_schedule_append+0x1e>
    return USB0_ENDPTPRIME & USB0_ENDPTPRIME_PETB(1 << endpoint_number);
2000d8f2:	4091      	lsls	r1, r2
2000d8f4:	6804      	ldr	r4, [r0, #0]
2000d8f6:	040f      	lsls	r7, r1, #16
2000d8f8:	e002      	b.n	2000d900 <usb_endpoint_schedule_append+0x24>
  } else {
    return USB0_ENDPTPRIME & USB0_ENDPTPRIME_PERB(1 << endpoint_number);
2000d8fa:	4091      	lsls	r1, r2
2000d8fc:	6804      	ldr	r4, [r0, #0]
2000d8fe:	1c0f      	adds	r7, r1, #0
2000d900:	403c      	ands	r4, r7
2000d902:	1e62      	subs	r2, r4, #1
2000d904:	4194      	sbcs	r4, r2
{
  bool done;

  tail_td->next_dtd_pointer = new_td;

  if (usb_endpoint_is_priming(endpoint)) {
2000d906:	2c00      	cmp	r4, #0
2000d908:	d115      	bne.n	2000d936 <usb_endpoint_schedule_append+0x5a>
    return;
  }

  do {
    USB0_USBCMD_D |= USB0_USBCMD_D_ATDTW;
2000d90a:	4c0c      	ldr	r4, [pc, #48]	; (2000d93c <usb_endpoint_schedule_append+0x60>)
2000d90c:	2080      	movs	r0, #128	; 0x80
2000d90e:	6822      	ldr	r2, [r4, #0]
2000d910:	01c7      	lsls	r7, r0, #7
2000d912:	433a      	orrs	r2, r7
2000d914:	6022      	str	r2, [r4, #0]
    done = usb_endpoint_is_ready(endpoint);
2000d916:	1c28      	adds	r0, r5, #0
2000d918:	f7ff ffca 	bl	2000d8b0 <usb_endpoint_is_ready>
  } while (!(USB0_USBCMD_D & USB0_USBCMD_D_ATDTW));
2000d91c:	6821      	ldr	r1, [r4, #0]
2000d91e:	4239      	tst	r1, r7
2000d920:	d0f3      	beq.n	2000d90a <usb_endpoint_schedule_append+0x2e>

  USB0_USBCMD_D &= ~USB0_USBCMD_D_ATDTW;
2000d922:	6822      	ldr	r2, [r4, #0]
2000d924:	4b06      	ldr	r3, [pc, #24]	; (2000d940 <usb_endpoint_schedule_append+0x64>)
2000d926:	4013      	ands	r3, r2
2000d928:	6023      	str	r3, [r4, #0]
  if(!done) {
2000d92a:	2800      	cmp	r0, #0
2000d92c:	d103      	bne.n	2000d936 <usb_endpoint_schedule_append+0x5a>
    usb_endpoint_prime(endpoint, new_td);
2000d92e:	1c28      	adds	r0, r5, #0
2000d930:	1c31      	adds	r1, r6, #0
2000d932:	f7ff ff6b 	bl	2000d80c <usb_endpoint_prime>
  }
}
2000d936:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2000d938:	400061b0 	.word	0x400061b0
2000d93c:	40006140 	.word	0x40006140
2000d940:	ffffbfff 	.word	0xffffbfff

2000d944 <usb_endpoint_schedule_wait>:
// Schedule an already filled-in transfer descriptor for execution on
// the given endpoint, waiting until the endpoint has finished.
void usb_endpoint_schedule_wait(
  const usb_endpoint_t* const endpoint,
  usb_transfer_descriptor_t* const td)
{
2000d944:	b538      	push	{r3, r4, r5, lr}
2000d946:	1c05      	adds	r5, r0, #0
2000d948:	1c0c      	adds	r4, r1, #0
  // Ensure that endpoint is ready to be primed.
  // It may have been flushed due to an aborted transaction.
  // TODO: This should be preceded by a flush?
  while( usb_endpoint_is_ready(endpoint) );
2000d94a:	1c28      	adds	r0, r5, #0
2000d94c:	f7ff ffb0 	bl	2000d8b0 <usb_endpoint_is_ready>
2000d950:	2800      	cmp	r0, #0
2000d952:	d1fa      	bne.n	2000d94a <usb_endpoint_schedule_wait+0x6>

  td->next_dtd_pointer = USB_TD_NEXT_DTD_POINTER_TERMINATE;
2000d954:	2301      	movs	r3, #1

  usb_endpoint_prime(endpoint, td);
2000d956:	1c28      	adds	r0, r5, #0
  // Ensure that endpoint is ready to be primed.
  // It may have been flushed due to an aborted transaction.
  // TODO: This should be preceded by a flush?
  while( usb_endpoint_is_ready(endpoint) );

  td->next_dtd_pointer = USB_TD_NEXT_DTD_POINTER_TERMINATE;
2000d958:	6023      	str	r3, [r4, #0]

  usb_endpoint_prime(endpoint, td);
2000d95a:	1c21      	adds	r1, r4, #0
2000d95c:	f7ff ff56 	bl	2000d80c <usb_endpoint_prime>
}
2000d960:	bd38      	pop	{r3, r4, r5, pc}
	...

2000d964 <usb_endpoint_stall>:
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000d964:	6902      	ldr	r2, [r0, #16]
2000d966:	230f      	movs	r3, #15
void usb_endpoint_stall(const usb_endpoint_t* const endpoint)
{
  // Endpoint is to be stalled as a pair -- both OUT and IN.
  // See UM10503 section 23.10.5.2 "Stalling"
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  USB0_ENDPTCTRL(endpoint_number) |= (USB0_ENDPTCTRL_RXS | USB0_ENDPTCTRL_TXS);
2000d968:	4804      	ldr	r0, [pc, #16]	; (2000d97c <usb_endpoint_stall+0x18>)
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000d96a:	4013      	ands	r3, r2
void usb_endpoint_stall(const usb_endpoint_t* const endpoint)
{
  // Endpoint is to be stalled as a pair -- both OUT and IN.
  // See UM10503 section 23.10.5.2 "Stalling"
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  USB0_ENDPTCTRL(endpoint_number) |= (USB0_ENDPTCTRL_RXS | USB0_ENDPTCTRL_TXS);
2000d96c:	1819      	adds	r1, r3, r0
2000d96e:	008b      	lsls	r3, r1, #2
2000d970:	681a      	ldr	r2, [r3, #0]
2000d972:	4803      	ldr	r0, [pc, #12]	; (2000d980 <usb_endpoint_stall+0x1c>)
2000d974:	4302      	orrs	r2, r0
2000d976:	601a      	str	r2, [r3, #0]

  // TODO: Also need to reset data toggle in both directions?
}
2000d978:	4770      	bx	lr
2000d97a:	46c0      	nop			; (mov r8, r8)
2000d97c:	10001870 	.word	0x10001870
2000d980:	00010001 	.word	0x00010001

2000d984 <usb_speed>:
  USB0_OTGSC = USB0_OTGSC_OT | USB0_OTGSC_VD;
}

usb_speed_t usb_speed(const usb_device_t* const device)
{
  if( device == usb_device_usb0 )
2000d984:	4b08      	ldr	r3, [pc, #32]	; (2000d9a8 <usb_speed+0x24>)
  // VBUS_Discharge: VBUS discharges through resistor
  USB0_OTGSC = USB0_OTGSC_OT | USB0_OTGSC_VD;
}

usb_speed_t usb_speed(const usb_device_t* const device)
{
2000d986:	1c02      	adds	r2, r0, #0
  if( device == usb_device_usb0 )
2000d988:	6819      	ldr	r1, [r3, #0]
        return USB_SPEED_FULL;
    }
  } else {
    // TODO: This should not be possible with a more class-like
    // implementation.
    return USB_SPEED_FULL;
2000d98a:	2001      	movs	r0, #1
  USB0_OTGSC = USB0_OTGSC_OT | USB0_OTGSC_VD;
}

usb_speed_t usb_speed(const usb_device_t* const device)
{
  if( device == usb_device_usb0 )
2000d98c:	428a      	cmp	r2, r1
2000d98e:	d10a      	bne.n	2000d9a6 <usb_speed+0x22>
  {
    switch( USB0_PORTSC1_D & USB0_PORTSC1_D_PSPD_MASK )
2000d990:	4806      	ldr	r0, [pc, #24]	; (2000d9ac <usb_speed+0x28>)
2000d992:	23c0      	movs	r3, #192	; 0xc0
2000d994:	6802      	ldr	r2, [r0, #0]
2000d996:	0519      	lsls	r1, r3, #20
2000d998:	20f8      	movs	r0, #248	; 0xf8
2000d99a:	4011      	ands	r1, r2
2000d99c:	0602      	lsls	r2, r0, #24
2000d99e:	1888      	adds	r0, r1, r2
2000d9a0:	4243      	negs	r3, r0
2000d9a2:	4158      	adcs	r0, r3
2000d9a4:	3001      	adds	r0, #1
  } else {
    // TODO: This should not be possible with a more class-like
    // implementation.
    return USB_SPEED_FULL;
  }
}
2000d9a6:	4770      	bx	lr
2000d9a8:	2000f340 	.word	0x2000f340
2000d9ac:	40006184 	.word	0x40006184

2000d9b0 <usb_set_address_immediate>:

void usb_set_address_immediate(
  const usb_device_t* const device,
  const uint_fast8_t address)
{
  if( device == usb_device_usb0 )
2000d9b0:	4b03      	ldr	r3, [pc, #12]	; (2000d9c0 <usb_set_address_immediate+0x10>)
2000d9b2:	681a      	ldr	r2, [r3, #0]
2000d9b4:	4290      	cmp	r0, r2
2000d9b6:	d102      	bne.n	2000d9be <usb_set_address_immediate+0xe>
  {
    USB0_DEVICEADDR = USB0_DEVICEADDR_USBADR(address);
2000d9b8:	4802      	ldr	r0, [pc, #8]	; (2000d9c4 <usb_set_address_immediate+0x14>)
2000d9ba:	0649      	lsls	r1, r1, #25
2000d9bc:	6001      	str	r1, [r0, #0]
  }
}
2000d9be:	4770      	bx	lr
2000d9c0:	2000f340 	.word	0x2000f340
2000d9c4:	40006154 	.word	0x40006154

2000d9c8 <usb_set_address_deferred>:

void usb_set_address_deferred(
  const usb_device_t* const device,
  const uint_fast8_t address)
{
  if( device == usb_device_usb0 )
2000d9c8:	4b05      	ldr	r3, [pc, #20]	; (2000d9e0 <usb_set_address_deferred+0x18>)
2000d9ca:	681a      	ldr	r2, [r3, #0]
2000d9cc:	4290      	cmp	r0, r2
2000d9ce:	d105      	bne.n	2000d9dc <usb_set_address_deferred+0x14>
  {
    USB0_DEVICEADDR = USB0_DEVICEADDR_USBADR(address)
2000d9d0:	0648      	lsls	r0, r1, #25
                      | USB0_DEVICEADDR_USBADRA;
2000d9d2:	2180      	movs	r1, #128	; 0x80
2000d9d4:	044a      	lsls	r2, r1, #17
  const usb_device_t* const device,
  const uint_fast8_t address)
{
  if( device == usb_device_usb0 )
  {
    USB0_DEVICEADDR = USB0_DEVICEADDR_USBADR(address)
2000d9d6:	4b03      	ldr	r3, [pc, #12]	; (2000d9e4 <usb_set_address_deferred+0x1c>)
                      | USB0_DEVICEADDR_USBADRA;
2000d9d8:	4302      	orrs	r2, r0
  const usb_device_t* const device,
  const uint_fast8_t address)
{
  if( device == usb_device_usb0 )
  {
    USB0_DEVICEADDR = USB0_DEVICEADDR_USBADR(address)
2000d9da:	601a      	str	r2, [r3, #0]
                      | USB0_DEVICEADDR_USBADRA;
  }
}
2000d9dc:	4770      	bx	lr
2000d9de:	46c0      	nop			; (mov r8, r8)
2000d9e0:	2000f340 	.word	0x2000f340
2000d9e4:	40006154 	.word	0x40006154

2000d9e8 <usb_device_init>:
}

void usb_device_init(
  const uint_fast8_t device_ordinal,
  usb_device_t* const device)
{
2000d9e8:	b508      	push	{r3, lr}
  if( device_ordinal == 0 )
2000d9ea:	2800      	cmp	r0, #0
2000d9ec:	d12b      	bne.n	2000da46 <usb_device_init+0x5e>
  while( (RESET_ACTIVE_STATUS0 & RESET_CTRL0_USB0_RST) == 0 );
}

static void usb_phy_enable(void)
{
  CREG_CREG0 &= ~CREG_CREG0_USB0PHY;
2000d9ee:	4816      	ldr	r0, [pc, #88]	; (2000da48 <usb_device_init+0x60>)
  const uint_fast8_t device_ordinal,
  usb_device_t* const device)
{
  if( device_ordinal == 0 )
  {
    usb_device_usb0 = device;
2000d9f0:	4b16      	ldr	r3, [pc, #88]	; (2000da4c <usb_device_init+0x64>)
  while( (RESET_ACTIVE_STATUS0 & RESET_CTRL0_USB0_RST) == 0 );
}

static void usb_phy_enable(void)
{
  CREG_CREG0 &= ~CREG_CREG0_USB0PHY;
2000d9f2:	6802      	ldr	r2, [r0, #0]
  const uint_fast8_t device_ordinal,
  usb_device_t* const device)
{
  if( device_ordinal == 0 )
  {
    usb_device_usb0 = device;
2000d9f4:	6019      	str	r1, [r3, #0]
  while( (RESET_ACTIVE_STATUS0 & RESET_CTRL0_USB0_RST) == 0 );
}

static void usb_phy_enable(void)
{
  CREG_CREG0 &= ~CREG_CREG0_USB0PHY;
2000d9f6:	2120      	movs	r1, #32
2000d9f8:	438a      	bics	r2, r1
2000d9fa:	6002      	str	r2, [r0, #0]
  }
}

static void usb_reset_all_endpoints(void)
{
  usb_disable_all_endpoints();
2000d9fc:	f7ff fec2 	bl	2000d784 <usb_disable_all_endpoints>
  USB0_ENDPTCOMPLETE = USB0_ENDPTCOMPLETE & mask;
}

static void usb_clear_all_pending_interrupts(void)
{
  usb_clear_pending_interrupts(0xFFFFFFFF);
2000da00:	2301      	movs	r3, #1
2000da02:	4258      	negs	r0, r3
2000da04:	f7ff fe96 	bl	2000d734 <usb_clear_pending_interrupts>
  usb_wait_for_endpoint_flushing_to_finish(mask);
}

static void usb_flush_all_primed_endpoints(void)
{
  usb_flush_primed_endpoints(0xFFFFFFFF);
2000da08:	2001      	movs	r0, #1
2000da0a:	4240      	negs	r0, r0
2000da0c:	f7ff feac 	bl	2000d768 <usb_flush_primed_endpoints>
  USB0_USBCMD_D |= USB0_USBCMD_D_RS;
}

static void usb_controller_stop(void)
{
  USB0_USBCMD_D &= ~USB0_USBCMD_D_RS;
2000da10:	4b0f      	ldr	r3, [pc, #60]	; (2000da50 <usb_device_init+0x68>)
2000da12:	2101      	movs	r1, #1
2000da14:	681a      	ldr	r2, [r3, #0]

  // Reset controller. Resets internal pipelines, timers, counters, state
  // machines to initial values. Not recommended when device is in attached
  // state -- effect on attached host is undefined. Detach first by flushing
  // all primed endpoints and stopping controller.
  USB0_USBCMD_D = USB0_USBCMD_D_RST;
2000da16:	2002      	movs	r0, #2
  USB0_USBCMD_D |= USB0_USBCMD_D_RS;
}

static void usb_controller_stop(void)
{
  USB0_USBCMD_D &= ~USB0_USBCMD_D_RS;
2000da18:	438a      	bics	r2, r1
2000da1a:	601a      	str	r2, [r3, #0]

  // Reset controller. Resets internal pipelines, timers, counters, state
  // machines to initial values. Not recommended when device is in attached
  // state -- effect on attached host is undefined. Detach first by flushing
  // all primed endpoints and stopping controller.
  USB0_USBCMD_D = USB0_USBCMD_D_RST;
2000da1c:	6018      	str	r0, [r3, #0]
  USB0_USBCMD_D &= ~USB0_USBCMD_D_RS;
}

static uint_fast8_t usb_controller_is_resetting(void)
{
  return (USB0_USBCMD_D & USB0_USBCMD_D_RST) != 0;
2000da1e:	6818      	ldr	r0, [r3, #0]
2000da20:	2102      	movs	r1, #2
2000da22:	4a0b      	ldr	r2, [pc, #44]	; (2000da50 <usb_device_init+0x68>)
  // machines to initial values. Not recommended when device is in attached
  // state -- effect on attached host is undefined. Detach first by flushing
  // all primed endpoints and stopping controller.
  USB0_USBCMD_D = USB0_USBCMD_D_RST;

  while( usb_controller_is_resetting() );
2000da24:	4208      	tst	r0, r1
2000da26:	d1fa      	bne.n	2000da1e <usb_device_init+0x36>
}

static void usb_controller_set_device_mode(void)
{
  // Set USB0 peripheral mode
  USB0_USBMODE_D = USB0_USBMODE_D_CM1_0(2);
2000da28:	4b0a      	ldr	r3, [pc, #40]	; (2000da54 <usb_device_init+0x6c>)

  // Set device-related OTG flags
  // OTG termination: controls pull-down on USB_DM
  // VBUS_Discharge: VBUS discharges through resistor
  USB0_OTGSC = USB0_OTGSC_OT | USB0_OTGSC_VD;
2000da2a:	2009      	movs	r0, #9
}

static void usb_controller_set_device_mode(void)
{
  // Set USB0 peripheral mode
  USB0_USBMODE_D = USB0_USBMODE_D_CM1_0(2);
2000da2c:	6019      	str	r1, [r3, #0]

  // Set device-related OTG flags
  // OTG termination: controls pull-down on USB_DM
  // VBUS_Discharge: VBUS discharges through resistor
  USB0_OTGSC = USB0_OTGSC_OT | USB0_OTGSC_VD;
2000da2e:	490a      	ldr	r1, [pc, #40]	; (2000da58 <usb_device_init+0x70>)
    usb_phy_enable();
    usb_controller_reset();
    usb_controller_set_device_mode();

    // Set interrupt threshold interval to 0
    USB0_USBCMD_D &= ~USB0_USBCMD_D_ITC_MASK;
2000da30:	4b0a      	ldr	r3, [pc, #40]	; (2000da5c <usb_device_init+0x74>)
  USB0_USBMODE_D = USB0_USBMODE_D_CM1_0(2);

  // Set device-related OTG flags
  // OTG termination: controls pull-down on USB_DM
  // VBUS_Discharge: VBUS discharges through resistor
  USB0_OTGSC = USB0_OTGSC_OT | USB0_OTGSC_VD;
2000da32:	6008      	str	r0, [r1, #0]
    usb_phy_enable();
    usb_controller_reset();
    usb_controller_set_device_mode();

    // Set interrupt threshold interval to 0
    USB0_USBCMD_D &= ~USB0_USBCMD_D_ITC_MASK;
2000da34:	6810      	ldr	r0, [r2, #0]

    // Configure endpoint list address
    USB0_ENDPOINTLISTADDR = (uint32_t)usb_qh;
2000da36:	490a      	ldr	r1, [pc, #40]	; (2000da60 <usb_device_init+0x78>)
    usb_phy_enable();
    usb_controller_reset();
    usb_controller_set_device_mode();

    // Set interrupt threshold interval to 0
    USB0_USBCMD_D &= ~USB0_USBCMD_D_ITC_MASK;
2000da38:	4003      	ands	r3, r0
2000da3a:	6013      	str	r3, [r2, #0]

    // Configure endpoint list address
    USB0_ENDPOINTLISTADDR = (uint32_t)usb_qh;

    // Enable interrupts
    USB0_USBINTR_D =
2000da3c:	4809      	ldr	r0, [pc, #36]	; (2000da64 <usb_device_init+0x7c>)

    // Set interrupt threshold interval to 0
    USB0_USBCMD_D &= ~USB0_USBCMD_D_ITC_MASK;

    // Configure endpoint list address
    USB0_ENDPOINTLISTADDR = (uint32_t)usb_qh;
2000da3e:	4a0a      	ldr	r2, [pc, #40]	; (2000da68 <usb_device_init+0x80>)

    // Enable interrupts
    USB0_USBINTR_D =
2000da40:	4b0a      	ldr	r3, [pc, #40]	; (2000da6c <usb_device_init+0x84>)

    // Set interrupt threshold interval to 0
    USB0_USBCMD_D &= ~USB0_USBCMD_D_ITC_MASK;

    // Configure endpoint list address
    USB0_ENDPOINTLISTADDR = (uint32_t)usb_qh;
2000da42:	600a      	str	r2, [r1, #0]

    // Enable interrupts
    USB0_USBINTR_D =
2000da44:	6018      	str	r0, [r3, #0]
      //| USB0_USBINTR_D_SRE
      | USB0_USBINTR_D_SLE
      //| USB0_USBINTR_D_NAKE
      ;
  }
}
2000da46:	bd08      	pop	{r3, pc}
2000da48:	40043004 	.word	0x40043004
2000da4c:	2000f340 	.word	0x2000f340
2000da50:	40006140 	.word	0x40006140
2000da54:	400061a8 	.word	0x400061a8
2000da58:	400061a4 	.word	0x400061a4
2000da5c:	ff00ffff 	.word	0xff00ffff
2000da60:	40006158 	.word	0x40006158
2000da64:	00000147 	.word	0x00000147
2000da68:	2000f800 	.word	0x2000f800
2000da6c:	40006148 	.word	0x40006148

2000da70 <usb_run>:

void usb_run(usb_device_t* const device)
{
2000da70:	b508      	push	{r3, lr}
  //}
}

static void usb_interrupt_enable(usb_device_t* const device)
{
  if( device == usb_device_usb0 )
2000da72:	4b06      	ldr	r3, [pc, #24]	; (2000da8c <usb_run+0x1c>)
2000da74:	6819      	ldr	r1, [r3, #0]
2000da76:	4288      	cmp	r0, r1
2000da78:	d102      	bne.n	2000da80 <usb_run+0x10>
  {
    nvic_enable_irq(NVIC_USB0_IRQ);
2000da7a:	2008      	movs	r0, #8
2000da7c:	f000 fe1e 	bl	2000e6bc <nvic_enable_irq>
  // TODO: Also need to reset data toggle in both directions?
}

static void usb_controller_run(void)
{
  USB0_USBCMD_D |= USB0_USBCMD_D_RS;
2000da80:	4803      	ldr	r0, [pc, #12]	; (2000da90 <usb_run+0x20>)
2000da82:	2301      	movs	r3, #1
2000da84:	6802      	ldr	r2, [r0, #0]
2000da86:	431a      	orrs	r2, r3
2000da88:	6002      	str	r2, [r0, #0]

void usb_run(usb_device_t* const device)
{
  usb_interrupt_enable(device);
  usb_controller_run();
}
2000da8a:	bd08      	pop	{r3, pc}
2000da8c:	2000f340 	.word	0x2000f340
2000da90:	40006140 	.word	0x40006140

2000da94 <usb_endpoint_init>:
  dst->length_l = src[6];
  dst->length_h = src[7];
}

void usb_endpoint_init(const usb_endpoint_t* const endpoint)
{
2000da94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000da96:	1c04      	adds	r4, r0, #0
  usb_endpoint_flush(endpoint);
2000da98:	f7ff fed0 	bl	2000d83c <usb_endpoint_flush>

  uint_fast16_t max_packet_size = endpoint->device->descriptor[7];
2000da9c:	6963      	ldr	r3, [r4, #20]
2000da9e:	6818      	ldr	r0, [r3, #0]
2000daa0:	79c7      	ldrb	r7, [r0, #7]
  usb_transfer_type_t transfer_type = USB_TRANSFER_TYPE_CONTROL;
  const uint8_t* const endpoint_descriptor = usb_endpoint_descriptor(endpoint);
2000daa2:	1c20      	adds	r0, r4, #0
2000daa4:	f000 fa41 	bl	2000df2a <usb_endpoint_descriptor>
2000daa8:	1e05      	subs	r5, r0, #0
  if( endpoint_descriptor )
2000daaa:	d006      	beq.n	2000daba <usb_endpoint_init+0x26>
  {
    max_packet_size = usb_endpoint_descriptor_max_packet_size(endpoint_descriptor);
2000daac:	f000 fa52 	bl	2000df54 <usb_endpoint_descriptor_max_packet_size>
2000dab0:	1c07      	adds	r7, r0, #0
    transfer_type = usb_endpoint_descriptor_transfer_type(endpoint_descriptor);
2000dab2:	1c28      	adds	r0, r5, #0
2000dab4:	f000 fa54 	bl	2000df60 <usb_endpoint_descriptor_transfer_type>
2000dab8:	1c05      	adds	r5, r0, #0
  }

  // TODO: There are more capabilities to adjust based on the endpoint
  // descriptor.
  usb_queue_head_t* const qh = usb_queue_head(endpoint->address);
2000daba:	6926      	ldr	r6, [r4, #16]
2000dabc:	1c30      	adds	r0, r6, #0
2000dabe:	f7ff fe89 	bl	2000d7d4 <usb_queue_head>
  qh->capabilities = USB_QH_CAPABILITIES_MULT(0)
    | USB_QH_CAPABILITIES_ZLT
    | USB_QH_CAPABILITIES_MPL(max_packet_size)
    | ((transfer_type == USB_TRANSFER_TYPE_CONTROL) ? USB_QH_CAPABILITIES_IOS : 0);
2000dac2:	426b      	negs	r3, r5
2000dac4:	416b      	adcs	r3, r5
2000dac6:	2280      	movs	r2, #128	; 0x80
  // TODO: There are more capabilities to adjust based on the endpoint
  // descriptor.
  usb_queue_head_t* const qh = usb_queue_head(endpoint->address);
  qh->capabilities = USB_QH_CAPABILITIES_MULT(0)
    | USB_QH_CAPABILITIES_ZLT
    | USB_QH_CAPABILITIES_MPL(max_packet_size)
2000dac8:	0439      	lsls	r1, r7, #16
    | ((transfer_type == USB_TRANSFER_TYPE_CONTROL) ? USB_QH_CAPABILITIES_IOS : 0);
2000daca:	03df      	lsls	r7, r3, #15
2000dacc:	0593      	lsls	r3, r2, #22
2000dace:	4319      	orrs	r1, r3
2000dad0:	4339      	orrs	r1, r7
  }

  // TODO: There are more capabilities to adjust based on the endpoint
  // descriptor.
  usb_queue_head_t* const qh = usb_queue_head(endpoint->address);
  qh->capabilities = USB_QH_CAPABILITIES_MULT(0)
2000dad2:	6001      	str	r1, [r0, #0]
    | USB_QH_CAPABILITIES_ZLT
    | USB_QH_CAPABILITIES_MPL(max_packet_size)
    | ((transfer_type == USB_TRANSFER_TYPE_CONTROL) ? USB_QH_CAPABILITIES_IOS : 0);

  qh->current_dtd_pointer = 0;
  qh->next_dtd_pointer = USB_TD_NEXT_DTD_POINTER_TERMINATE;
2000dad4:	2701      	movs	r7, #1
  qh->capabilities = USB_QH_CAPABILITIES_MULT(0)
    | USB_QH_CAPABILITIES_ZLT
    | USB_QH_CAPABILITIES_MPL(max_packet_size)
    | ((transfer_type == USB_TRANSFER_TYPE_CONTROL) ? USB_QH_CAPABILITIES_IOS : 0);

  qh->current_dtd_pointer = 0;
2000dad6:	2100      	movs	r1, #0
  qh->next_dtd_pointer = USB_TD_NEXT_DTD_POINTER_TERMINATE;
  qh->total_bytes
    = USB_TD_DTD_TOKEN_TOTAL_BYTES(0)
2000dad8:	60c1      	str	r1, [r0, #12]
  qh->capabilities = USB_QH_CAPABILITIES_MULT(0)
    | USB_QH_CAPABILITIES_ZLT
    | USB_QH_CAPABILITIES_MPL(max_packet_size)
    | ((transfer_type == USB_TRANSFER_TYPE_CONTROL) ? USB_QH_CAPABILITIES_IOS : 0);

  qh->current_dtd_pointer = 0;
2000dada:	6041      	str	r1, [r0, #4]
  qh->next_dtd_pointer = USB_TD_NEXT_DTD_POINTER_TERMINATE;
  qh->total_bytes
    = USB_TD_DTD_TOKEN_TOTAL_BYTES(0)
    | USB_TD_DTD_TOKEN_MULTO(0);

  qh->buffer_pointer_page[0] = 0;
2000dadc:	6101      	str	r1, [r0, #16]
    | USB_QH_CAPABILITIES_ZLT
    | USB_QH_CAPABILITIES_MPL(max_packet_size)
    | ((transfer_type == USB_TRANSFER_TYPE_CONTROL) ? USB_QH_CAPABILITIES_IOS : 0);

  qh->current_dtd_pointer = 0;
  qh->next_dtd_pointer = USB_TD_NEXT_DTD_POINTER_TERMINATE;
2000dade:	6087      	str	r7, [r0, #8]
  qh->total_bytes
    = USB_TD_DTD_TOKEN_TOTAL_BYTES(0)
    | USB_TD_DTD_TOKEN_MULTO(0);

  qh->buffer_pointer_page[0] = 0;
  qh->buffer_pointer_page[1] = 0;
2000dae0:	6141      	str	r1, [r0, #20]
  qh->buffer_pointer_page[2] = 0;
2000dae2:	6181      	str	r1, [r0, #24]
  qh->buffer_pointer_page[3] = 0;
2000dae4:	61c1      	str	r1, [r0, #28]
  qh->buffer_pointer_page[4] = 0;
2000dae6:	6201      	str	r1, [r0, #32]

  // This is how we look up an endpoint structure from an endpoint address:
  qh->_reserved_0 = (uint32_t)endpoint;
2000dae8:	6244      	str	r4, [r0, #36]	; 0x24
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000daea:	240f      	movs	r4, #15
  // NOTE: UM10503 section 23.6.24 "Endpoint 1 to 5 control registers" says
  // that the disabled side of an endpoint must be set to a non-control type
  // (e.g. bulk, interrupt, or iso).
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  USB0_ENDPTCTRL(endpoint_number)
    = ( USB0_ENDPTCTRL(endpoint_number)
2000daec:	480b      	ldr	r0, [pc, #44]	; (2000db1c <usb_endpoint_init+0x88>)
  return (endpoint_address & 0x80) ? true : false;
}

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000daee:	4034      	ands	r4, r6
  // NOTE: UM10503 section 23.6.24 "Endpoint 1 to 5 control registers" says
  // that the disabled side of an endpoint must be set to a non-control type
  // (e.g. bulk, interrupt, or iso).
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  USB0_ENDPTCTRL(endpoint_number)
    = ( USB0_ENDPTCTRL(endpoint_number)
2000daf0:	1822      	adds	r2, r4, r0
2000daf2:	0093      	lsls	r3, r2, #2
2000daf4:	6819      	ldr	r1, [r3, #0]
        & ~(USB0_ENDPTCTRL_TXT1_0_MASK | USB0_ENDPTCTRL_RXT_MASK) )
2000daf6:	4c0a      	ldr	r4, [pc, #40]	; (2000db20 <usb_endpoint_init+0x8c>)
      | ( USB0_ENDPTCTRL_TXT1_0(transfer_type)
      | USB0_ENDPTCTRL_RXT(transfer_type) );
2000daf8:	00af      	lsls	r7, r5, #2
  // (e.g. bulk, interrupt, or iso).
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  USB0_ENDPTCTRL(endpoint_number)
    = ( USB0_ENDPTCTRL(endpoint_number)
        & ~(USB0_ENDPTCTRL_TXT1_0_MASK | USB0_ENDPTCTRL_RXT_MASK) )
      | ( USB0_ENDPTCTRL_TXT1_0(transfer_type)
2000dafa:	04ad      	lsls	r5, r5, #18
      | USB0_ENDPTCTRL_RXT(transfer_type) );
2000dafc:	433d      	orrs	r5, r7
  // that the disabled side of an endpoint must be set to a non-control type
  // (e.g. bulk, interrupt, or iso).
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  USB0_ENDPTCTRL(endpoint_number)
    = ( USB0_ENDPTCTRL(endpoint_number)
        & ~(USB0_ENDPTCTRL_TXT1_0_MASK | USB0_ENDPTCTRL_RXT_MASK) )
2000dafe:	400c      	ands	r4, r1
      | ( USB0_ENDPTCTRL_TXT1_0(transfer_type)
2000db00:	4325      	orrs	r5, r4
  // NOTE: UM10503 section 23.6.24 "Endpoint 1 to 5 control registers" says
  // that the disabled side of an endpoint must be set to a non-control type
  // (e.g. bulk, interrupt, or iso).
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  USB0_ENDPTCTRL(endpoint_number)
    = ( USB0_ENDPTCTRL(endpoint_number)
2000db02:	601d      	str	r5, [r3, #0]
}

static void usb_endpoint_enable(const usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);
  if( usb_endpoint_is_in(endpoint->address) ) {
2000db04:	0632      	lsls	r2, r6, #24
2000db06:	d503      	bpl.n	2000db10 <usb_endpoint_init+0x7c>
    USB0_ENDPTCTRL(endpoint_number) |= (USB0_ENDPTCTRL_TXE | USB0_ENDPTCTRL_TXR);
2000db08:	22c0      	movs	r2, #192	; 0xc0
2000db0a:	6818      	ldr	r0, [r3, #0]
2000db0c:	0416      	lsls	r6, r2, #16
2000db0e:	e001      	b.n	2000db14 <usb_endpoint_init+0x80>
  } else {
    USB0_ENDPTCTRL(endpoint_number) |= (USB0_ENDPTCTRL_RXE | USB0_ENDPTCTRL_RXR);
2000db10:	681e      	ldr	r6, [r3, #0]
2000db12:	20c0      	movs	r0, #192	; 0xc0
2000db14:	4306      	orrs	r6, r0
2000db16:	601e      	str	r6, [r3, #0]
  //  USB0_ENDPTNAKEN_EPRNE(1 << endpoint_out->number);

  usb_endpoint_set_type(endpoint, transfer_type);

  usb_endpoint_enable(endpoint);
}
2000db18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2000db1a:	46c0      	nop			; (mov r8, r8)
2000db1c:	10001870 	.word	0x10001870
2000db20:	fff3fff3 	.word	0xfff3fff3

2000db24 <usb0_isr>:
    }
  }
}

void usb0_isr(void)
{
2000db24:	b5f0      	push	{r4, r5, r6, r7, lr}
}

static uint32_t usb_get_status(void)
{
    // Mask status flags with enabled flag interrupts.
  const uint32_t status = USB0_USBSTS_D & USB0_USBINTR_D;
2000db26:	4b5d      	ldr	r3, [pc, #372]	; (2000dc9c <usb0_isr+0x178>)
2000db28:	4a5d      	ldr	r2, [pc, #372]	; (2000dca0 <usb0_isr+0x17c>)
2000db2a:	6819      	ldr	r1, [r3, #0]
2000db2c:	6810      	ldr	r0, [r2, #0]
    }
  }
}

void usb0_isr(void)
{
2000db2e:	b085      	sub	sp, #20
}

static uint32_t usb_get_status(void)
{
    // Mask status flags with enabled flag interrupts.
  const uint32_t status = USB0_USBSTS_D & USB0_USBINTR_D;
2000db30:	4001      	ands	r1, r0
2000db32:	9100      	str	r1, [sp, #0]
  }
}

static void usb_clear_status(const uint32_t status)
{
  USB0_USBSTS_D = status;
2000db34:	6019      	str	r1, [r3, #0]

void usb0_isr(void)
{
  const uint32_t status = usb_get_status();

  if( status == 0 ) {
2000db36:	d100      	bne.n	2000db3a <usb0_isr+0x16>
2000db38:	e0ad      	b.n	2000dc96 <usb0_isr+0x172>
    // Nothing to do.
    return;
  }

  if( status & USB0_USBSTS_D_UI ) {
2000db3a:	07cb      	lsls	r3, r1, #31
2000db3c:	d418      	bmi.n	2000db70 <usb0_isr+0x4c>

  if( status & USB0_USBSTS_D_SLI ) {
    // Device controller suspend.
  }
*/
  if( status & USB0_USBSTS_D_URI ) {
2000db3e:	9800      	ldr	r0, [sp, #0]
2000db40:	0642      	lsls	r2, r0, #25
2000db42:	d400      	bmi.n	2000db46 <usb0_isr+0x22>
2000db44:	e0a7      	b.n	2000dc96 <usb0_isr+0x172>
    // USB reset received.
    usb_bus_reset(usb_device_usb0);
2000db46:	4e57      	ldr	r6, [pc, #348]	; (2000dca4 <usb0_isr+0x180>)
  USB0_ENDPTCOMPLETE = USB0_ENDPTCOMPLETE & mask;
}

static void usb_clear_all_pending_interrupts(void)
{
  usb_clear_pending_interrupts(0xFFFFFFFF);
2000db48:	2401      	movs	r4, #1
    // Device controller suspend.
  }
*/
  if( status & USB0_USBSTS_D_URI ) {
    // USB reset received.
    usb_bus_reset(usb_device_usb0);
2000db4a:	6837      	ldr	r7, [r6, #0]
  usb_wait_for_endpoint_flushing_to_finish(mask);
}

static void usb_flush_all_primed_endpoints(void)
{
  usb_flush_primed_endpoints(0xFFFFFFFF);
2000db4c:	2501      	movs	r5, #1
  }
}

static void usb_reset_all_endpoints(void)
{
  usb_disable_all_endpoints();
2000db4e:	f7ff fe19 	bl	2000d784 <usb_disable_all_endpoints>
  USB0_ENDPTCOMPLETE = USB0_ENDPTCOMPLETE & mask;
}

static void usb_clear_all_pending_interrupts(void)
{
  usb_clear_pending_interrupts(0xFFFFFFFF);
2000db52:	4260      	negs	r0, r4
2000db54:	f7ff fdee 	bl	2000d734 <usb_clear_pending_interrupts>
  usb_wait_for_endpoint_flushing_to_finish(mask);
}

static void usb_flush_all_primed_endpoints(void)
{
  usb_flush_primed_endpoints(0xFFFFFFFF);
2000db58:	4268      	negs	r0, r5
2000db5a:	f7ff fe05 	bl	2000d768 <usb_flush_primed_endpoints>

static void usb_bus_reset(usb_device_t* const device)
{
  // According to UM10503 v1.4 section 23.10.3 "Bus reset":
  usb_reset_all_endpoints();
  usb_set_address_immediate(device, 0);
2000db5e:	1c38      	adds	r0, r7, #0
2000db60:	2100      	movs	r1, #0
2000db62:	f7ff ff25 	bl	2000d9b0 <usb_set_address_immediate>
  usb_set_configuration(device, 0);
2000db66:	1c38      	adds	r0, r7, #0
2000db68:	2100      	movs	r1, #0
2000db6a:	f000 fa03 	bl	2000df74 <usb_set_configuration>
2000db6e:	e092      	b.n	2000dc96 <usb0_isr+0x172>
  USB0_ENDPTSETUPSTAT = endpoint_setup_status;
}

static uint32_t usb_get_endpoint_setup_status(void)
{
  return USB0_ENDPTSETUPSTAT;
2000db70:	4f4d      	ldr	r7, [pc, #308]	; (2000dca8 <usb0_isr+0x184>)
}

static void usb_check_for_setup_events(void)
{
  const uint32_t endptsetupstat = usb_get_endpoint_setup_status();
  if( endptsetupstat )
2000db72:	2600      	movs	r6, #0
  USB0_ENDPTSETUPSTAT = endpoint_setup_status;
}

static uint32_t usb_get_endpoint_setup_status(void)
{
  return USB0_ENDPTSETUPSTAT;
2000db74:	683b      	ldr	r3, [r7, #0]
2000db76:	9303      	str	r3, [sp, #12]
}

static void usb_check_for_setup_events(void)
{
  const uint32_t endptsetupstat = usb_get_endpoint_setup_status();
  if( endptsetupstat )
2000db78:	42b3      	cmp	r3, r6
2000db7a:	d15d      	bne.n	2000dc38 <usb0_isr+0x114>
  USB0_ENDPTCOMPLETE = endpoint_complete;
}

static uint32_t usb_get_endpoint_complete(void)
{
  return USB0_ENDPTCOMPLETE;
2000db7c:	4e4b      	ldr	r6, [pc, #300]	; (2000dcac <usb0_isr+0x188>)
}

static void usb_check_for_transfer_events(void)
{
  const uint32_t endptcomplete = usb_get_endpoint_complete();
  if( endptcomplete )
2000db7e:	2400      	movs	r4, #0
  USB0_ENDPTCOMPLETE = endpoint_complete;
}

static uint32_t usb_get_endpoint_complete(void)
{
  return USB0_ENDPTCOMPLETE;
2000db80:	6837      	ldr	r7, [r6, #0]
}

static void usb_check_for_transfer_events(void)
{
  const uint32_t endptcomplete = usb_get_endpoint_complete();
  if( endptcomplete )
2000db82:	42a7      	cmp	r7, r4
2000db84:	d170      	bne.n	2000dc68 <usb0_isr+0x144>
2000db86:	e7da      	b.n	2000db3e <usb0_isr+0x1a>
  return &usb_qh[USB_QH_INDEX(endpoint_address)];
}

static usb_endpoint_t* usb_endpoint_from_address(const uint_fast8_t endpoint_address)
{
  return (usb_endpoint_t*)usb_queue_head(endpoint_address)->_reserved_0;
2000db88:	1c30      	adds	r0, r6, #0
2000db8a:	f7ff fe23 	bl	2000d7d4 <usb_queue_head>
2000db8e:	6a44      	ldr	r4, [r0, #36]	; 0x24
      {
        usb_endpoint_t* const endpoint =
          usb_endpoint_from_address(
            usb_endpoint_address(USB_TRANSFER_DIRECTION_OUT, i)
          );
        if( endpoint && endpoint->setup_complete )
2000db90:	2c00      	cmp	r4, #0
2000db92:	d058      	beq.n	2000dc46 <usb0_isr+0x122>
2000db94:	6a20      	ldr	r0, [r4, #32]
2000db96:	2800      	cmp	r0, #0
2000db98:	d055      	beq.n	2000dc46 <usb0_isr+0x122>
        {
          copy_setup(&endpoint->setup, usb_queue_head(endpoint->address)->setup);
2000db9a:	6923      	ldr	r3, [r4, #16]
2000db9c:	1c18      	adds	r0, r3, #0
2000db9e:	9301      	str	r3, [sp, #4]
2000dba0:	f7ff fe18 	bl	2000d7d4 <usb_queue_head>
  usb_controller_run();
}

static void copy_setup(usb_setup_t* const dst, const volatile uint8_t* const src)
{
  dst->request_type = src[0];
2000dba4:	1c01      	adds	r1, r0, #0
2000dba6:	3128      	adds	r1, #40	; 0x28
2000dba8:	780a      	ldrb	r2, [r1, #0]
  dst->request = src[1];
2000dbaa:	1c05      	adds	r5, r0, #0
  usb_controller_run();
}

static void copy_setup(usb_setup_t* const dst, const volatile uint8_t* const src)
{
  dst->request_type = src[0];
2000dbac:	7022      	strb	r2, [r4, #0]
  dst->request = src[1];
2000dbae:	3529      	adds	r5, #41	; 0x29
2000dbb0:	782b      	ldrb	r3, [r5, #0]
  dst->value_l = src[2];
2000dbb2:	1c01      	adds	r1, r0, #0
}

static void copy_setup(usb_setup_t* const dst, const volatile uint8_t* const src)
{
  dst->request_type = src[0];
  dst->request = src[1];
2000dbb4:	7063      	strb	r3, [r4, #1]
  dst->value_l = src[2];
2000dbb6:	312a      	adds	r1, #42	; 0x2a
2000dbb8:	780a      	ldrb	r2, [r1, #0]
  dst->value_h = src[3];
2000dbba:	1c05      	adds	r5, r0, #0

static void copy_setup(usb_setup_t* const dst, const volatile uint8_t* const src)
{
  dst->request_type = src[0];
  dst->request = src[1];
  dst->value_l = src[2];
2000dbbc:	70a2      	strb	r2, [r4, #2]
  dst->value_h = src[3];
2000dbbe:	352b      	adds	r5, #43	; 0x2b
2000dbc0:	782b      	ldrb	r3, [r5, #0]
  dst->index_l = src[4];
2000dbc2:	1c01      	adds	r1, r0, #0
static void copy_setup(usb_setup_t* const dst, const volatile uint8_t* const src)
{
  dst->request_type = src[0];
  dst->request = src[1];
  dst->value_l = src[2];
  dst->value_h = src[3];
2000dbc4:	70e3      	strb	r3, [r4, #3]
  dst->index_l = src[4];
2000dbc6:	312c      	adds	r1, #44	; 0x2c
2000dbc8:	780a      	ldrb	r2, [r1, #0]
  dst->index_h = src[5];
2000dbca:	1c05      	adds	r5, r0, #0
{
  dst->request_type = src[0];
  dst->request = src[1];
  dst->value_l = src[2];
  dst->value_h = src[3];
  dst->index_l = src[4];
2000dbcc:	7122      	strb	r2, [r4, #4]
  dst->index_h = src[5];
2000dbce:	352d      	adds	r5, #45	; 0x2d
2000dbd0:	782b      	ldrb	r3, [r5, #0]
  dst->length_l = src[6];
2000dbd2:	1c01      	adds	r1, r0, #0
  dst->request_type = src[0];
  dst->request = src[1];
  dst->value_l = src[2];
  dst->value_h = src[3];
  dst->index_l = src[4];
  dst->index_h = src[5];
2000dbd4:	7163      	strb	r3, [r4, #5]
  dst->length_l = src[6];
2000dbd6:	312e      	adds	r1, #46	; 0x2e
2000dbd8:	780a      	ldrb	r2, [r1, #0]
  dst->length_h = src[7];
2000dbda:	302f      	adds	r0, #47	; 0x2f
  dst->request = src[1];
  dst->value_l = src[2];
  dst->value_h = src[3];
  dst->index_l = src[4];
  dst->index_h = src[5];
  dst->length_l = src[6];
2000dbdc:	71a2      	strb	r2, [r4, #6]
  dst->length_h = src[7];
2000dbde:	7800      	ldrb	r0, [r0, #0]
        if( endpoint && endpoint->setup_complete )
        {
          copy_setup(&endpoint->setup, usb_queue_head(endpoint->address)->setup);
          // TODO: Clean up this duplicated effort by providing
          // a cleaner way to get the SETUP data.
          copy_setup(&endpoint->in->setup, usb_queue_head(endpoint->address)->setup);
2000dbe0:	69a5      	ldr	r5, [r4, #24]
  dst->value_l = src[2];
  dst->value_h = src[3];
  dst->index_l = src[4];
  dst->index_h = src[5];
  dst->length_l = src[6];
  dst->length_h = src[7];
2000dbe2:	71e0      	strb	r0, [r4, #7]
        if( endpoint && endpoint->setup_complete )
        {
          copy_setup(&endpoint->setup, usb_queue_head(endpoint->address)->setup);
          // TODO: Clean up this duplicated effort by providing
          // a cleaner way to get the SETUP data.
          copy_setup(&endpoint->in->setup, usb_queue_head(endpoint->address)->setup);
2000dbe4:	9801      	ldr	r0, [sp, #4]
2000dbe6:	f7ff fdf5 	bl	2000d7d4 <usb_queue_head>
  usb_controller_run();
}

static void copy_setup(usb_setup_t* const dst, const volatile uint8_t* const src)
{
  dst->request_type = src[0];
2000dbea:	1c03      	adds	r3, r0, #0
2000dbec:	3328      	adds	r3, #40	; 0x28
2000dbee:	7819      	ldrb	r1, [r3, #0]
  dst->request = src[1];
2000dbf0:	1c02      	adds	r2, r0, #0
  usb_controller_run();
}

static void copy_setup(usb_setup_t* const dst, const volatile uint8_t* const src)
{
  dst->request_type = src[0];
2000dbf2:	7029      	strb	r1, [r5, #0]
  dst->request = src[1];
2000dbf4:	3229      	adds	r2, #41	; 0x29
2000dbf6:	7813      	ldrb	r3, [r2, #0]
  dst->value_l = src[2];
2000dbf8:	1c01      	adds	r1, r0, #0
}

static void copy_setup(usb_setup_t* const dst, const volatile uint8_t* const src)
{
  dst->request_type = src[0];
  dst->request = src[1];
2000dbfa:	706b      	strb	r3, [r5, #1]
  dst->value_l = src[2];
2000dbfc:	312a      	adds	r1, #42	; 0x2a
2000dbfe:	780a      	ldrb	r2, [r1, #0]
  dst->value_h = src[3];
2000dc00:	1c03      	adds	r3, r0, #0

static void copy_setup(usb_setup_t* const dst, const volatile uint8_t* const src)
{
  dst->request_type = src[0];
  dst->request = src[1];
  dst->value_l = src[2];
2000dc02:	70aa      	strb	r2, [r5, #2]
  dst->value_h = src[3];
2000dc04:	332b      	adds	r3, #43	; 0x2b
2000dc06:	7819      	ldrb	r1, [r3, #0]
  dst->index_l = src[4];
2000dc08:	1c02      	adds	r2, r0, #0
static void copy_setup(usb_setup_t* const dst, const volatile uint8_t* const src)
{
  dst->request_type = src[0];
  dst->request = src[1];
  dst->value_l = src[2];
  dst->value_h = src[3];
2000dc0a:	70e9      	strb	r1, [r5, #3]
  dst->index_l = src[4];
2000dc0c:	322c      	adds	r2, #44	; 0x2c
2000dc0e:	7813      	ldrb	r3, [r2, #0]
  dst->index_h = src[5];
2000dc10:	1c01      	adds	r1, r0, #0
{
  dst->request_type = src[0];
  dst->request = src[1];
  dst->value_l = src[2];
  dst->value_h = src[3];
  dst->index_l = src[4];
2000dc12:	712b      	strb	r3, [r5, #4]
  dst->index_h = src[5];
2000dc14:	312d      	adds	r1, #45	; 0x2d
2000dc16:	780a      	ldrb	r2, [r1, #0]
  dst->length_l = src[6];
2000dc18:	1c03      	adds	r3, r0, #0
  dst->request_type = src[0];
  dst->request = src[1];
  dst->value_l = src[2];
  dst->value_h = src[3];
  dst->index_l = src[4];
  dst->index_h = src[5];
2000dc1a:	716a      	strb	r2, [r5, #5]
  dst->length_l = src[6];
2000dc1c:	332e      	adds	r3, #46	; 0x2e
2000dc1e:	7819      	ldrb	r1, [r3, #0]
  dst->length_h = src[7];
2000dc20:	302f      	adds	r0, #47	; 0x2f
  dst->request = src[1];
  dst->value_l = src[2];
  dst->value_h = src[3];
  dst->index_l = src[4];
  dst->index_h = src[5];
  dst->length_l = src[6];
2000dc22:	71a9      	strb	r1, [r5, #6]
  dst->length_h = src[7];
2000dc24:	7800      	ldrb	r0, [r0, #0]
2000dc26:	71e8      	strb	r0, [r5, #7]
  return status;
}

static void usb_clear_endpoint_setup_status(const uint32_t endpoint_setup_status)
{
  USB0_ENDPTSETUPSTAT = endpoint_setup_status;
2000dc28:	9d02      	ldr	r5, [sp, #8]
          copy_setup(&endpoint->setup, usb_queue_head(endpoint->address)->setup);
          // TODO: Clean up this duplicated effort by providing
          // a cleaner way to get the SETUP data.
          copy_setup(&endpoint->in->setup, usb_queue_head(endpoint->address)->setup);
          usb_clear_endpoint_setup_status(endptsetupstat_bit);
          endpoint->setup_complete(endpoint);
2000dc2a:	6a22      	ldr	r2, [r4, #32]
  return status;
}

static void usb_clear_endpoint_setup_status(const uint32_t endpoint_setup_status)
{
  USB0_ENDPTSETUPSTAT = endpoint_setup_status;
2000dc2c:	603d      	str	r5, [r7, #0]
          copy_setup(&endpoint->setup, usb_queue_head(endpoint->address)->setup);
          // TODO: Clean up this duplicated effort by providing
          // a cleaner way to get the SETUP data.
          copy_setup(&endpoint->in->setup, usb_queue_head(endpoint->address)->setup);
          usb_clear_endpoint_setup_status(endptsetupstat_bit);
          endpoint->setup_complete(endpoint);
2000dc2e:	1c20      	adds	r0, r4, #0
2000dc30:	4790      	blx	r2
static void usb_check_for_setup_events(void)
{
  const uint32_t endptsetupstat = usb_get_endpoint_setup_status();
  if( endptsetupstat )
  {
    for( uint_fast8_t i=0; i<6; i++ )
2000dc32:	3601      	adds	r6, #1
2000dc34:	2e06      	cmp	r6, #6
2000dc36:	d0a1      	beq.n	2000db7c <usb0_isr+0x58>
    {
      const uint32_t endptsetupstat_bit = USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT(1 << i);
2000dc38:	2101      	movs	r1, #1
      if( endptsetupstat & endptsetupstat_bit )
2000dc3a:	9a03      	ldr	r2, [sp, #12]
  const uint32_t endptsetupstat = usb_get_endpoint_setup_status();
  if( endptsetupstat )
  {
    for( uint_fast8_t i=0; i<6; i++ )
    {
      const uint32_t endptsetupstat_bit = USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT(1 << i);
2000dc3c:	40b1      	lsls	r1, r6
2000dc3e:	9102      	str	r1, [sp, #8]
      if( endptsetupstat & endptsetupstat_bit )
2000dc40:	420a      	tst	r2, r1
2000dc42:	d0f6      	beq.n	2000dc32 <usb0_isr+0x10e>
2000dc44:	e7a0      	b.n	2000db88 <usb0_isr+0x64>
  return status;
}

static void usb_clear_endpoint_setup_status(const uint32_t endpoint_setup_status)
{
  USB0_ENDPTSETUPSTAT = endpoint_setup_status;
2000dc46:	9d02      	ldr	r5, [sp, #8]
2000dc48:	603d      	str	r5, [r7, #0]
2000dc4a:	e7f2      	b.n	2000dc32 <usb0_isr+0x10e>
  return USB0_ENDPTSETUPSTAT;
}

static void usb_clear_endpoint_complete(const uint32_t endpoint_complete)
{
  USB0_ENDPTCOMPLETE = endpoint_complete;
2000dc4c:	6035      	str	r5, [r6, #0]
  return &usb_qh[USB_QH_INDEX(endpoint_address)];
}

static usb_endpoint_t* usb_endpoint_from_address(const uint_fast8_t endpoint_address)
{
  return (usb_endpoint_t*)usb_queue_head(endpoint_address)->_reserved_0;
2000dc4e:	1c20      	adds	r0, r4, #0
2000dc50:	f7ff fdc0 	bl	2000d7d4 <usb_queue_head>
2000dc54:	6a40      	ldr	r0, [r0, #36]	; 0x24
      if( endptcomplete & endptcomplete_out_bit )
      {
        usb_clear_endpoint_complete(endptcomplete_out_bit);
        usb_endpoint_t* const endpoint =
          usb_endpoint_from_address(usb_endpoint_address(USB_TRANSFER_DIRECTION_OUT, i));
        if( endpoint && endpoint->transfer_complete )
2000dc56:	2800      	cmp	r0, #0
2000dc58:	d10b      	bne.n	2000dc72 <usb0_isr+0x14e>
        {
          endpoint->transfer_complete(endpoint);
        }
      }

      const uint32_t endptcomplete_in_bit = USB0_ENDPTCOMPLETE_ETCE(1 << i);
2000dc5a:	0429      	lsls	r1, r5, #16
      if( endptcomplete & endptcomplete_in_bit )
2000dc5c:	420f      	tst	r7, r1
2000dc5e:	d10d      	bne.n	2000dc7c <usb0_isr+0x158>
static void usb_check_for_transfer_events(void)
{
  const uint32_t endptcomplete = usb_get_endpoint_complete();
  if( endptcomplete )
  {
    for( uint_fast8_t i=0; i<6; i++ ) {
2000dc60:	3401      	adds	r4, #1
2000dc62:	2c06      	cmp	r4, #6
2000dc64:	d100      	bne.n	2000dc68 <usb0_isr+0x144>
2000dc66:	e76a      	b.n	2000db3e <usb0_isr+0x1a>

      const uint32_t endptcomplete_out_bit = USB0_ENDPTCOMPLETE_ERCE(1 << i);
2000dc68:	2501      	movs	r5, #1
2000dc6a:	40a5      	lsls	r5, r4
      if( endptcomplete & endptcomplete_out_bit )
2000dc6c:	422f      	tst	r7, r5
2000dc6e:	d0f4      	beq.n	2000dc5a <usb0_isr+0x136>
2000dc70:	e7ec      	b.n	2000dc4c <usb0_isr+0x128>
      {
        usb_clear_endpoint_complete(endptcomplete_out_bit);
        usb_endpoint_t* const endpoint =
          usb_endpoint_from_address(usb_endpoint_address(USB_TRANSFER_DIRECTION_OUT, i));
        if( endpoint && endpoint->transfer_complete )
2000dc72:	6a43      	ldr	r3, [r0, #36]	; 0x24
2000dc74:	2b00      	cmp	r3, #0
2000dc76:	d0f0      	beq.n	2000dc5a <usb0_isr+0x136>
        {
          endpoint->transfer_complete(endpoint);
2000dc78:	4798      	blx	r3
2000dc7a:	e7ee      	b.n	2000dc5a <usb0_isr+0x136>

static uint_fast8_t usb_endpoint_address(
  const usb_transfer_direction_t direction,
  const uint_fast8_t number)
{
  return ((direction == USB_TRANSFER_DIRECTION_IN) ? 0x80 : 0x00) + number;
2000dc7c:	1c20      	adds	r0, r4, #0
  return USB0_ENDPTSETUPSTAT;
}

static void usb_clear_endpoint_complete(const uint32_t endpoint_complete)
{
  USB0_ENDPTCOMPLETE = endpoint_complete;
2000dc7e:	6031      	str	r1, [r6, #0]

static uint_fast8_t usb_endpoint_address(
  const usb_transfer_direction_t direction,
  const uint_fast8_t number)
{
  return ((direction == USB_TRANSFER_DIRECTION_IN) ? 0x80 : 0x00) + number;
2000dc80:	3080      	adds	r0, #128	; 0x80
  return &usb_qh[USB_QH_INDEX(endpoint_address)];
}

static usb_endpoint_t* usb_endpoint_from_address(const uint_fast8_t endpoint_address)
{
  return (usb_endpoint_t*)usb_queue_head(endpoint_address)->_reserved_0;
2000dc82:	f7ff fda7 	bl	2000d7d4 <usb_queue_head>
2000dc86:	6a40      	ldr	r0, [r0, #36]	; 0x24
      if( endptcomplete & endptcomplete_in_bit )
      {
        usb_clear_endpoint_complete(endptcomplete_in_bit);
        usb_endpoint_t* const endpoint =
          usb_endpoint_from_address(usb_endpoint_address(USB_TRANSFER_DIRECTION_IN, i));
        if( endpoint && endpoint->transfer_complete )
2000dc88:	2800      	cmp	r0, #0
2000dc8a:	d0e9      	beq.n	2000dc60 <usb0_isr+0x13c>
2000dc8c:	6a42      	ldr	r2, [r0, #36]	; 0x24
2000dc8e:	2a00      	cmp	r2, #0
2000dc90:	d0e6      	beq.n	2000dc60 <usb0_isr+0x13c>
        {
          endpoint->transfer_complete(endpoint);
2000dc92:	4790      	blx	r2
2000dc94:	e7e4      	b.n	2000dc60 <usb0_isr+0x13c>
  if( status & USB0_USBSTS_D_NAKI ) {
    // Both the TX/RX endpoint NAK bit and corresponding TX/RX endpoint
    // NAK enable bit are set.
  }
*/
}
2000dc96:	b005      	add	sp, #20
2000dc98:	bdf0      	pop	{r4, r5, r6, r7, pc}
2000dc9a:	46c0      	nop			; (mov r8, r8)
2000dc9c:	40006144 	.word	0x40006144
2000dca0:	40006148 	.word	0x40006148
2000dca4:	2000f340 	.word	0x2000f340
2000dca8:	400061ac 	.word	0x400061ac
2000dcac:	400061bc 	.word	0x400061bc

2000dcb0 <endpoint_queue>:

#define USB_ENDPOINT_INDEX(endpoint_address) (((endpoint_address & 0xF) * 2) + ((endpoint_address >> 7) & 1))

static usb_queue_t* endpoint_queue(const usb_endpoint_t* const endpoint)
{
  uint32_t index = USB_ENDPOINT_INDEX(endpoint->address);
2000dcb0:	6903      	ldr	r3, [r0, #16]
2000dcb2:	210f      	movs	r1, #15
2000dcb4:	061a      	lsls	r2, r3, #24
2000dcb6:	400b      	ands	r3, r1
2000dcb8:	0fd0      	lsrs	r0, r2, #31
  if (endpoint_queues[index] == NULL) while (1);
2000dcba:	005b      	lsls	r3, r3, #1
2000dcbc:	181a      	adds	r2, r3, r0
2000dcbe:	4903      	ldr	r1, [pc, #12]	; (2000dccc <endpoint_queue+0x1c>)
2000dcc0:	0090      	lsls	r0, r2, #2
2000dcc2:	5840      	ldr	r0, [r0, r1]
2000dcc4:	2800      	cmp	r0, #0
2000dcc6:	d100      	bne.n	2000dcca <endpoint_queue+0x1a>
2000dcc8:	e7fe      	b.n	2000dcc8 <endpoint_queue+0x18>
  return endpoint_queues[index];
}
2000dcca:	4770      	bx	lr
2000dccc:	2000f344 	.word	0x2000f344

2000dcd0 <usb_queue_init>:

void usb_queue_init(usb_queue_t* const queue)
{
  uint32_t index = USB_ENDPOINT_INDEX(queue->endpoint->address);
2000dcd0:	6803      	ldr	r3, [r0, #0]
  if (endpoint_queues[index] == NULL) while (1);
  return endpoint_queues[index];
}

void usb_queue_init(usb_queue_t* const queue)
{
2000dcd2:	b570      	push	{r4, r5, r6, lr}
  uint32_t index = USB_ENDPOINT_INDEX(queue->endpoint->address);
2000dcd4:	691c      	ldr	r4, [r3, #16]
2000dcd6:	220f      	movs	r2, #15
2000dcd8:	0621      	lsls	r1, r4, #24
2000dcda:	4014      	ands	r4, r2
2000dcdc:	0fcd      	lsrs	r5, r1, #31
2000dcde:	0066      	lsls	r6, r4, #1
2000dce0:	19ac      	adds	r4, r5, r6
  if (endpoint_queues[index] != NULL) while (1);
2000dce2:	4b0e      	ldr	r3, [pc, #56]	; (2000dd1c <usb_queue_init+0x4c>)
2000dce4:	00a1      	lsls	r1, r4, #2
2000dce6:	58ca      	ldr	r2, [r1, r3]
2000dce8:	2a00      	cmp	r2, #0
2000dcea:	d000      	beq.n	2000dcee <usb_queue_init+0x1e>
2000dcec:	e7fe      	b.n	2000dcec <usb_queue_init+0x1c>
  endpoint_queues[index] = queue;
2000dcee:	50c8      	str	r0, [r1, r3]

  usb_transfer_t* t = queue->free_transfers;
2000dcf0:	6881      	ldr	r1, [r0, #8]
  for (unsigned int i=0; i < queue->pool_size - 1; i++, t++) {
2000dcf2:	6844      	ldr	r4, [r0, #4]
{
  uint32_t index = USB_ENDPOINT_INDEX(queue->endpoint->address);
  if (endpoint_queues[index] != NULL) while (1);
  endpoint_queues[index] = queue;

  usb_transfer_t* t = queue->free_transfers;
2000dcf4:	1c0b      	adds	r3, r1, #0
  for (unsigned int i=0; i < queue->pool_size - 1; i++, t++) {
2000dcf6:	1e65      	subs	r5, r4, #1
2000dcf8:	42aa      	cmp	r2, r5
2000dcfa:	d206      	bcs.n	2000dd0a <usb_queue_init+0x3a>
          t->next = t+1;
2000dcfc:	3380      	adds	r3, #128	; 0x80
  uint32_t index = USB_ENDPOINT_INDEX(endpoint->address);
  if (endpoint_queues[index] == NULL) while (1);
  return endpoint_queues[index];
}

void usb_queue_init(usb_queue_t* const queue)
2000dcfe:	1c1e      	adds	r6, r3, #0
2000dd00:	3e80      	subs	r6, #128	; 0x80
  if (endpoint_queues[index] != NULL) while (1);
  endpoint_queues[index] = queue;

  usb_transfer_t* t = queue->free_transfers;
  for (unsigned int i=0; i < queue->pool_size - 1; i++, t++) {
          t->next = t+1;
2000dd02:	6033      	str	r3, [r6, #0]
          t->queue = queue;
2000dd04:	6670      	str	r0, [r6, #100]	; 0x64
  uint32_t index = USB_ENDPOINT_INDEX(queue->endpoint->address);
  if (endpoint_queues[index] != NULL) while (1);
  endpoint_queues[index] = queue;

  usb_transfer_t* t = queue->free_transfers;
  for (unsigned int i=0; i < queue->pool_size - 1; i++, t++) {
2000dd06:	3201      	adds	r2, #1
2000dd08:	e7f6      	b.n	2000dcf8 <usb_queue_init+0x28>
  uint32_t index = USB_ENDPOINT_INDEX(endpoint->address);
  if (endpoint_queues[index] == NULL) while (1);
  return endpoint_queues[index];
}

void usb_queue_init(usb_queue_t* const queue)
2000dd0a:	4d05      	ldr	r5, [pc, #20]	; (2000dd20 <usb_queue_init+0x50>)
  usb_transfer_t* t = queue->free_transfers;
  for (unsigned int i=0; i < queue->pool_size - 1; i++, t++) {
          t->next = t+1;
          t->queue = queue;
  }
  t->next = NULL;
2000dd0c:	2300      	movs	r3, #0
  uint32_t index = USB_ENDPOINT_INDEX(endpoint->address);
  if (endpoint_queues[index] == NULL) while (1);
  return endpoint_queues[index];
}

void usb_queue_init(usb_queue_t* const queue)
2000dd0e:	1962      	adds	r2, r4, r5
2000dd10:	01d6      	lsls	r6, r2, #7
2000dd12:	198c      	adds	r4, r1, r6
  usb_transfer_t* t = queue->free_transfers;
  for (unsigned int i=0; i < queue->pool_size - 1; i++, t++) {
          t->next = t+1;
          t->queue = queue;
  }
  t->next = NULL;
2000dd14:	6023      	str	r3, [r4, #0]
  t->queue = queue;
2000dd16:	6660      	str	r0, [r4, #100]	; 0x64
}
2000dd18:	bd70      	pop	{r4, r5, r6, pc}
2000dd1a:	46c0      	nop			; (mov r8, r8)
2000dd1c:	2000f344 	.word	0x2000f344
2000dd20:	01ffffff 	.word	0x01ffffff

2000dd24 <usb_queue_flush_endpoint>:
  }
  cm_enable_interrupts();
}

void usb_queue_flush_endpoint(const usb_endpoint_t* const endpoint)
{
2000dd24:	b508      	push	{r3, lr}
  usb_queue_flush_queue(endpoint_queue(endpoint));
2000dd26:	f7ff ffc3 	bl	2000dcb0 <endpoint_queue>
        __asm__("CPSIE I\n");
}

static inline void cm_disable_interrupts(void)
{
        __asm__("CPSID I\n");
2000dd2a:	b672      	cpsid	i
}

static void usb_queue_flush_queue(usb_queue_t* const queue)
{
  cm_disable_interrupts();
  while (queue->active)
2000dd2c:	68c3      	ldr	r3, [r0, #12]
2000dd2e:	2b00      	cmp	r3, #0
2000dd30:	d007      	beq.n	2000dd42 <usb_queue_flush_endpoint+0x1e>
  {
    usb_transfer_t* transfer = queue->active;
2000dd32:	68c3      	ldr	r3, [r0, #12]
    queue->active = transfer->next;
2000dd34:	6819      	ldr	r1, [r3, #0]
}

/* Place a transfer in the free list (nolock or disable IRQ) */
static void free_transfer_nolock(usb_transfer_t* const transfer)
{
  usb_queue_t* const queue = transfer->queue;
2000dd36:	6e5a      	ldr	r2, [r3, #100]	; 0x64
{
  cm_disable_interrupts();
  while (queue->active)
  {
    usb_transfer_t* transfer = queue->active;
    queue->active = transfer->next;
2000dd38:	60c1      	str	r1, [r0, #12]
  do {
          transfer->next = (void *) __ldrex((uint32_t *) &queue->free_transfers);
          aborted = __strex((uint32_t) transfer, (uint32_t *) &queue->free_transfers);
  } while (aborted);
*/
  transfer->next = queue->free_transfers;
2000dd3a:	6891      	ldr	r1, [r2, #8]
2000dd3c:	6019      	str	r1, [r3, #0]
  queue->free_transfers = transfer;
2000dd3e:	6093      	str	r3, [r2, #8]
2000dd40:	e7f4      	b.n	2000dd2c <usb_queue_flush_endpoint+0x8>
#ifndef LIBOPENCM3_CORTEX_H
#define LIBOPENCM3_CORTEX_H

static inline void cm_enable_interrupts(void)
{
        __asm__("CPSIE I\n");
2000dd42:	b662      	cpsie	i
}

void usb_queue_flush_endpoint(const usb_endpoint_t* const endpoint)
{
  usb_queue_flush_queue(endpoint_queue(endpoint));
}
2000dd44:	bd08      	pop	{r3, pc}
	...

2000dd48 <usb_transfer_schedule>:

int usb_transfer_schedule(
  const usb_endpoint_t* const endpoint,
  void* const data,
  const uint32_t maximum_length)
{
2000dd48:	b538      	push	{r3, r4, r5, lr}
2000dd4a:	1c0c      	adds	r4, r1, #0
2000dd4c:	1c15      	adds	r5, r2, #0
  usb_queue_t* const queue = endpoint_queue(endpoint);
2000dd4e:	f7ff ffaf 	bl	2000dcb0 <endpoint_queue>
/*
  bool aborted;
*/
  usb_transfer_t* transfer;

  if (queue->free_transfers == NULL)
2000dd52:	6883      	ldr	r3, [r0, #8]
2000dd54:	2b00      	cmp	r3, #0
2000dd56:	d042      	beq.n	2000ddde <usb_transfer_schedule+0x96>
}

static inline void cm_disable_interrupts(void)
{
        __asm__("CPSID I\n");
2000dd58:	b672      	cpsid	i
          transfer = (void *) __ldrex((uint32_t *) &queue->free_transfers);
          aborted = __strex((uint32_t) transfer->next, (uint32_t *) &queue->free_transfers);
  } while (aborted);
*/
  cm_disable_interrupts();
  transfer = queue->free_transfers;
2000dd5a:	6883      	ldr	r3, [r0, #8]
  queue->free_transfers = transfer->next;
  transfer->next = NULL;
2000dd5c:	2200      	movs	r2, #0
          aborted = __strex((uint32_t) transfer->next, (uint32_t *) &queue->free_transfers);
  } while (aborted);
*/
  cm_disable_interrupts();
  transfer = queue->free_transfers;
  queue->free_transfers = transfer->next;
2000dd5e:	6819      	ldr	r1, [r3, #0]
2000dd60:	6081      	str	r1, [r0, #8]
  transfer->next = NULL;
2000dd62:	601a      	str	r2, [r3, #0]
#ifndef LIBOPENCM3_CORTEX_H
#define LIBOPENCM3_CORTEX_H

static inline void cm_enable_interrupts(void)
{
        __asm__("CPSIE I\n");
2000dd64:	b662      	cpsie	i
  usb_transfer_t* const transfer = allocate_transfer(queue);
  if (transfer == NULL) return -1;
  usb_transfer_descriptor_t* const td = &transfer->td;

  // Configure the transfer descriptor
  td->next_dtd_pointer = USB_TD_NEXT_DTD_POINTER_TERMINATE;
2000dd66:	2101      	movs	r1, #1
2000dd68:	6419      	str	r1, [r3, #64]	; 0x40
  td->total_bytes =
      USB_TD_DTD_TOKEN_TOTAL_BYTES(maximum_length)
    | USB_TD_DTD_TOKEN_IOC
    | USB_TD_DTD_TOKEN_MULTO(0)
    | USB_TD_DTD_TOKEN_STATUS_ACTIVE;
2000dd6a:	491e      	ldr	r1, [pc, #120]	; (2000dde4 <usb_transfer_schedule+0x9c>)
  usb_transfer_descriptor_t* const td = &transfer->td;

  // Configure the transfer descriptor
  td->next_dtd_pointer = USB_TD_NEXT_DTD_POINTER_TERMINATE;
  td->total_bytes =
      USB_TD_DTD_TOKEN_TOTAL_BYTES(maximum_length)
2000dd6c:	042a      	lsls	r2, r5, #16
    | USB_TD_DTD_TOKEN_IOC
    | USB_TD_DTD_TOKEN_MULTO(0)
    | USB_TD_DTD_TOKEN_STATUS_ACTIVE;
2000dd6e:	430a      	orrs	r2, r1
  if (transfer == NULL) return -1;
  usb_transfer_descriptor_t* const td = &transfer->td;

  // Configure the transfer descriptor
  td->next_dtd_pointer = USB_TD_NEXT_DTD_POINTER_TERMINATE;
  td->total_bytes =
2000dd70:	645a      	str	r2, [r3, #68]	; 0x44
      USB_TD_DTD_TOKEN_TOTAL_BYTES(maximum_length)
    | USB_TD_DTD_TOKEN_IOC
    | USB_TD_DTD_TOKEN_MULTO(0)
    | USB_TD_DTD_TOKEN_STATUS_ACTIVE;
  td->buffer_pointer_page[0] =  (uint32_t)data;
  td->buffer_pointer_page[1] = ((uint32_t)data + 0x1000) & 0xfffff000;
2000dd72:	2280      	movs	r2, #128	; 0x80
2000dd74:	0151      	lsls	r1, r2, #5
2000dd76:	1862      	adds	r2, r4, r1
2000dd78:	0b11      	lsrs	r1, r2, #12
2000dd7a:	030a      	lsls	r2, r1, #12
  td->buffer_pointer_page[2] = ((uint32_t)data + 0x2000) & 0xfffff000;
2000dd7c:	2180      	movs	r1, #128	; 0x80
  td->total_bytes =
      USB_TD_DTD_TOKEN_TOTAL_BYTES(maximum_length)
    | USB_TD_DTD_TOKEN_IOC
    | USB_TD_DTD_TOKEN_MULTO(0)
    | USB_TD_DTD_TOKEN_STATUS_ACTIVE;
  td->buffer_pointer_page[0] =  (uint32_t)data;
2000dd7e:	649c      	str	r4, [r3, #72]	; 0x48
  td->buffer_pointer_page[1] = ((uint32_t)data + 0x1000) & 0xfffff000;
2000dd80:	64da      	str	r2, [r3, #76]	; 0x4c
  td->buffer_pointer_page[2] = ((uint32_t)data + 0x2000) & 0xfffff000;
2000dd82:	018a      	lsls	r2, r1, #6
2000dd84:	18a1      	adds	r1, r4, r2
2000dd86:	0b0a      	lsrs	r2, r1, #12
2000dd88:	0311      	lsls	r1, r2, #12
  td->buffer_pointer_page[3] = ((uint32_t)data + 0x3000) & 0xfffff000;
2000dd8a:	22c0      	movs	r2, #192	; 0xc0
    | USB_TD_DTD_TOKEN_IOC
    | USB_TD_DTD_TOKEN_MULTO(0)
    | USB_TD_DTD_TOKEN_STATUS_ACTIVE;
  td->buffer_pointer_page[0] =  (uint32_t)data;
  td->buffer_pointer_page[1] = ((uint32_t)data + 0x1000) & 0xfffff000;
  td->buffer_pointer_page[2] = ((uint32_t)data + 0x2000) & 0xfffff000;
2000dd8c:	6519      	str	r1, [r3, #80]	; 0x50
  td->buffer_pointer_page[3] = ((uint32_t)data + 0x3000) & 0xfffff000;
2000dd8e:	0191      	lsls	r1, r2, #6
2000dd90:	1862      	adds	r2, r4, r1
2000dd92:	0b11      	lsrs	r1, r2, #12
2000dd94:	030a      	lsls	r2, r1, #12
  td->buffer_pointer_page[4] = ((uint32_t)data + 0x4000) & 0xfffff000;
2000dd96:	2180      	movs	r1, #128	; 0x80
    | USB_TD_DTD_TOKEN_MULTO(0)
    | USB_TD_DTD_TOKEN_STATUS_ACTIVE;
  td->buffer_pointer_page[0] =  (uint32_t)data;
  td->buffer_pointer_page[1] = ((uint32_t)data + 0x1000) & 0xfffff000;
  td->buffer_pointer_page[2] = ((uint32_t)data + 0x2000) & 0xfffff000;
  td->buffer_pointer_page[3] = ((uint32_t)data + 0x3000) & 0xfffff000;
2000dd98:	655a      	str	r2, [r3, #84]	; 0x54
  td->buffer_pointer_page[4] = ((uint32_t)data + 0x4000) & 0xfffff000;
2000dd9a:	01ca      	lsls	r2, r1, #7
2000dd9c:	18a4      	adds	r4, r4, r2
2000dd9e:	0b21      	lsrs	r1, r4, #12
2000dda0:	030a      	lsls	r2, r1, #12
2000dda2:	659a      	str	r2, [r3, #88]	; 0x58

  // Fill in transfer fields
  transfer->maximum_length = maximum_length;
2000dda4:	661d      	str	r5, [r3, #96]	; 0x60
}

static inline void cm_disable_interrupts(void)
{
        __asm__("CPSID I\n");
2000dda6:	b672      	cpsid	i
/* Add a transfer to the end of an endpoint's queue. Returns the old
 * tail or NULL is the queue was empty
 */
static usb_transfer_t* endpoint_queue_transfer(usb_transfer_t* const transfer)
{
  usb_queue_t* const queue = transfer->queue;
2000dda8:	6e5d      	ldr	r5, [r3, #100]	; 0x64
  transfer->next = NULL;
  if (queue->active != NULL)
2000ddaa:	68ec      	ldr	r4, [r5, #12]
2000ddac:	2c00      	cmp	r4, #0
2000ddae:	d00d      	beq.n	2000ddcc <usb_transfer_schedule+0x84>
  {
      usb_transfer_t* t = queue->active;
2000ddb0:	68e9      	ldr	r1, [r5, #12]
      while (t->next != NULL) t = t->next;
2000ddb2:	680a      	ldr	r2, [r1, #0]
2000ddb4:	2a00      	cmp	r2, #0
2000ddb6:	d001      	beq.n	2000ddbc <usb_transfer_schedule+0x74>
2000ddb8:	1c11      	adds	r1, r2, #0
2000ddba:	e7fa      	b.n	2000ddb2 <usb_transfer_schedule+0x6a>
  {
    // The queue is currently empty, we need to re-prime
    usb_endpoint_schedule_wait(queue->endpoint, &transfer->td);
  } else {
    // The queue is currently running, try to append
    usb_endpoint_schedule_append(queue->endpoint, &tail->td, &transfer->td);
2000ddbc:	1c1a      	adds	r2, r3, #0
  transfer->next = NULL;
  if (queue->active != NULL)
  {
      usb_transfer_t* t = queue->active;
      while (t->next != NULL) t = t->next;
      t->next = transfer;
2000ddbe:	600b      	str	r3, [r1, #0]
  {
    // The queue is currently empty, we need to re-prime
    usb_endpoint_schedule_wait(queue->endpoint, &transfer->td);
  } else {
    // The queue is currently running, try to append
    usb_endpoint_schedule_append(queue->endpoint, &tail->td, &transfer->td);
2000ddc0:	6800      	ldr	r0, [r0, #0]
2000ddc2:	3140      	adds	r1, #64	; 0x40
2000ddc4:	3240      	adds	r2, #64	; 0x40
2000ddc6:	f7ff fd89 	bl	2000d8dc <usb_endpoint_schedule_append>
2000ddca:	e005      	b.n	2000ddd8 <usb_transfer_schedule+0x90>
  cm_disable_interrupts();
  usb_transfer_t* tail = endpoint_queue_transfer(transfer);
  if (tail == NULL)
  {
    // The queue is currently empty, we need to re-prime
    usb_endpoint_schedule_wait(queue->endpoint, &transfer->td);
2000ddcc:	1c19      	adds	r1, r3, #0
      usb_transfer_t* t = queue->active;
      while (t->next != NULL) t = t->next;
      t->next = transfer;
      return t;
  } else {
      queue->active = transfer;
2000ddce:	60eb      	str	r3, [r5, #12]
  cm_disable_interrupts();
  usb_transfer_t* tail = endpoint_queue_transfer(transfer);
  if (tail == NULL)
  {
    // The queue is currently empty, we need to re-prime
    usb_endpoint_schedule_wait(queue->endpoint, &transfer->td);
2000ddd0:	6800      	ldr	r0, [r0, #0]
2000ddd2:	3140      	adds	r1, #64	; 0x40
2000ddd4:	f7ff fdb6 	bl	2000d944 <usb_endpoint_schedule_wait>
#ifndef LIBOPENCM3_CORTEX_H
#define LIBOPENCM3_CORTEX_H

static inline void cm_enable_interrupts(void)
{
        __asm__("CPSIE I\n");
2000ddd8:	b662      	cpsie	i
  } else {
    // The queue is currently running, try to append
    usb_endpoint_schedule_append(queue->endpoint, &tail->td, &transfer->td);
  }
  cm_enable_interrupts();
  return 0;
2000ddda:	2000      	movs	r0, #0
2000dddc:	e001      	b.n	2000dde2 <usb_transfer_schedule+0x9a>
  void* const data,
  const uint32_t maximum_length)
{
  usb_queue_t* const queue = endpoint_queue(endpoint);
  usb_transfer_t* const transfer = allocate_transfer(queue);
  if (transfer == NULL) return -1;
2000ddde:	2001      	movs	r0, #1
2000dde0:	4240      	negs	r0, r0
    // The queue is currently running, try to append
    usb_endpoint_schedule_append(queue->endpoint, &tail->td, &transfer->td);
  }
  cm_enable_interrupts();
  return 0;
}
2000dde2:	bd38      	pop	{r3, r4, r5, pc}
2000dde4:	00008080 	.word	0x00008080

2000dde8 <usb_transfer_schedule_block>:

int usb_transfer_schedule_block(
  const usb_endpoint_t* const endpoint,
  void* const data,
  const uint32_t maximum_length)
{
2000dde8:	b570      	push	{r4, r5, r6, lr}
2000ddea:	1c06      	adds	r6, r0, #0
2000ddec:	1c0d      	adds	r5, r1, #0
2000ddee:	1c14      	adds	r4, r2, #0
  int ret;
  do
  {
    ret = usb_transfer_schedule(endpoint, data, maximum_length);
2000ddf0:	1c30      	adds	r0, r6, #0
2000ddf2:	1c29      	adds	r1, r5, #0
2000ddf4:	1c22      	adds	r2, r4, #0
2000ddf6:	f7ff ffa7 	bl	2000dd48 <usb_transfer_schedule>
  } while (ret == -1);
2000ddfa:	3001      	adds	r0, #1
2000ddfc:	d0f8      	beq.n	2000ddf0 <usb_transfer_schedule_block+0x8>
  return 0;
}
2000ddfe:	2000      	movs	r0, #0
2000de00:	bd70      	pop	{r4, r5, r6, pc}

2000de02 <usb_transfer_schedule_ack>:

int usb_transfer_schedule_ack(const usb_endpoint_t* const endpoint)
{
2000de02:	b508      	push	{r3, lr}
  return usb_transfer_schedule_block(endpoint, 0, 0);
2000de04:	2100      	movs	r1, #0
2000de06:	1c0a      	adds	r2, r1, #0
2000de08:	f7ff ffee 	bl	2000dde8 <usb_transfer_schedule_block>
}
2000de0c:	bd08      	pop	{r3, pc}

2000de0e <usb_queue_transfer_complete>:

/* Called when an endpoint might have completed a transfer */
void usb_queue_transfer_complete(usb_endpoint_t* const endpoint)
{
2000de0e:	b510      	push	{r4, lr}
  usb_queue_t* const queue = endpoint_queue(endpoint);
2000de10:	f7ff ff4e 	bl	2000dcb0 <endpoint_queue>
  if (queue == NULL) while(1); // Uh oh
2000de14:	2800      	cmp	r0, #0
2000de16:	d100      	bne.n	2000de1a <usb_queue_transfer_complete+0xc>
2000de18:	e7fe      	b.n	2000de18 <usb_queue_transfer_complete+0xa>
  usb_transfer_t* transfer = queue->active;
2000de1a:	68c3      	ldr	r3, [r0, #12]

  while (transfer != NULL)
2000de1c:	2b00      	cmp	r3, #0
2000de1e:	d010      	beq.n	2000de42 <usb_queue_transfer_complete+0x34>
  {
    uint8_t status = transfer->td.total_bytes;
2000de20:	6c5a      	ldr	r2, [r3, #68]	; 0x44

    // Check for failures
    if (status & USB_TD_DTD_TOKEN_STATUS_HALTED
        || status & USB_TD_DTD_TOKEN_STATUS_BUFFER_ERROR
        || status & USB_TD_DTD_TOKEN_STATUS_TRANSACTION_ERROR)
2000de22:	2168      	movs	r1, #104	; 0x68
2000de24:	420a      	tst	r2, r1
2000de26:	d000      	beq.n	2000de2a <usb_queue_transfer_complete+0x1c>
2000de28:	e7fe      	b.n	2000de28 <usb_queue_transfer_complete+0x1a>
      // TODO: Uh oh, do something useful here
      while (1);
    }

    // Still not finished
    if (status & USB_TD_DTD_TOKEN_STATUS_ACTIVE)
2000de2a:	0611      	lsls	r1, r2, #24
2000de2c:	d409      	bmi.n	2000de42 <usb_queue_transfer_complete+0x34>
            break;

    // Advance the head.
    queue->active = transfer->next;
2000de2e:	681a      	ldr	r2, [r3, #0]
}

/* Place a transfer in the free list */
static void free_transfer(usb_transfer_t* const transfer)
{
        usb_queue_t* const queue = transfer->queue;
2000de30:	6e59      	ldr	r1, [r3, #100]	; 0x64
    // Still not finished
    if (status & USB_TD_DTD_TOKEN_STATUS_ACTIVE)
            break;

    // Advance the head.
    queue->active = transfer->next;
2000de32:	60c2      	str	r2, [r0, #12]
}

static inline void cm_disable_interrupts(void)
{
        __asm__("CPSID I\n");
2000de34:	b672      	cpsid	i
          transfer->next = (void *) __ldrex((uint32_t *) &queue->free_transfers);
          aborted = __strex((uint32_t) transfer, (uint32_t *) &queue->free_transfers);
  } while (aborted);
*/
  cm_disable_interrupts();
  transfer->next = queue->free_transfers;
2000de36:	688c      	ldr	r4, [r1, #8]
2000de38:	601c      	str	r4, [r3, #0]
  queue->free_transfers = transfer;
2000de3a:	608b      	str	r3, [r1, #8]
#ifndef LIBOPENCM3_CORTEX_H
#define LIBOPENCM3_CORTEX_H

static inline void cm_enable_interrupts(void)
{
        __asm__("CPSIE I\n");
2000de3c:	b662      	cpsie	i
    queue->active = transfer->next;
    usb_transfer_t* next = transfer->next;

    // Free transfer
    free_transfer(transfer);
    transfer = next;
2000de3e:	1c13      	adds	r3, r2, #0
2000de40:	e7ec      	b.n	2000de1c <usb_queue_transfer_complete+0xe>
  }
}
2000de42:	bd10      	pop	{r4, pc}

2000de44 <usb_request>:
#include <stdbool.h>

static void usb_request(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
2000de44:	b510      	push	{r4, lr}
  usb_request_status_t status = USB_REQUEST_STATUS_STALL;
  usb_request_handler_fn handler = 0;

  switch( endpoint->setup.request_type & USB_SETUP_REQUEST_TYPE_mask )
2000de46:	7802      	ldrb	r2, [r0, #0]
2000de48:	2360      	movs	r3, #96	; 0x60
#include <stdbool.h>

static void usb_request(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
2000de4a:	1c04      	adds	r4, r0, #0
  usb_request_status_t status = USB_REQUEST_STATUS_STALL;
  usb_request_handler_fn handler = 0;

  switch( endpoint->setup.request_type & USB_SETUP_REQUEST_TYPE_mask )
2000de4c:	4013      	ands	r3, r2
2000de4e:	2b40      	cmp	r3, #64	; 0x40
2000de50:	d00f      	beq.n	2000de72 <usb_request+0x2e>
2000de52:	d806      	bhi.n	2000de62 <usb_request+0x1e>
2000de54:	2b00      	cmp	r3, #0
2000de56:	d009      	beq.n	2000de6c <usb_request+0x28>
2000de58:	2b20      	cmp	r3, #32
2000de5a:	d112      	bne.n	2000de82 <usb_request+0x3e>
    case USB_SETUP_REQUEST_TYPE_STANDARD:
      handler = usb_request_handlers.standard;
      break;

    case USB_SETUP_REQUEST_TYPE_CLASS:
      handler = usb_request_handlers.class;
2000de5c:	480b      	ldr	r0, [pc, #44]	; (2000de8c <usb_request+0x48>)
2000de5e:	6842      	ldr	r2, [r0, #4]
      break;
2000de60:	e009      	b.n	2000de76 <usb_request+0x32>
  const usb_transfer_stage_t stage)
{
  usb_request_status_t status = USB_REQUEST_STATUS_STALL;
  usb_request_handler_fn handler = 0;

  switch( endpoint->setup.request_type & USB_SETUP_REQUEST_TYPE_mask )
2000de62:	2b60      	cmp	r3, #96	; 0x60
2000de64:	d10d      	bne.n	2000de82 <usb_request+0x3e>
    case USB_SETUP_REQUEST_TYPE_VENDOR:
      handler = usb_request_handlers.vendor;
      break;

    case USB_SETUP_REQUEST_TYPE_RESERVED:
      handler = usb_request_handlers.reserved;
2000de66:	4b09      	ldr	r3, [pc, #36]	; (2000de8c <usb_request+0x48>)
2000de68:	68da      	ldr	r2, [r3, #12]
      break;
2000de6a:	e004      	b.n	2000de76 <usb_request+0x32>
  usb_request_handler_fn handler = 0;

  switch( endpoint->setup.request_type & USB_SETUP_REQUEST_TYPE_mask )
  {
    case USB_SETUP_REQUEST_TYPE_STANDARD:
      handler = usb_request_handlers.standard;
2000de6c:	4a07      	ldr	r2, [pc, #28]	; (2000de8c <usb_request+0x48>)
2000de6e:	6812      	ldr	r2, [r2, #0]
      break;
2000de70:	e001      	b.n	2000de76 <usb_request+0x32>
    case USB_SETUP_REQUEST_TYPE_CLASS:
      handler = usb_request_handlers.class;
      break;

    case USB_SETUP_REQUEST_TYPE_VENDOR:
      handler = usb_request_handlers.vendor;
2000de72:	4806      	ldr	r0, [pc, #24]	; (2000de8c <usb_request+0x48>)
2000de74:	6882      	ldr	r2, [r0, #8]
    case USB_SETUP_REQUEST_TYPE_RESERVED:
      handler = usb_request_handlers.reserved;
      break;
  }

  if( handler ) {
2000de76:	2a00      	cmp	r2, #0
2000de78:	d003      	beq.n	2000de82 <usb_request+0x3e>
    status = handler(endpoint, stage);
2000de7a:	1c20      	adds	r0, r4, #0
2000de7c:	4790      	blx	r2
  }

  if( status != USB_REQUEST_STATUS_OK ) {
2000de7e:	2800      	cmp	r0, #0
2000de80:	d002      	beq.n	2000de88 <usb_request+0x44>
    // USB 2.0 section 9.2.7 "Request Error"
    usb_endpoint_stall(endpoint);
2000de82:	1c20      	adds	r0, r4, #0
2000de84:	f7ff fd6e 	bl	2000d964 <usb_endpoint_stall>
  }
}
2000de88:	bd10      	pop	{r4, pc}
2000de8a:	46c0      	nop			; (mov r8, r8)
2000de8c:	2000e97c 	.word	0x2000e97c

2000de90 <usb_setup_complete>:

void usb_setup_complete(usb_endpoint_t* const endpoint)
{
2000de90:	b508      	push	{r3, lr}
  usb_request(endpoint, USB_TRANSFER_STAGE_SETUP);
2000de92:	2100      	movs	r1, #0
2000de94:	f7ff ffd6 	bl	2000de44 <usb_request>
}
2000de98:	bd08      	pop	{r3, pc}

2000de9a <usb_control_out_complete>:

void usb_control_out_complete(usb_endpoint_t* const endpoint)
{
2000de9a:	b510      	push	{r4, lr}
  const bool device_to_host =
    endpoint->setup.request_type >> USB_SETUP_REQUEST_TYPE_DATA_TRANSFER_DIRECTION_shift;
2000de9c:	7803      	ldrb	r3, [r0, #0]
{
  usb_request(endpoint, USB_TRANSFER_STAGE_SETUP);
}

void usb_control_out_complete(usb_endpoint_t* const endpoint)
{
2000de9e:	1c04      	adds	r4, r0, #0
  const bool device_to_host =
    endpoint->setup.request_type >> USB_SETUP_REQUEST_TYPE_DATA_TRANSFER_DIRECTION_shift;
  if( device_to_host ) {
2000dea0:	09da      	lsrs	r2, r3, #7
    usb_request(endpoint, USB_TRANSFER_STAGE_STATUS);
2000dea2:	2102      	movs	r1, #2

void usb_control_out_complete(usb_endpoint_t* const endpoint)
{
  const bool device_to_host =
    endpoint->setup.request_type >> USB_SETUP_REQUEST_TYPE_DATA_TRANSFER_DIRECTION_shift;
  if( device_to_host ) {
2000dea4:	2a00      	cmp	r2, #0
2000dea6:	d100      	bne.n	2000deaa <usb_control_out_complete+0x10>
    usb_request(endpoint, USB_TRANSFER_STAGE_STATUS);
  } else {
    usb_request(endpoint, USB_TRANSFER_STAGE_DATA);
2000dea8:	2101      	movs	r1, #1
2000deaa:	f7ff ffcb 	bl	2000de44 <usb_request>
  }
        usb_queue_transfer_complete(endpoint);
2000deae:	1c20      	adds	r0, r4, #0
2000deb0:	f7ff ffad 	bl	2000de0e <usb_queue_transfer_complete>
}
2000deb4:	bd10      	pop	{r4, pc}

2000deb6 <usb_control_in_complete>:

void usb_control_in_complete(usb_endpoint_t* const endpoint)
{
2000deb6:	b510      	push	{r4, lr}
  const bool device_to_host =
    endpoint->setup.request_type >> USB_SETUP_REQUEST_TYPE_DATA_TRANSFER_DIRECTION_shift;
2000deb8:	7803      	ldrb	r3, [r0, #0]
  }
        usb_queue_transfer_complete(endpoint);
}

void usb_control_in_complete(usb_endpoint_t* const endpoint)
{
2000deba:	1c04      	adds	r4, r0, #0
  const bool device_to_host =
    endpoint->setup.request_type >> USB_SETUP_REQUEST_TYPE_DATA_TRANSFER_DIRECTION_shift;
  if( device_to_host ) {
2000debc:	09da      	lsrs	r2, r3, #7
    usb_request(endpoint, USB_TRANSFER_STAGE_DATA);
2000debe:	2101      	movs	r1, #1

void usb_control_in_complete(usb_endpoint_t* const endpoint)
{
  const bool device_to_host =
    endpoint->setup.request_type >> USB_SETUP_REQUEST_TYPE_DATA_TRANSFER_DIRECTION_shift;
  if( device_to_host ) {
2000dec0:	2a00      	cmp	r2, #0
2000dec2:	d100      	bne.n	2000dec6 <usb_control_in_complete+0x10>
    usb_request(endpoint, USB_TRANSFER_STAGE_DATA);
  } else {
    usb_request(endpoint, USB_TRANSFER_STAGE_STATUS);
2000dec4:	2102      	movs	r1, #2
2000dec6:	f7ff ffbd 	bl	2000de44 <usb_request>
  }
  usb_queue_transfer_complete(endpoint);
2000deca:	1c20      	adds	r0, r4, #0
2000decc:	f7ff ff9f 	bl	2000de0e <usb_queue_transfer_complete>
}
2000ded0:	bd10      	pop	{r4, pc}

2000ded2 <usb_send_descriptor>:
}

static usb_request_status_t usb_send_descriptor(
  usb_endpoint_t* const endpoint,
  const uint8_t* const descriptor_data)
{
2000ded2:	b510      	push	{r4, lr}
2000ded4:	1c04      	adds	r4, r0, #0
  const uint32_t setup_length = endpoint->setup.length;
2000ded6:	88c3      	ldrh	r3, [r0, #6]
  uint32_t descriptor_length = descriptor_data[0];
  if ( ( descriptor_data[1] == USB_DESCRIPTOR_TYPE_CONFIGURATION ) ||
2000ded8:	7848      	ldrb	r0, [r1, #1]
static usb_request_status_t usb_send_descriptor(
  usb_endpoint_t* const endpoint,
  const uint8_t* const descriptor_data)
{
  const uint32_t setup_length = endpoint->setup.length;
  uint32_t descriptor_length = descriptor_data[0];
2000deda:	780a      	ldrb	r2, [r1, #0]
  if ( ( descriptor_data[1] == USB_DESCRIPTOR_TYPE_CONFIGURATION ) ||
2000dedc:	2802      	cmp	r0, #2
2000dede:	d001      	beq.n	2000dee4 <usb_send_descriptor+0x12>
2000dee0:	2807      	cmp	r0, #7
2000dee2:	d103      	bne.n	2000deec <usb_send_descriptor+0x1a>
        ( descriptor_data[1] == USB_DESCRIPTOR_TYPE_OTHER_SPEED_CONFIGURATION ) )
  {
    descriptor_length = (descriptor_data[3] << 8) | descriptor_data[2];
2000dee4:	78ca      	ldrb	r2, [r1, #3]
2000dee6:	7888      	ldrb	r0, [r1, #2]
2000dee8:	0212      	lsls	r2, r2, #8
2000deea:	4302      	orrs	r2, r0
  }
  // We cast the const away but this shouldn't be a problem as this is a write transfer
  usb_transfer_schedule_block(
2000deec:	69a0      	ldr	r0, [r4, #24]
2000deee:	429a      	cmp	r2, r3
2000def0:	d900      	bls.n	2000def4 <usb_send_descriptor+0x22>
2000def2:	1c1a      	adds	r2, r3, #0
2000def4:	f7ff ff78 	bl	2000dde8 <usb_transfer_schedule_block>
    endpoint->in,
    (uint8_t* const) descriptor_data,
    (setup_length > descriptor_length) ? descriptor_length : setup_length);
  usb_transfer_schedule_ack(endpoint->out);
2000def8:	69e0      	ldr	r0, [r4, #28]
2000defa:	f7ff ff82 	bl	2000de02 <usb_transfer_schedule_ack>
  return USB_REQUEST_STATUS_OK;
}
2000defe:	2000      	movs	r0, #0
2000df00:	bd10      	pop	{r4, pc}

2000df02 <usb_send_descriptor_config>:
static usb_request_status_t usb_send_descriptor_config(
  usb_endpoint_t* const endpoint,
  usb_speed_t speed,
  const uint8_t config_num)
{
  usb_configuration_t** config = *(endpoint->device->configurations);
2000df02:	6943      	ldr	r3, [r0, #20]

static usb_request_status_t usb_send_descriptor_config(
  usb_endpoint_t* const endpoint,
  usb_speed_t speed,
  const uint8_t config_num)
{
2000df04:	b570      	push	{r4, r5, r6, lr}
2000df06:	68dd      	ldr	r5, [r3, #12]
  usb_configuration_t** config = *(endpoint->device->configurations);
  unsigned int i = 0;
2000df08:	2400      	movs	r4, #0
  for( ; *config != NULL; config++ )
2000df0a:	cd08      	ldmia	r5!, {r3}
2000df0c:	2b00      	cmp	r3, #0
2000df0e:	d00a      	beq.n	2000df26 <usb_send_descriptor_config+0x24>
  {
    if( (*config)->speed == speed)
2000df10:	7a1e      	ldrb	r6, [r3, #8]
2000df12:	428e      	cmp	r6, r1
2000df14:	d1f9      	bne.n	2000df0a <usb_send_descriptor_config+0x8>
    {
      if (i == config_num)
2000df16:	4294      	cmp	r4, r2
2000df18:	d103      	bne.n	2000df22 <usb_send_descriptor_config+0x20>
      {
        return usb_send_descriptor(endpoint, (*config)->descriptor);
2000df1a:	6819      	ldr	r1, [r3, #0]
2000df1c:	f7ff ffd9 	bl	2000ded2 <usb_send_descriptor>
2000df20:	e002      	b.n	2000df28 <usb_send_descriptor_config+0x26>
      } else {
        i++;
2000df22:	3401      	adds	r4, #1
2000df24:	e7f1      	b.n	2000df0a <usb_send_descriptor_config+0x8>
      }
    }
  }
  return USB_REQUEST_STATUS_STALL;
2000df26:	2001      	movs	r0, #1
}
2000df28:	bd70      	pop	{r4, r5, r6, pc}

2000df2a <usb_endpoint_descriptor>:
  return (endpoint_address & 0xF);
}

const uint8_t* usb_endpoint_descriptor(const usb_endpoint_t* const endpoint)
{
  const usb_configuration_t* const configuration = endpoint->device->configuration;
2000df2a:	6943      	ldr	r3, [r0, #20]
{
  return (endpoint_address & 0xF);
}

const uint8_t* usb_endpoint_descriptor(const usb_endpoint_t* const endpoint)
{
2000df2c:	b510      	push	{r4, lr}
  const usb_configuration_t* const configuration = endpoint->device->configuration;
2000df2e:	691b      	ldr	r3, [r3, #16]
{
  return (endpoint_address & 0xF);
}

const uint8_t* usb_endpoint_descriptor(const usb_endpoint_t* const endpoint)
{
2000df30:	1c02      	adds	r2, r0, #0
  const usb_configuration_t* const configuration = endpoint->device->configuration;
  if( configuration )
2000df32:	2b00      	cmp	r3, #0
2000df34:	d00c      	beq.n	2000df50 <usb_endpoint_descriptor+0x26>
  {
    const uint8_t* descriptor = configuration->descriptor;
2000df36:	6818      	ldr	r0, [r3, #0]
    while( descriptor[0] != 0 )
2000df38:	7803      	ldrb	r3, [r0, #0]
2000df3a:	2b00      	cmp	r3, #0
2000df3c:	d008      	beq.n	2000df50 <usb_endpoint_descriptor+0x26>
    {
      if( descriptor[1] == USB_DESCRIPTOR_TYPE_ENDPOINT )
2000df3e:	7841      	ldrb	r1, [r0, #1]
2000df40:	2905      	cmp	r1, #5
2000df42:	d103      	bne.n	2000df4c <usb_endpoint_descriptor+0x22>
      {
        if( descriptor[2] == endpoint->address ) {
2000df44:	7881      	ldrb	r1, [r0, #2]
2000df46:	6914      	ldr	r4, [r2, #16]
2000df48:	42a1      	cmp	r1, r4
2000df4a:	d002      	beq.n	2000df52 <usb_endpoint_descriptor+0x28>
          return descriptor;
        }
      }
      descriptor += descriptor[0];
2000df4c:	18c0      	adds	r0, r0, r3
2000df4e:	e7f3      	b.n	2000df38 <usb_endpoint_descriptor+0xe>
    }
  }

  return 0;
2000df50:	1c18      	adds	r0, r3, #0
}
2000df52:	bd10      	pop	{r4, pc}

2000df54 <usb_endpoint_descriptor_max_packet_size>:

uint_fast16_t usb_endpoint_descriptor_max_packet_size(const uint8_t* const endpoint_descriptor)
{
  return (endpoint_descriptor[5] << 8) | endpoint_descriptor[4];
2000df54:	7942      	ldrb	r2, [r0, #5]
2000df56:	7903      	ldrb	r3, [r0, #4]
2000df58:	0211      	lsls	r1, r2, #8
2000df5a:	1c08      	adds	r0, r1, #0
2000df5c:	4318      	orrs	r0, r3
}
2000df5e:	4770      	bx	lr

2000df60 <usb_endpoint_descriptor_transfer_type>:

usb_transfer_type_t usb_endpoint_descriptor_transfer_type(const uint8_t* const endpoint_descriptor)
{
  return (endpoint_descriptor[3] & 0x3);
2000df60:	78c0      	ldrb	r0, [r0, #3]
2000df62:	2303      	movs	r3, #3
2000df64:	4018      	ands	r0, r3
}
2000df66:	4770      	bx	lr

2000df68 <usb_set_configuration_changed_cb>:

void (*usb_configuration_changed_cb)(usb_device_t* const) = NULL;

void usb_set_configuration_changed_cb(void (*callback)(usb_device_t* const))
{
  usb_configuration_changed_cb = callback;
2000df68:	4b01      	ldr	r3, [pc, #4]	; (2000df70 <usb_set_configuration_changed_cb+0x8>)
2000df6a:	6018      	str	r0, [r3, #0]
}
2000df6c:	4770      	bx	lr
2000df6e:	46c0      	nop			; (mov r8, r8)
2000df70:	2000f374 	.word	0x2000f374

2000df74 <usb_set_configuration>:

bool usb_set_configuration(
  usb_device_t* const device,
  const uint_fast8_t configuration_number)
{
2000df74:	b570      	push	{r4, r5, r6, lr}
2000df76:	1c04      	adds	r4, r0, #0
2000df78:	1e0d      	subs	r5, r1, #0
  const usb_configuration_t* new_configuration = 0;
  if( configuration_number != 0 )
2000df7a:	d00e      	beq.n	2000df9a <usb_set_configuration+0x26>
  {
    // Locate requested configuration.
    if( device->configurations )
2000df7c:	68c6      	ldr	r6, [r0, #12]
2000df7e:	2e00      	cmp	r6, #0
2000df80:	d018      	beq.n	2000dfb4 <usb_set_configuration+0x40>
    {
      usb_configuration_t** configurations = *(device->configurations);
      uint32_t i = 0;
      const usb_speed_t usb_speed_current = usb_speed(device);
2000df82:	f7ff fcff 	bl	2000d984 <usb_speed>
      while( configurations[i] )
2000df86:	ce08      	ldmia	r6!, {r3}
2000df88:	2b00      	cmp	r3, #0
2000df8a:	d013      	beq.n	2000dfb4 <usb_set_configuration+0x40>
      {
        if( (configurations[i]->speed == usb_speed_current) &&
2000df8c:	7a1a      	ldrb	r2, [r3, #8]
2000df8e:	4282      	cmp	r2, r0
2000df90:	d1f9      	bne.n	2000df86 <usb_set_configuration+0x12>
2000df92:	6859      	ldr	r1, [r3, #4]
2000df94:	42a9      	cmp	r1, r5
2000df96:	d1f6      	bne.n	2000df86 <usb_set_configuration+0x12>
2000df98:	e000      	b.n	2000df9c <usb_set_configuration+0x28>

bool usb_set_configuration(
  usb_device_t* const device,
  const uint_fast8_t configuration_number)
{
  const usb_configuration_t* new_configuration = 0;
2000df9a:	1c0b      	adds	r3, r1, #0
    if( new_configuration == 0 ) {
      return false;
    }
  }

  if( new_configuration != device->configuration ) {
2000df9c:	6920      	ldr	r0, [r4, #16]
2000df9e:	4283      	cmp	r3, r0
2000dfa0:	d000      	beq.n	2000dfa4 <usb_set_configuration+0x30>
    // Configuration changed.
    device->configuration = new_configuration;
2000dfa2:	6123      	str	r3, [r4, #16]
  }

  if (usb_configuration_changed_cb)
2000dfa4:	4b04      	ldr	r3, [pc, #16]	; (2000dfb8 <usb_set_configuration+0x44>)
2000dfa6:	681d      	ldr	r5, [r3, #0]
2000dfa8:	2d00      	cmp	r5, #0
2000dfaa:	d001      	beq.n	2000dfb0 <usb_set_configuration+0x3c>
    usb_configuration_changed_cb(device);
2000dfac:	1c20      	adds	r0, r4, #0
2000dfae:	47a8      	blx	r5

  return true;
2000dfb0:	2001      	movs	r0, #1
2000dfb2:	e000      	b.n	2000dfb6 <usb_set_configuration+0x42>
      }
    }

    // Requested configuration not found: request error.
    if( new_configuration == 0 ) {
      return false;
2000dfb4:	2000      	movs	r0, #0

  if (usb_configuration_changed_cb)
    usb_configuration_changed_cb(device);

  return true;
}
2000dfb6:	bd70      	pop	{r4, r5, r6, pc}
2000dfb8:	2000f374 	.word	0x2000f374

2000dfbc <usb_standard_request>:
/*********************************************************************/

usb_request_status_t usb_standard_request(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
2000dfbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000dfbe:	1c04      	adds	r4, r0, #0
  switch( endpoint->setup.request )
2000dfc0:	7840      	ldrb	r0, [r0, #1]
/*********************************************************************/

usb_request_status_t usb_standard_request(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
2000dfc2:	1c0e      	adds	r6, r1, #0
  switch( endpoint->setup.request )
2000dfc4:	280b      	cmp	r0, #11
2000dfc6:	d900      	bls.n	2000dfca <usb_standard_request+0xe>
2000dfc8:	e0ea      	b.n	2000e1a0 <usb_standard_request+0x1e4>
2000dfca:	f000 fb93 	bl	2000e6f4 <__gnu_thumb1_case_uqi>
2000dfce:	2a06      	.short	0x2a06
2000dfd0:	afe93ee9 	.word	0xafe93ee9
2000dfd4:	bacce970 	.word	0xbacce970
2000dfd8:	6353      	.short	0x6353
  {
    case USB_STANDARD_REQUEST_GET_STATUS:
      return usb_standard_request_get_status(endpoint, stage);
2000dfda:	2500      	movs	r5, #0
}
static usb_request_status_t usb_standard_request_get_status(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
  if (stage == USB_TRANSFER_STAGE_SETUP)
2000dfdc:	42a9      	cmp	r1, r5
2000dfde:	d000      	beq.n	2000dfe2 <usb_standard_request+0x26>
2000dfe0:	e0df      	b.n	2000e1a2 <usb_standard_request+0x1e6>
  {
    switch (endpoint->setup.request_type & USB_SETUP_REQUEST_TYPE_RECIPIENT_mask)
2000dfe2:	7822      	ldrb	r2, [r4, #0]
2000dfe4:	211f      	movs	r1, #31
2000dfe6:	400a      	ands	r2, r1
2000dfe8:	2a01      	cmp	r2, #1
2000dfea:	d016      	beq.n	2000e01a <usb_standard_request+0x5e>
2000dfec:	42aa      	cmp	r2, r5
2000dfee:	d011      	beq.n	2000e014 <usb_standard_request+0x58>
2000dff0:	2a02      	cmp	r2, #2
2000dff2:	d000      	beq.n	2000dff6 <usb_standard_request+0x3a>
2000dff4:	e0d5      	b.n	2000e1a2 <usb_standard_request+0x1e6>
uint8_t   USB_CurrentInterface = 0; //Bit 0 = SelfPowerred, Bit=1 Remote Wakeup
uint16_t  USB_EpStatus;

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000dff6:	88a7      	ldrh	r7, [r4, #4]
  }
}
static usb_request_status_t usb_standard_request_get_status_endpoint(usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->setup.index);
  USB_EpStatus = (USB0_ENDPTCTRL(endpoint_number) & (USB0_ENDPTCTRL_RXS | USB0_ENDPTCTRL_TXS)) ? 1 : 0;
2000dff8:	486b      	ldr	r0, [pc, #428]	; (2000e1a8 <usb_standard_request+0x1ec>)
uint8_t   USB_CurrentInterface = 0; //Bit 0 = SelfPowerred, Bit=1 Remote Wakeup
uint16_t  USB_EpStatus;

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000dffa:	230f      	movs	r3, #15
2000dffc:	403b      	ands	r3, r7
  }
}
static usb_request_status_t usb_standard_request_get_status_endpoint(usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->setup.index);
  USB_EpStatus = (USB0_ENDPTCTRL(endpoint_number) & (USB0_ENDPTCTRL_RXS | USB0_ENDPTCTRL_TXS)) ? 1 : 0;
2000dffe:	181e      	adds	r6, r3, r0
2000e000:	00b1      	lsls	r1, r6, #2
2000e002:	680f      	ldr	r7, [r1, #0]
2000e004:	4b69      	ldr	r3, [pc, #420]	; (2000e1ac <usb_standard_request+0x1f0>)
2000e006:	496a      	ldr	r1, [pc, #424]	; (2000e1b0 <usb_standard_request+0x1f4>)
2000e008:	403b      	ands	r3, r7
2000e00a:	1e58      	subs	r0, r3, #1
2000e00c:	4183      	sbcs	r3, r0
2000e00e:	800b      	strh	r3, [r1, #0]
  usb_transfer_schedule_block(endpoint->in, &USB_EpStatus, 2);
2000e010:	69a0      	ldr	r0, [r4, #24]
2000e012:	e03b      	b.n	2000e08c <usb_standard_request+0xd0>
  if (stage == USB_TRANSFER_STAGE_SETUP)
  {
    switch (endpoint->setup.request_type & USB_SETUP_REQUEST_TYPE_RECIPIENT_mask)
    {
      case USB_SETUP_REQUEST_TYPE_RECIPIENT_DEVICE:
        usb_transfer_schedule_block(endpoint->in, &USB_DeviceStatus, 2);
2000e014:	69a0      	ldr	r0, [r4, #24]
2000e016:	4967      	ldr	r1, [pc, #412]	; (2000e1b4 <usb_standard_request+0x1f8>)
2000e018:	e001      	b.n	2000e01e <usb_standard_request+0x62>
        usb_transfer_schedule_ack(endpoint->out);
        return USB_REQUEST_STATUS_OK;
        break;
      case USB_SETUP_REQUEST_TYPE_RECIPIENT_INTERFACE:
        usb_transfer_schedule_block(endpoint->in, &USB_InterfaceStatus, 2);
2000e01a:	69a0      	ldr	r0, [r4, #24]
2000e01c:	4966      	ldr	r1, [pc, #408]	; (2000e1b8 <usb_standard_request+0x1fc>)
2000e01e:	2202      	movs	r2, #2
2000e020:	e034      	b.n	2000e08c <usb_standard_request+0xd0>
  const usb_transfer_stage_t stage)
{
  switch( endpoint->setup.request )
  {
    case USB_STANDARD_REQUEST_GET_STATUS:
      return usb_standard_request_get_status(endpoint, stage);
2000e022:	2500      	movs	r5, #0

static usb_request_status_t usb_standard_request_clear_feature(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
  if (stage == USB_TRANSFER_STAGE_SETUP)
2000e024:	42a9      	cmp	r1, r5
2000e026:	d000      	beq.n	2000e02a <usb_standard_request+0x6e>
2000e028:	e0bb      	b.n	2000e1a2 <usb_standard_request+0x1e6>
  {
    switch (endpoint->setup.request_type & USB_SETUP_REQUEST_TYPE_RECIPIENT_mask)
2000e02a:	7822      	ldrb	r2, [r4, #0]
2000e02c:	211f      	movs	r1, #31
2000e02e:	4011      	ands	r1, r2
2000e030:	2902      	cmp	r1, #2
2000e032:	d000      	beq.n	2000e036 <usb_standard_request+0x7a>
2000e034:	e0b5      	b.n	2000e1a2 <usb_standard_request+0x1e6>
uint8_t   USB_CurrentInterface = 0; //Bit 0 = SelfPowerred, Bit=1 Remote Wakeup
uint16_t  USB_EpStatus;

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000e036:	88a7      	ldrh	r7, [r4, #4]

static usb_request_status_t usb_standard_request_clear_feature_endpoint(
  usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->setup.index);
  USB0_ENDPTCTRL(endpoint_number) &= ~(USB0_ENDPTCTRL_RXS | USB0_ENDPTCTRL_TXS);
2000e038:	485b      	ldr	r0, [pc, #364]	; (2000e1a8 <usb_standard_request+0x1ec>)
uint8_t   USB_CurrentInterface = 0; //Bit 0 = SelfPowerred, Bit=1 Remote Wakeup
uint16_t  USB_EpStatus;

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000e03a:	230f      	movs	r3, #15
2000e03c:	403b      	ands	r3, r7

static usb_request_status_t usb_standard_request_clear_feature_endpoint(
  usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->setup.index);
  USB0_ENDPTCTRL(endpoint_number) &= ~(USB0_ENDPTCTRL_RXS | USB0_ENDPTCTRL_TXS);
2000e03e:	181e      	adds	r6, r3, r0
2000e040:	00b7      	lsls	r7, r6, #2
2000e042:	683a      	ldr	r2, [r7, #0]
2000e044:	485d      	ldr	r0, [pc, #372]	; (2000e1bc <usb_standard_request+0x200>)
2000e046:	4010      	ands	r0, r2
2000e048:	e012      	b.n	2000e070 <usb_standard_request+0xb4>
  const usb_transfer_stage_t stage)
{
  switch( endpoint->setup.request )
  {
    case USB_STANDARD_REQUEST_GET_STATUS:
      return usb_standard_request_get_status(endpoint, stage);
2000e04a:	2500      	movs	r5, #0

static usb_request_status_t usb_standard_request_set_feature(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
  if (stage == USB_TRANSFER_STAGE_SETUP)
2000e04c:	42a9      	cmp	r1, r5
2000e04e:	d000      	beq.n	2000e052 <usb_standard_request+0x96>
2000e050:	e0a7      	b.n	2000e1a2 <usb_standard_request+0x1e6>
  {
    switch (endpoint->setup.request_type & USB_SETUP_REQUEST_TYPE_RECIPIENT_mask)
2000e052:	7827      	ldrb	r7, [r4, #0]
2000e054:	201f      	movs	r0, #31
2000e056:	4038      	ands	r0, r7
2000e058:	2802      	cmp	r0, #2
2000e05a:	d000      	beq.n	2000e05e <usb_standard_request+0xa2>
2000e05c:	e0a1      	b.n	2000e1a2 <usb_standard_request+0x1e6>
uint8_t   USB_CurrentInterface = 0; //Bit 0 = SelfPowerred, Bit=1 Remote Wakeup
uint16_t  USB_EpStatus;

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000e05e:	88a6      	ldrh	r6, [r4, #4]
2000e060:	220f      	movs	r2, #15

static usb_request_status_t usb_standard_request_set_feature_endpoint(
  usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->setup.index);
  USB0_ENDPTCTRL(endpoint_number) |= (USB0_ENDPTCTRL_RXS | USB0_ENDPTCTRL_TXS);
2000e062:	4951      	ldr	r1, [pc, #324]	; (2000e1a8 <usb_standard_request+0x1ec>)
uint8_t   USB_CurrentInterface = 0; //Bit 0 = SelfPowerred, Bit=1 Remote Wakeup
uint16_t  USB_EpStatus;

static uint_fast8_t usb_endpoint_number(const uint_fast8_t endpoint_address)
{
  return (endpoint_address & 0xF);
2000e064:	4032      	ands	r2, r6

static usb_request_status_t usb_standard_request_set_feature_endpoint(
  usb_endpoint_t* const endpoint)
{
  const uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->setup.index);
  USB0_ENDPTCTRL(endpoint_number) |= (USB0_ENDPTCTRL_RXS | USB0_ENDPTCTRL_TXS);
2000e066:	1853      	adds	r3, r2, r1
2000e068:	009f      	lsls	r7, r3, #2
2000e06a:	6838      	ldr	r0, [r7, #0]
2000e06c:	4e4f      	ldr	r6, [pc, #316]	; (2000e1ac <usb_standard_request+0x1f0>)
2000e06e:	4330      	orrs	r0, r6
2000e070:	6038      	str	r0, [r7, #0]
2000e072:	e018      	b.n	2000e0a6 <usb_standard_request+0xea>
  const usb_transfer_stage_t stage)
{
  switch( endpoint->setup.request )
  {
    case USB_STANDARD_REQUEST_GET_STATUS:
      return usb_standard_request_get_status(endpoint, stage);
2000e074:	2500      	movs	r5, #0

static usb_request_status_t usb_standard_request_get_interface(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
  if (stage == USB_TRANSFER_STAGE_SETUP)
2000e076:	42a9      	cmp	r1, r5
2000e078:	d000      	beq.n	2000e07c <usb_standard_request+0xc0>
2000e07a:	e092      	b.n	2000e1a2 <usb_standard_request+0x1e6>
  {
    switch (endpoint->setup.request_type & USB_SETUP_REQUEST_TYPE_RECIPIENT_mask)
2000e07c:	7822      	ldrb	r2, [r4, #0]
2000e07e:	201f      	movs	r0, #31
2000e080:	4002      	ands	r2, r0
2000e082:	2a01      	cmp	r2, #1
2000e084:	d000      	beq.n	2000e088 <usb_standard_request+0xcc>
2000e086:	e08c      	b.n	2000e1a2 <usb_standard_request+0x1e6>
    {
      case USB_SETUP_REQUEST_TYPE_RECIPIENT_DEVICE:
        break;

      case USB_SETUP_REQUEST_TYPE_RECIPIENT_INTERFACE:
        usb_transfer_schedule_block(endpoint->in, &USB_CurrentInterface, 1);
2000e088:	69a0      	ldr	r0, [r4, #24]
2000e08a:	494d      	ldr	r1, [pc, #308]	; (2000e1c0 <usb_standard_request+0x204>)
2000e08c:	f7ff feac 	bl	2000dde8 <usb_transfer_schedule_block>
        usb_transfer_schedule_ack(endpoint->out);
2000e090:	69e0      	ldr	r0, [r4, #28]
2000e092:	e009      	b.n	2000e0a8 <usb_standard_request+0xec>
  const usb_transfer_stage_t stage)
{
  switch( endpoint->setup.request )
  {
    case USB_STANDARD_REQUEST_GET_STATUS:
      return usb_standard_request_get_status(endpoint, stage);
2000e094:	2500      	movs	r5, #0

static usb_request_status_t usb_standard_request_set_interface(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
  if (stage == USB_TRANSFER_STAGE_SETUP)
2000e096:	42a9      	cmp	r1, r5
2000e098:	d000      	beq.n	2000e09c <usb_standard_request+0xe0>
2000e09a:	e082      	b.n	2000e1a2 <usb_standard_request+0x1e6>
  {
    switch (endpoint->setup.request_type & USB_SETUP_REQUEST_TYPE_RECIPIENT_mask)
2000e09c:	7822      	ldrb	r2, [r4, #0]
2000e09e:	231f      	movs	r3, #31
2000e0a0:	4013      	ands	r3, r2
2000e0a2:	2b01      	cmp	r3, #1
2000e0a4:	d17d      	bne.n	2000e1a2 <usb_standard_request+0x1e6>
    {
      case USB_SETUP_REQUEST_TYPE_RECIPIENT_DEVICE:
        break;
      case USB_SETUP_REQUEST_TYPE_RECIPIENT_INTERFACE:
        usb_transfer_schedule_ack(endpoint->in);
2000e0a6:	69a0      	ldr	r0, [r4, #24]
2000e0a8:	f7ff feab 	bl	2000de02 <usb_transfer_schedule_ack>
2000e0ac:	e079      	b.n	2000e1a2 <usb_standard_request+0x1e6>

static usb_request_status_t usb_standard_request_get_descriptor(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
  switch( stage )
2000e0ae:	2900      	cmp	r1, #0
2000e0b0:	d15b      	bne.n	2000e16a <usb_standard_request+0x1ae>
}

static usb_request_status_t usb_standard_request_get_descriptor_setup(
  usb_endpoint_t* const endpoint)
{
  switch( endpoint->setup.value_h )
2000e0b2:	78e0      	ldrb	r0, [r4, #3]
2000e0b4:	3801      	subs	r0, #1
2000e0b6:	2806      	cmp	r0, #6
2000e0b8:	d872      	bhi.n	2000e1a0 <usb_standard_request+0x1e4>
2000e0ba:	f000 fb1b 	bl	2000e6f4 <__gnu_thumb1_case_uqi>
2000e0be:	0704      	.short	0x0704
2000e0c0:	10717121 	.word	0x10717121
2000e0c4:	13          	.byte	0x13
2000e0c5:	00          	.byte	0x00
  {
    case USB_DESCRIPTOR_TYPE_DEVICE:
      return usb_send_descriptor(endpoint, endpoint->device->descriptor);
2000e0c6:	6961      	ldr	r1, [r4, #20]
2000e0c8:	6809      	ldr	r1, [r1, #0]
2000e0ca:	e023      	b.n	2000e114 <usb_standard_request+0x158>

    case USB_DESCRIPTOR_TYPE_CONFIGURATION:
      // TODO: Duplicated code. Refactor.
      if( usb_speed(endpoint->device) == USB_SPEED_HIGH ) {
2000e0cc:	6960      	ldr	r0, [r4, #20]
2000e0ce:	f7ff fc59 	bl	2000d984 <usb_speed>
2000e0d2:	78a2      	ldrb	r2, [r4, #2]
2000e0d4:	1c01      	adds	r1, r0, #0
        return usb_send_descriptor_config(endpoint, USB_SPEED_HIGH, endpoint->setup.value_l);
2000e0d6:	1c20      	adds	r0, r4, #0
    case USB_DESCRIPTOR_TYPE_DEVICE:
      return usb_send_descriptor(endpoint, endpoint->device->descriptor);

    case USB_DESCRIPTOR_TYPE_CONFIGURATION:
      // TODO: Duplicated code. Refactor.
      if( usb_speed(endpoint->device) == USB_SPEED_HIGH ) {
2000e0d8:	2902      	cmp	r1, #2
2000e0da:	d10a      	bne.n	2000e0f2 <usb_standard_request+0x136>
2000e0dc:	e00d      	b.n	2000e0fa <usb_standard_request+0x13e>
      } else {
        return usb_send_descriptor_config(endpoint, USB_SPEED_FULL, endpoint->setup.value_l);
      }

    case USB_DESCRIPTOR_TYPE_DEVICE_QUALIFIER:
      return usb_send_descriptor(endpoint, endpoint->device->qualifier_descriptor);
2000e0de:	6963      	ldr	r3, [r4, #20]
2000e0e0:	6899      	ldr	r1, [r3, #8]
2000e0e2:	e017      	b.n	2000e114 <usb_standard_request+0x158>

    case USB_DESCRIPTOR_TYPE_OTHER_SPEED_CONFIGURATION:
      // TODO: Duplicated code. Refactor.
      if( usb_speed(endpoint->device) == USB_SPEED_HIGH ) {
2000e0e4:	6960      	ldr	r0, [r4, #20]
2000e0e6:	f7ff fc4d 	bl	2000d984 <usb_speed>
2000e0ea:	78a2      	ldrb	r2, [r4, #2]
2000e0ec:	2802      	cmp	r0, #2
2000e0ee:	d102      	bne.n	2000e0f6 <usb_standard_request+0x13a>
        return usb_send_descriptor_config(endpoint, USB_SPEED_FULL, endpoint->setup.value_l);
2000e0f0:	1c20      	adds	r0, r4, #0
2000e0f2:	2101      	movs	r1, #1
2000e0f4:	e001      	b.n	2000e0fa <usb_standard_request+0x13e>
      } else {
        return usb_send_descriptor_config(endpoint, USB_SPEED_HIGH, endpoint->setup.value_l);
2000e0f6:	1c20      	adds	r0, r4, #0
2000e0f8:	2102      	movs	r1, #2
2000e0fa:	f7ff ff02 	bl	2000df02 <usb_send_descriptor_config>
2000e0fe:	e00c      	b.n	2000e11a <usb_standard_request+0x15e>
  return USB_REQUEST_STATUS_OK;
}

static usb_request_status_t usb_send_descriptor_string(usb_endpoint_t* const endpoint)
{
  if ( endpoint->setup.value_l == 0xee)
2000e100:	78a0      	ldrb	r0, [r4, #2]
2000e102:	28ee      	cmp	r0, #238	; 0xee
2000e104:	d102      	bne.n	2000e10c <usb_standard_request+0x150>
  {
    return usb_send_descriptor(endpoint, usb_descriptor_MSDescriptor);
2000e106:	1c20      	adds	r0, r4, #0
2000e108:	492e      	ldr	r1, [pc, #184]	; (2000e1c4 <usb_standard_request+0x208>)
2000e10a:	e004      	b.n	2000e116 <usb_standard_request+0x15a>
  }
  else
  {
    uint_fast8_t index = endpoint->setup.value_l;
    for( uint_fast8_t i=0; endpoint->device->descriptor_strings[i] != 0; i++ )
2000e10c:	6967      	ldr	r7, [r4, #20]
2000e10e:	2600      	movs	r6, #0
2000e110:	687d      	ldr	r5, [r7, #4]
2000e112:	e007      	b.n	2000e124 <usb_standard_request+0x168>
    {
      if( i == index ) {
        return usb_send_descriptor(endpoint, endpoint->device->descriptor_strings[i]);
2000e114:	1c20      	adds	r0, r4, #0
2000e116:	f7ff fedc 	bl	2000ded2 <usb_send_descriptor>
2000e11a:	1c05      	adds	r5, r0, #0
2000e11c:	e041      	b.n	2000e1a2 <usb_standard_request+0x1e6>
  else
  {
    uint_fast8_t index = endpoint->setup.value_l;
    for( uint_fast8_t i=0; endpoint->device->descriptor_strings[i] != 0; i++ )
    {
      if( i == index ) {
2000e11e:	4286      	cmp	r6, r0
2000e120:	d0f8      	beq.n	2000e114 <usb_standard_request+0x158>
    return usb_send_descriptor(endpoint, usb_descriptor_MSDescriptor);
  }
  else
  {
    uint_fast8_t index = endpoint->setup.value_l;
    for( uint_fast8_t i=0; endpoint->device->descriptor_strings[i] != 0; i++ )
2000e122:	3601      	adds	r6, #1
2000e124:	cd02      	ldmia	r5!, {r1}
2000e126:	2900      	cmp	r1, #0
2000e128:	d1f9      	bne.n	2000e11e <usb_standard_request+0x162>
2000e12a:	e039      	b.n	2000e1a0 <usb_standard_request+0x1e4>

static usb_request_status_t usb_standard_request_set_address(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
  switch( stage )
2000e12c:	2900      	cmp	r1, #0
2000e12e:	d11c      	bne.n	2000e16a <usb_standard_request+0x1ae>
/*********************************************************************/

static usb_request_status_t usb_standard_request_set_address_setup(
  usb_endpoint_t* const endpoint)
{
  usb_set_address_deferred(endpoint->device, endpoint->setup.value_l);
2000e130:	78a1      	ldrb	r1, [r4, #2]
2000e132:	6960      	ldr	r0, [r4, #20]
2000e134:	f7ff fc48 	bl	2000d9c8 <usb_set_address_deferred>
  usb_transfer_schedule_ack(endpoint->in);
2000e138:	69a0      	ldr	r0, [r4, #24]
2000e13a:	f7ff fe62 	bl	2000de02 <usb_transfer_schedule_ack>
  const usb_transfer_stage_t stage)
{
  switch( stage )
  {
    case USB_TRANSFER_STAGE_SETUP:
      return usb_standard_request_set_address_setup(endpoint);
2000e13e:	1c35      	adds	r5, r6, #0
2000e140:	e02f      	b.n	2000e1a2 <usb_standard_request+0x1e6>

static usb_request_status_t usb_standard_request_set_configuration(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
  switch( stage )
2000e142:	2900      	cmp	r1, #0
2000e144:	d111      	bne.n	2000e16a <usb_standard_request+0x1ae>
/*********************************************************************/

static usb_request_status_t usb_standard_request_set_configuration_setup(
  usb_endpoint_t* const endpoint)
{
  const uint8_t usb_configuration = endpoint->setup.value_l;
2000e146:	78a7      	ldrb	r7, [r4, #2]
  if( usb_set_configuration(endpoint->device, usb_configuration) )
2000e148:	6960      	ldr	r0, [r4, #20]
2000e14a:	1c39      	adds	r1, r7, #0
2000e14c:	f7ff ff12 	bl	2000df74 <usb_set_configuration>
    usb_transfer_schedule_ack(endpoint->in);
    return USB_REQUEST_STATUS_OK;
  }
  else
  {
    return USB_REQUEST_STATUS_STALL;
2000e150:	2501      	movs	r5, #1

static usb_request_status_t usb_standard_request_set_configuration_setup(
  usb_endpoint_t* const endpoint)
{
  const uint8_t usb_configuration = endpoint->setup.value_l;
  if( usb_set_configuration(endpoint->device, usb_configuration) )
2000e152:	2800      	cmp	r0, #0
2000e154:	d025      	beq.n	2000e1a2 <usb_standard_request+0x1e6>
  {
    if( usb_configuration == 0 )
2000e156:	2f00      	cmp	r7, #0
2000e158:	d103      	bne.n	2000e162 <usb_standard_request+0x1a6>
    {
      // TODO: Should this be done immediately?
      usb_set_address_immediate(endpoint->device, 0);
2000e15a:	6960      	ldr	r0, [r4, #20]
2000e15c:	1c31      	adds	r1, r6, #0
2000e15e:	f7ff fc27 	bl	2000d9b0 <usb_set_address_immediate>
    }
    usb_transfer_schedule_ack(endpoint->in);
2000e162:	69a0      	ldr	r0, [r4, #24]
2000e164:	e018      	b.n	2000e198 <usb_standard_request+0x1dc>

static usb_request_status_t usb_standard_request_get_configuration(
  usb_endpoint_t* const endpoint,
  const usb_transfer_stage_t stage)
{
  switch( stage )
2000e166:	2900      	cmp	r1, #0
2000e168:	d004      	beq.n	2000e174 <usb_standard_request+0x1b8>
    case USB_TRANSFER_STAGE_SETUP:
      return usb_standard_request_get_configuration_setup(endpoint);

    case USB_TRANSFER_STAGE_DATA:
    case USB_TRANSFER_STAGE_STATUS:
      return USB_REQUEST_STATUS_OK;
2000e16a:	2202      	movs	r2, #2
2000e16c:	42b2      	cmp	r2, r6
2000e16e:	419b      	sbcs	r3, r3
2000e170:	425d      	negs	r5, r3
2000e172:	e016      	b.n	2000e1a2 <usb_standard_request+0x1e6>
/*********************************************************************/

static usb_request_status_t usb_standard_request_get_configuration_setup(
  usb_endpoint_t* const endpoint)
{
  if( endpoint->setup.length == 1 )
2000e174:	88e1      	ldrh	r1, [r4, #6]
    }
    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
    usb_transfer_schedule_ack(endpoint->out);
    return USB_REQUEST_STATUS_OK;
  } else {
    return USB_REQUEST_STATUS_STALL;
2000e176:	2501      	movs	r5, #1
/*********************************************************************/

static usb_request_status_t usb_standard_request_get_configuration_setup(
  usb_endpoint_t* const endpoint)
{
  if( endpoint->setup.length == 1 )
2000e178:	42a9      	cmp	r1, r5
2000e17a:	d112      	bne.n	2000e1a2 <usb_standard_request+0x1e6>
  {
    endpoint->buffer[0] = 0;
    if( endpoint->device->configuration )
2000e17c:	6965      	ldr	r5, [r4, #20]
static usb_request_status_t usb_standard_request_get_configuration_setup(
  usb_endpoint_t* const endpoint)
{
  if( endpoint->setup.length == 1 )
  {
    endpoint->buffer[0] = 0;
2000e17e:	7226      	strb	r6, [r4, #8]
    if( endpoint->device->configuration )
2000e180:	692e      	ldr	r6, [r5, #16]
2000e182:	2e00      	cmp	r6, #0
2000e184:	d001      	beq.n	2000e18a <usb_standard_request+0x1ce>
    {
      endpoint->buffer[0] = endpoint->device->configuration->number;
2000e186:	6872      	ldr	r2, [r6, #4]
2000e188:	7222      	strb	r2, [r4, #8]
    }
    usb_transfer_schedule_block(endpoint->in, &endpoint->buffer, 1);
2000e18a:	1c21      	adds	r1, r4, #0
2000e18c:	3108      	adds	r1, #8
2000e18e:	69a0      	ldr	r0, [r4, #24]
2000e190:	2201      	movs	r2, #1
2000e192:	f7ff fe29 	bl	2000dde8 <usb_transfer_schedule_block>
    usb_transfer_schedule_ack(endpoint->out);
2000e196:	69e0      	ldr	r0, [r4, #28]
2000e198:	f7ff fe33 	bl	2000de02 <usb_transfer_schedule_ack>
    return USB_REQUEST_STATUS_OK;
2000e19c:	2500      	movs	r5, #0
2000e19e:	e000      	b.n	2000e1a2 <usb_standard_request+0x1e6>

    case USB_STANDARD_REQUEST_GET_CONFIGURATION:
      return usb_standard_request_get_configuration(endpoint, stage);

    default:
      return USB_REQUEST_STATUS_STALL;
2000e1a0:	2501      	movs	r5, #1
  }
}
2000e1a2:	1c28      	adds	r0, r5, #0
2000e1a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2000e1a6:	46c0      	nop			; (mov r8, r8)
2000e1a8:	10001870 	.word	0x10001870
2000e1ac:	00010001 	.word	0x00010001
2000e1b0:	2000fb00 	.word	0x2000fb00
2000e1b4:	2000f37a 	.word	0x2000f37a
2000e1b8:	2000f378 	.word	0x2000f378
2000e1bc:	fffefffe 	.word	0xfffefffe
2000e1c0:	2000f37c 	.word	0x2000f37c
2000e1c4:	2000ed41 	.word	0x2000ed41

2000e1c8 <scu_pinmux>:
/* For pin_conf_normal value see scu.h define SCU_CONF_XXX or Configuration for
 * different I/O pins types
 */
void scu_pinmux(scu_grp_pin_t group_pin, uint32_t scu_conf)
{
	MMIO32(group_pin) = scu_conf;
2000e1c8:	6001      	str	r1, [r0, #0]
}
2000e1ca:	4770      	bx	lr

2000e1cc <i2c0_init>:
#define SFSP_I2C1_SDA_SCL (0x00000001 | SCU_CONF_ZIF_DIS_IN_GLITCH_FILT | SCU_CONF_EZI_EN_IN_BUFFER)

void i2c0_init(const uint16_t duty_cycle_count)
{
  /* enable input on SCL and SDA pins */
  SCU_SFSI2C0 = SCU_I2C0_NOMINAL;
2000e1cc:	4a06      	ldr	r2, [pc, #24]	; (2000e1e8 <i2c0_init+0x1c>)
2000e1ce:	4b07      	ldr	r3, [pc, #28]	; (2000e1ec <i2c0_init+0x20>)

  I2C0_SCLH = duty_cycle_count;
2000e1d0:	4907      	ldr	r1, [pc, #28]	; (2000e1f0 <i2c0_init+0x24>)
#define SFSP_I2C1_SDA_SCL (0x00000001 | SCU_CONF_ZIF_DIS_IN_GLITCH_FILT | SCU_CONF_EZI_EN_IN_BUFFER)

void i2c0_init(const uint16_t duty_cycle_count)
{
  /* enable input on SCL and SDA pins */
  SCU_SFSI2C0 = SCU_I2C0_NOMINAL;
2000e1d2:	601a      	str	r2, [r3, #0]

  I2C0_SCLH = duty_cycle_count;
  I2C0_SCLL = duty_cycle_count;
2000e1d4:	4a07      	ldr	r2, [pc, #28]	; (2000e1f4 <i2c0_init+0x28>)
void i2c0_init(const uint16_t duty_cycle_count)
{
  /* enable input on SCL and SDA pins */
  SCU_SFSI2C0 = SCU_I2C0_NOMINAL;

  I2C0_SCLH = duty_cycle_count;
2000e1d6:	6008      	str	r0, [r1, #0]
  I2C0_SCLL = duty_cycle_count;

  /* clear the control bits */
  I2C0_CONCLR = (I2C_CONCLR_AAC | I2C_CONCLR_SIC
2000e1d8:	4b07      	ldr	r3, [pc, #28]	; (2000e1f8 <i2c0_init+0x2c>)
{
  /* enable input on SCL and SDA pins */
  SCU_SFSI2C0 = SCU_I2C0_NOMINAL;

  I2C0_SCLH = duty_cycle_count;
  I2C0_SCLL = duty_cycle_count;
2000e1da:	6010      	str	r0, [r2, #0]
  /* clear the control bits */
  I2C0_CONCLR = (I2C_CONCLR_AAC | I2C_CONCLR_SIC
      | I2C_CONCLR_STAC | I2C_CONCLR_I2ENC);

  /* enable I2C0 */
  I2C0_CONSET = I2C_CONSET_I2EN;
2000e1dc:	4a07      	ldr	r2, [pc, #28]	; (2000e1fc <i2c0_init+0x30>)

  I2C0_SCLH = duty_cycle_count;
  I2C0_SCLL = duty_cycle_count;

  /* clear the control bits */
  I2C0_CONCLR = (I2C_CONCLR_AAC | I2C_CONCLR_SIC
2000e1de:	206c      	movs	r0, #108	; 0x6c
      | I2C_CONCLR_STAC | I2C_CONCLR_I2ENC);

  /* enable I2C0 */
  I2C0_CONSET = I2C_CONSET_I2EN;
2000e1e0:	2140      	movs	r1, #64	; 0x40

  I2C0_SCLH = duty_cycle_count;
  I2C0_SCLL = duty_cycle_count;

  /* clear the control bits */
  I2C0_CONCLR = (I2C_CONCLR_AAC | I2C_CONCLR_SIC
2000e1e2:	6018      	str	r0, [r3, #0]
      | I2C_CONCLR_STAC | I2C_CONCLR_I2ENC);

  /* enable I2C0 */
  I2C0_CONSET = I2C_CONSET_I2EN;
2000e1e4:	6011      	str	r1, [r2, #0]
}
2000e1e6:	4770      	bx	lr
2000e1e8:	00000808 	.word	0x00000808
2000e1ec:	40086c84 	.word	0x40086c84
2000e1f0:	400a1010 	.word	0x400a1010
2000e1f4:	400a1014 	.word	0x400a1014
2000e1f8:	400a1018 	.word	0x400a1018
2000e1fc:	400a1000 	.word	0x400a1000

2000e200 <i2c1_init>:

void i2c1_init(const uint16_t duty_cycle_count)
{
  /* Configure pin function for I2C1*/
  SCU_SFSP2_3 = SFSP_I2C1_SDA_SCL;
2000e200:	4a07      	ldr	r2, [pc, #28]	; (2000e220 <i2c1_init+0x20>)
  SCU_SFSP2_4 = SFSP_I2C1_SDA_SCL;
2000e202:	4908      	ldr	r1, [pc, #32]	; (2000e224 <i2c1_init+0x24>)
}

void i2c1_init(const uint16_t duty_cycle_count)
{
  /* Configure pin function for I2C1*/
  SCU_SFSP2_3 = SFSP_I2C1_SDA_SCL;
2000e204:	23c1      	movs	r3, #193	; 0xc1
2000e206:	6013      	str	r3, [r2, #0]
  SCU_SFSP2_4 = SFSP_I2C1_SDA_SCL;
2000e208:	600b      	str	r3, [r1, #0]

  I2C1_SCLH = duty_cycle_count;
2000e20a:	4b07      	ldr	r3, [pc, #28]	; (2000e228 <i2c1_init+0x28>)
  I2C1_SCLL = duty_cycle_count;
2000e20c:	4a07      	ldr	r2, [pc, #28]	; (2000e22c <i2c1_init+0x2c>)
{
  /* Configure pin function for I2C1*/
  SCU_SFSP2_3 = SFSP_I2C1_SDA_SCL;
  SCU_SFSP2_4 = SFSP_I2C1_SDA_SCL;

  I2C1_SCLH = duty_cycle_count;
2000e20e:	6018      	str	r0, [r3, #0]
  I2C1_SCLL = duty_cycle_count;

  /* clear the control bits */
  I2C1_CONCLR = (I2C_CONCLR_AAC | I2C_CONCLR_SIC
2000e210:	4907      	ldr	r1, [pc, #28]	; (2000e230 <i2c1_init+0x30>)
      | I2C_CONCLR_STAC | I2C_CONCLR_I2ENC);

  /* enable I2C1 */
  I2C1_CONSET = I2C_CONSET_I2EN;
2000e212:	4b08      	ldr	r3, [pc, #32]	; (2000e234 <i2c1_init+0x34>)
  /* Configure pin function for I2C1*/
  SCU_SFSP2_3 = SFSP_I2C1_SDA_SCL;
  SCU_SFSP2_4 = SFSP_I2C1_SDA_SCL;

  I2C1_SCLH = duty_cycle_count;
  I2C1_SCLL = duty_cycle_count;
2000e214:	6010      	str	r0, [r2, #0]

  /* clear the control bits */
  I2C1_CONCLR = (I2C_CONCLR_AAC | I2C_CONCLR_SIC
2000e216:	206c      	movs	r0, #108	; 0x6c
      | I2C_CONCLR_STAC | I2C_CONCLR_I2ENC);

  /* enable I2C1 */
  I2C1_CONSET = I2C_CONSET_I2EN;
2000e218:	2240      	movs	r2, #64	; 0x40

  I2C1_SCLH = duty_cycle_count;
  I2C1_SCLL = duty_cycle_count;

  /* clear the control bits */
  I2C1_CONCLR = (I2C_CONCLR_AAC | I2C_CONCLR_SIC
2000e21a:	6008      	str	r0, [r1, #0]
      | I2C_CONCLR_STAC | I2C_CONCLR_I2ENC);

  /* enable I2C1 */
  I2C1_CONSET = I2C_CONSET_I2EN;
2000e21c:	601a      	str	r2, [r3, #0]
}
2000e21e:	4770      	bx	lr
2000e220:	4008610c 	.word	0x4008610c
2000e224:	40086110 	.word	0x40086110
2000e228:	400e0010 	.word	0x400e0010
2000e22c:	400e0014 	.word	0x400e0014
2000e230:	400e0018 	.word	0x400e0018
2000e234:	400e0000 	.word	0x400e0000

2000e238 <i2c0_tx_start>:
/* transmit start bit */
void i2c0_tx_start(void)
{
  uint32_t timeout;

  I2C0_CONCLR = I2C_CONCLR_SIC;
2000e238:	4a0c      	ldr	r2, [pc, #48]	; (2000e26c <i2c0_tx_start+0x34>)
  I2C0_CONSET = I2C_CONSET_STA;
2000e23a:	490d      	ldr	r1, [pc, #52]	; (2000e270 <i2c0_tx_start+0x38>)
/* transmit start bit */
void i2c0_tx_start(void)
{
  uint32_t timeout;

  I2C0_CONCLR = I2C_CONCLR_SIC;
2000e23c:	2308      	movs	r3, #8
  I2C0_CONSET = I2C_CONSET_STA;
2000e23e:	2020      	movs	r0, #32
/* transmit start bit */
void i2c0_tx_start(void)
{
  uint32_t timeout;

  I2C0_CONCLR = I2C_CONCLR_SIC;
2000e240:	6013      	str	r3, [r2, #0]
  I2C0_CONSET = I2C_CONSET_STA;
2000e242:	6008      	str	r0, [r1, #0]

  timeout = 0;
  while( (!(I2C0_CONSET & I2C_CONSET_SI)) && (timeout < I2C_TIMEOUT) )
2000e244:	680a      	ldr	r2, [r1, #0]
2000e246:	4213      	tst	r3, r2
2000e248:	d10b      	bne.n	2000e262 <i2c0_tx_start+0x2a>
2000e24a:	4b0a      	ldr	r3, [pc, #40]	; (2000e274 <i2c0_tx_start+0x3c>)
2000e24c:	2208      	movs	r2, #8
2000e24e:	e005      	b.n	2000e25c <i2c0_tx_start+0x24>
2000e250:	6808      	ldr	r0, [r1, #0]
2000e252:	4202      	tst	r2, r0
2000e254:	d105      	bne.n	2000e262 <i2c0_tx_start+0x2a>
2000e256:	3b02      	subs	r3, #2
2000e258:	2b00      	cmp	r3, #0
2000e25a:	d002      	beq.n	2000e262 <i2c0_tx_start+0x2a>
2000e25c:	6808      	ldr	r0, [r1, #0]
2000e25e:	4202      	tst	r2, r0
2000e260:	d0f6      	beq.n	2000e250 <i2c0_tx_start+0x18>
  {
    timeout++;
  }

  I2C0_CONCLR = I2C_CONCLR_STAC;
2000e262:	4b02      	ldr	r3, [pc, #8]	; (2000e26c <i2c0_tx_start+0x34>)
2000e264:	2120      	movs	r1, #32
2000e266:	6019      	str	r1, [r3, #0]
}
2000e268:	4770      	bx	lr
2000e26a:	46c0      	nop			; (mov r8, r8)
2000e26c:	400a1018 	.word	0x400a1018
2000e270:	400a1000 	.word	0x400a1000
2000e274:	00002710 	.word	0x00002710

2000e278 <i2c1_tx_start>:
/* transmit start bit */
void i2c1_tx_start(void)
{
  uint32_t timeout;

  I2C1_CONCLR = I2C_CONCLR_SIC;
2000e278:	4a0c      	ldr	r2, [pc, #48]	; (2000e2ac <i2c1_tx_start+0x34>)
  I2C1_CONSET = I2C_CONSET_STA;
2000e27a:	490d      	ldr	r1, [pc, #52]	; (2000e2b0 <i2c1_tx_start+0x38>)
/* transmit start bit */
void i2c1_tx_start(void)
{
  uint32_t timeout;

  I2C1_CONCLR = I2C_CONCLR_SIC;
2000e27c:	2308      	movs	r3, #8
  I2C1_CONSET = I2C_CONSET_STA;
2000e27e:	2020      	movs	r0, #32
/* transmit start bit */
void i2c1_tx_start(void)
{
  uint32_t timeout;

  I2C1_CONCLR = I2C_CONCLR_SIC;
2000e280:	6013      	str	r3, [r2, #0]
  I2C1_CONSET = I2C_CONSET_STA;
2000e282:	6008      	str	r0, [r1, #0]

  timeout = 0;
  while( (!(I2C1_CONSET & I2C_CONSET_SI)) && (timeout < I2C_TIMEOUT) )
2000e284:	680a      	ldr	r2, [r1, #0]
2000e286:	4213      	tst	r3, r2
2000e288:	d10b      	bne.n	2000e2a2 <i2c1_tx_start+0x2a>
2000e28a:	4b0a      	ldr	r3, [pc, #40]	; (2000e2b4 <i2c1_tx_start+0x3c>)
2000e28c:	2208      	movs	r2, #8
2000e28e:	e005      	b.n	2000e29c <i2c1_tx_start+0x24>
2000e290:	6808      	ldr	r0, [r1, #0]
2000e292:	4202      	tst	r2, r0
2000e294:	d105      	bne.n	2000e2a2 <i2c1_tx_start+0x2a>
2000e296:	3b02      	subs	r3, #2
2000e298:	2b00      	cmp	r3, #0
2000e29a:	d002      	beq.n	2000e2a2 <i2c1_tx_start+0x2a>
2000e29c:	6808      	ldr	r0, [r1, #0]
2000e29e:	4202      	tst	r2, r0
2000e2a0:	d0f6      	beq.n	2000e290 <i2c1_tx_start+0x18>
  {
    timeout++;
  }

  I2C1_CONCLR = I2C_CONCLR_STAC;
2000e2a2:	4b02      	ldr	r3, [pc, #8]	; (2000e2ac <i2c1_tx_start+0x34>)
2000e2a4:	2120      	movs	r1, #32
2000e2a6:	6019      	str	r1, [r3, #0]
}
2000e2a8:	4770      	bx	lr
2000e2aa:	46c0      	nop			; (mov r8, r8)
2000e2ac:	400e0018 	.word	0x400e0018
2000e2b0:	400e0000 	.word	0x400e0000
2000e2b4:	00002710 	.word	0x00002710

2000e2b8 <i2c0_tx_byte>:
/* transmit data byte */
void i2c0_tx_byte(uint8_t byte)
{
  uint32_t timeout;

  if (I2C0_CONSET & I2C_CONSET_STA)
2000e2b8:	4b0e      	ldr	r3, [pc, #56]	; (2000e2f4 <i2c0_tx_byte+0x3c>)
2000e2ba:	2120      	movs	r1, #32
2000e2bc:	681a      	ldr	r2, [r3, #0]
2000e2be:	4211      	tst	r1, r2
2000e2c0:	d001      	beq.n	2000e2c6 <i2c0_tx_byte+0xe>
  {
    I2C0_CONCLR = I2C_CONCLR_STAC;
2000e2c2:	4b0d      	ldr	r3, [pc, #52]	; (2000e2f8 <i2c0_tx_byte+0x40>)
2000e2c4:	6019      	str	r1, [r3, #0]
  }
  I2C0_DAT = byte;
2000e2c6:	4a0d      	ldr	r2, [pc, #52]	; (2000e2fc <i2c0_tx_byte+0x44>)
  I2C0_CONCLR = I2C_CONCLR_SIC;
2000e2c8:	490b      	ldr	r1, [pc, #44]	; (2000e2f8 <i2c0_tx_byte+0x40>)

  if (I2C0_CONSET & I2C_CONSET_STA)
  {
    I2C0_CONCLR = I2C_CONCLR_STAC;
  }
  I2C0_DAT = byte;
2000e2ca:	6010      	str	r0, [r2, #0]
  I2C0_CONCLR = I2C_CONCLR_SIC;
2000e2cc:	2008      	movs	r0, #8
2000e2ce:	6008      	str	r0, [r1, #0]

  timeout = 0;
  while( (!(I2C0_CONSET & I2C_CONSET_SI)) && (timeout < I2C_TIMEOUT) )
2000e2d0:	4908      	ldr	r1, [pc, #32]	; (2000e2f4 <i2c0_tx_byte+0x3c>)
2000e2d2:	680b      	ldr	r3, [r1, #0]
2000e2d4:	4218      	tst	r0, r3
2000e2d6:	d10b      	bne.n	2000e2f0 <i2c0_tx_byte+0x38>
2000e2d8:	4b09      	ldr	r3, [pc, #36]	; (2000e300 <i2c0_tx_byte+0x48>)
2000e2da:	2208      	movs	r2, #8
2000e2dc:	e005      	b.n	2000e2ea <i2c0_tx_byte+0x32>
2000e2de:	6808      	ldr	r0, [r1, #0]
2000e2e0:	4202      	tst	r2, r0
2000e2e2:	d105      	bne.n	2000e2f0 <i2c0_tx_byte+0x38>
2000e2e4:	3b02      	subs	r3, #2
2000e2e6:	2b00      	cmp	r3, #0
2000e2e8:	d002      	beq.n	2000e2f0 <i2c0_tx_byte+0x38>
2000e2ea:	6808      	ldr	r0, [r1, #0]
2000e2ec:	4202      	tst	r2, r0
2000e2ee:	d0f6      	beq.n	2000e2de <i2c0_tx_byte+0x26>
  {
    timeout++;
  }
}
2000e2f0:	4770      	bx	lr
2000e2f2:	46c0      	nop			; (mov r8, r8)
2000e2f4:	400a1000 	.word	0x400a1000
2000e2f8:	400a1018 	.word	0x400a1018
2000e2fc:	400a1008 	.word	0x400a1008
2000e300:	00002710 	.word	0x00002710

2000e304 <i2c1_tx_byte>:
/* transmit data byte */
void i2c1_tx_byte(uint8_t byte)
{
  uint32_t timeout;

  if (I2C1_CONSET & I2C_CONSET_STA)
2000e304:	4b0e      	ldr	r3, [pc, #56]	; (2000e340 <i2c1_tx_byte+0x3c>)
2000e306:	2120      	movs	r1, #32
2000e308:	681a      	ldr	r2, [r3, #0]
2000e30a:	4211      	tst	r1, r2
2000e30c:	d001      	beq.n	2000e312 <i2c1_tx_byte+0xe>
  {
    I2C1_CONCLR = I2C_CONCLR_STAC;
2000e30e:	4b0d      	ldr	r3, [pc, #52]	; (2000e344 <i2c1_tx_byte+0x40>)
2000e310:	6019      	str	r1, [r3, #0]
  }
  I2C1_DAT = byte;
2000e312:	4a0d      	ldr	r2, [pc, #52]	; (2000e348 <i2c1_tx_byte+0x44>)
  I2C1_CONCLR = I2C_CONCLR_SIC;
2000e314:	490b      	ldr	r1, [pc, #44]	; (2000e344 <i2c1_tx_byte+0x40>)

  if (I2C1_CONSET & I2C_CONSET_STA)
  {
    I2C1_CONCLR = I2C_CONCLR_STAC;
  }
  I2C1_DAT = byte;
2000e316:	6010      	str	r0, [r2, #0]
  I2C1_CONCLR = I2C_CONCLR_SIC;
2000e318:	2008      	movs	r0, #8
2000e31a:	6008      	str	r0, [r1, #0]

  timeout = 0;
  while( (!(I2C1_CONSET & I2C_CONSET_SI)) && (timeout < I2C_TIMEOUT) )
2000e31c:	4908      	ldr	r1, [pc, #32]	; (2000e340 <i2c1_tx_byte+0x3c>)
2000e31e:	680b      	ldr	r3, [r1, #0]
2000e320:	4218      	tst	r0, r3
2000e322:	d10b      	bne.n	2000e33c <i2c1_tx_byte+0x38>
2000e324:	4b09      	ldr	r3, [pc, #36]	; (2000e34c <i2c1_tx_byte+0x48>)
2000e326:	2208      	movs	r2, #8
2000e328:	e005      	b.n	2000e336 <i2c1_tx_byte+0x32>
2000e32a:	6808      	ldr	r0, [r1, #0]
2000e32c:	4202      	tst	r2, r0
2000e32e:	d105      	bne.n	2000e33c <i2c1_tx_byte+0x38>
2000e330:	3b02      	subs	r3, #2
2000e332:	2b00      	cmp	r3, #0
2000e334:	d002      	beq.n	2000e33c <i2c1_tx_byte+0x38>
2000e336:	6808      	ldr	r0, [r1, #0]
2000e338:	4202      	tst	r2, r0
2000e33a:	d0f6      	beq.n	2000e32a <i2c1_tx_byte+0x26>
  {
    timeout++;
  }
}
2000e33c:	4770      	bx	lr
2000e33e:	46c0      	nop			; (mov r8, r8)
2000e340:	400e0000 	.word	0x400e0000
2000e344:	400e0018 	.word	0x400e0018
2000e348:	400e0008 	.word	0x400e0008
2000e34c:	00002710 	.word	0x00002710

2000e350 <i2c0_rx_byte>:
/* receive data byte */
uint8_t i2c0_rx_byte(void)
{
  uint32_t timeout;

  if (I2C0_CONSET & I2C_CONSET_STA)
2000e350:	4b0e      	ldr	r3, [pc, #56]	; (2000e38c <i2c0_rx_byte+0x3c>)
2000e352:	2020      	movs	r0, #32
2000e354:	681a      	ldr	r2, [r3, #0]
2000e356:	4210      	tst	r0, r2
2000e358:	d001      	beq.n	2000e35e <i2c0_rx_byte+0xe>
  {
    I2C0_CONCLR = I2C_CONCLR_STAC;
2000e35a:	490d      	ldr	r1, [pc, #52]	; (2000e390 <i2c0_rx_byte+0x40>)
2000e35c:	6008      	str	r0, [r1, #0]
  }
  I2C0_CONCLR = I2C_CONCLR_SIC;
2000e35e:	4a0c      	ldr	r2, [pc, #48]	; (2000e390 <i2c0_rx_byte+0x40>)
2000e360:	2308      	movs	r3, #8

  timeout = 0;
  while( (!(I2C0_CONSET & I2C_CONSET_SI)) && (timeout < I2C_TIMEOUT) )
2000e362:	490a      	ldr	r1, [pc, #40]	; (2000e38c <i2c0_rx_byte+0x3c>)

  if (I2C0_CONSET & I2C_CONSET_STA)
  {
    I2C0_CONCLR = I2C_CONCLR_STAC;
  }
  I2C0_CONCLR = I2C_CONCLR_SIC;
2000e364:	6013      	str	r3, [r2, #0]

  timeout = 0;
  while( (!(I2C0_CONSET & I2C_CONSET_SI)) && (timeout < I2C_TIMEOUT) )
2000e366:	6808      	ldr	r0, [r1, #0]
2000e368:	4203      	tst	r3, r0
2000e36a:	d10b      	bne.n	2000e384 <i2c0_rx_byte+0x34>
2000e36c:	4b09      	ldr	r3, [pc, #36]	; (2000e394 <i2c0_rx_byte+0x44>)
2000e36e:	2208      	movs	r2, #8
2000e370:	e005      	b.n	2000e37e <i2c0_rx_byte+0x2e>
2000e372:	6808      	ldr	r0, [r1, #0]
2000e374:	4202      	tst	r2, r0
2000e376:	d105      	bne.n	2000e384 <i2c0_rx_byte+0x34>
2000e378:	3b02      	subs	r3, #2
2000e37a:	2b00      	cmp	r3, #0
2000e37c:	d002      	beq.n	2000e384 <i2c0_rx_byte+0x34>
2000e37e:	6808      	ldr	r0, [r1, #0]
2000e380:	4202      	tst	r2, r0
2000e382:	d0f6      	beq.n	2000e372 <i2c0_rx_byte+0x22>
  {
    timeout++;
  }

  return I2C0_DAT;
2000e384:	4904      	ldr	r1, [pc, #16]	; (2000e398 <i2c0_rx_byte+0x48>)
2000e386:	680b      	ldr	r3, [r1, #0]
2000e388:	b2d8      	uxtb	r0, r3
}
2000e38a:	4770      	bx	lr
2000e38c:	400a1000 	.word	0x400a1000
2000e390:	400a1018 	.word	0x400a1018
2000e394:	00002710 	.word	0x00002710
2000e398:	400a1008 	.word	0x400a1008

2000e39c <i2c1_rx_byte>:
/* receive data byte (ack=1 => ACK if ack=0 NACK) */
uint8_t i2c1_rx_byte(bool ack)
{
  uint32_t timeout;

  if (I2C1_CONSET & I2C_CONSET_STA)
2000e39c:	4b12      	ldr	r3, [pc, #72]	; (2000e3e8 <i2c1_rx_byte+0x4c>)
2000e39e:	2120      	movs	r1, #32
2000e3a0:	681a      	ldr	r2, [r3, #0]
2000e3a2:	4211      	tst	r1, r2
2000e3a4:	d001      	beq.n	2000e3aa <i2c1_rx_byte+0xe>
  {
    I2C1_CONCLR = I2C_CONCLR_STAC;
2000e3a6:	4b11      	ldr	r3, [pc, #68]	; (2000e3ec <i2c1_rx_byte+0x50>)
2000e3a8:	6019      	str	r1, [r3, #0]
  }

  if (ack)
  {
    I2C1_CONSET = I2C_CONSET_AA;
2000e3aa:	2204      	movs	r2, #4
  if (I2C1_CONSET & I2C_CONSET_STA)
  {
    I2C1_CONCLR = I2C_CONCLR_STAC;
  }

  if (ack)
2000e3ac:	2800      	cmp	r0, #0
2000e3ae:	d018      	beq.n	2000e3e2 <i2c1_rx_byte+0x46>
  {
    I2C1_CONSET = I2C_CONSET_AA;
2000e3b0:	490d      	ldr	r1, [pc, #52]	; (2000e3e8 <i2c1_rx_byte+0x4c>)
2000e3b2:	600a      	str	r2, [r1, #0]
  } else
  {
    I2C1_CONCLR = I2C_CONCLR_AAC;
  }

  I2C1_CONCLR = I2C_CONCLR_SIC;
2000e3b4:	4a0d      	ldr	r2, [pc, #52]	; (2000e3ec <i2c1_rx_byte+0x50>)
2000e3b6:	2308      	movs	r3, #8
  timeout = 0;
  while( (!(I2C1_CONSET & I2C_CONSET_SI)) && (timeout < I2C_TIMEOUT) )
2000e3b8:	490b      	ldr	r1, [pc, #44]	; (2000e3e8 <i2c1_rx_byte+0x4c>)
  } else
  {
    I2C1_CONCLR = I2C_CONCLR_AAC;
  }

  I2C1_CONCLR = I2C_CONCLR_SIC;
2000e3ba:	6013      	str	r3, [r2, #0]
  timeout = 0;
  while( (!(I2C1_CONSET & I2C_CONSET_SI)) && (timeout < I2C_TIMEOUT) )
2000e3bc:	6808      	ldr	r0, [r1, #0]
2000e3be:	4203      	tst	r3, r0
2000e3c0:	d10b      	bne.n	2000e3da <i2c1_rx_byte+0x3e>
2000e3c2:	4b0b      	ldr	r3, [pc, #44]	; (2000e3f0 <i2c1_rx_byte+0x54>)
2000e3c4:	2208      	movs	r2, #8
2000e3c6:	e005      	b.n	2000e3d4 <i2c1_rx_byte+0x38>
2000e3c8:	6808      	ldr	r0, [r1, #0]
2000e3ca:	4202      	tst	r2, r0
2000e3cc:	d105      	bne.n	2000e3da <i2c1_rx_byte+0x3e>
2000e3ce:	3b02      	subs	r3, #2
2000e3d0:	2b00      	cmp	r3, #0
2000e3d2:	d002      	beq.n	2000e3da <i2c1_rx_byte+0x3e>
2000e3d4:	6808      	ldr	r0, [r1, #0]
2000e3d6:	4202      	tst	r2, r0
2000e3d8:	d0f6      	beq.n	2000e3c8 <i2c1_rx_byte+0x2c>
  {
    timeout++;
  }

  return I2C1_DAT;
2000e3da:	4906      	ldr	r1, [pc, #24]	; (2000e3f4 <i2c1_rx_byte+0x58>)
2000e3dc:	680b      	ldr	r3, [r1, #0]
2000e3de:	b2d8      	uxtb	r0, r3
}
2000e3e0:	4770      	bx	lr
  if (ack)
  {
    I2C1_CONSET = I2C_CONSET_AA;
  } else
  {
    I2C1_CONCLR = I2C_CONCLR_AAC;
2000e3e2:	4802      	ldr	r0, [pc, #8]	; (2000e3ec <i2c1_rx_byte+0x50>)
2000e3e4:	6002      	str	r2, [r0, #0]
2000e3e6:	e7e5      	b.n	2000e3b4 <i2c1_rx_byte+0x18>
2000e3e8:	400e0000 	.word	0x400e0000
2000e3ec:	400e0018 	.word	0x400e0018
2000e3f0:	00002710 	.word	0x00002710
2000e3f4:	400e0008 	.word	0x400e0008

2000e3f8 <i2c0_stop>:
}

/* transmit stop bit */
void i2c0_stop(void)
{
  if (I2C0_CONSET & I2C_CONSET_STA) {
2000e3f8:	4b06      	ldr	r3, [pc, #24]	; (2000e414 <i2c0_stop+0x1c>)
2000e3fa:	2020      	movs	r0, #32
2000e3fc:	681a      	ldr	r2, [r3, #0]
2000e3fe:	4210      	tst	r0, r2
2000e400:	d001      	beq.n	2000e406 <i2c0_stop+0xe>
    I2C0_CONCLR = I2C_CONCLR_STAC;
2000e402:	4905      	ldr	r1, [pc, #20]	; (2000e418 <i2c0_stop+0x20>)
2000e404:	6008      	str	r0, [r1, #0]
  }
  I2C0_CONSET = I2C_CONSET_STO;
2000e406:	4b03      	ldr	r3, [pc, #12]	; (2000e414 <i2c0_stop+0x1c>)
  I2C0_CONCLR = I2C_CONCLR_SIC;
2000e408:	4903      	ldr	r1, [pc, #12]	; (2000e418 <i2c0_stop+0x20>)
void i2c0_stop(void)
{
  if (I2C0_CONSET & I2C_CONSET_STA) {
    I2C0_CONCLR = I2C_CONCLR_STAC;
  }
  I2C0_CONSET = I2C_CONSET_STO;
2000e40a:	2210      	movs	r2, #16
  I2C0_CONCLR = I2C_CONCLR_SIC;
2000e40c:	2008      	movs	r0, #8
void i2c0_stop(void)
{
  if (I2C0_CONSET & I2C_CONSET_STA) {
    I2C0_CONCLR = I2C_CONCLR_STAC;
  }
  I2C0_CONSET = I2C_CONSET_STO;
2000e40e:	601a      	str	r2, [r3, #0]
  I2C0_CONCLR = I2C_CONCLR_SIC;
2000e410:	6008      	str	r0, [r1, #0]
}
2000e412:	4770      	bx	lr
2000e414:	400a1000 	.word	0x400a1000
2000e418:	400a1018 	.word	0x400a1018

2000e41c <i2c1_stop>:

/* transmit stop bit */
void i2c1_stop(void)
{
  if (I2C1_CONSET & I2C_CONSET_STA) {
2000e41c:	4b06      	ldr	r3, [pc, #24]	; (2000e438 <i2c1_stop+0x1c>)
2000e41e:	2020      	movs	r0, #32
2000e420:	681a      	ldr	r2, [r3, #0]
2000e422:	4210      	tst	r0, r2
2000e424:	d001      	beq.n	2000e42a <i2c1_stop+0xe>
    I2C1_CONCLR = I2C_CONCLR_STAC;
2000e426:	4905      	ldr	r1, [pc, #20]	; (2000e43c <i2c1_stop+0x20>)
2000e428:	6008      	str	r0, [r1, #0]
  }
  I2C1_CONSET = I2C_CONSET_STO;
2000e42a:	4b03      	ldr	r3, [pc, #12]	; (2000e438 <i2c1_stop+0x1c>)
  I2C1_CONCLR = I2C_CONCLR_SIC;
2000e42c:	4903      	ldr	r1, [pc, #12]	; (2000e43c <i2c1_stop+0x20>)
void i2c1_stop(void)
{
  if (I2C1_CONSET & I2C_CONSET_STA) {
    I2C1_CONCLR = I2C_CONCLR_STAC;
  }
  I2C1_CONSET = I2C_CONSET_STO;
2000e42e:	2210      	movs	r2, #16
  I2C1_CONCLR = I2C_CONCLR_SIC;
2000e430:	2008      	movs	r0, #8
void i2c1_stop(void)
{
  if (I2C1_CONSET & I2C_CONSET_STA) {
    I2C1_CONCLR = I2C_CONCLR_STAC;
  }
  I2C1_CONSET = I2C_CONSET_STO;
2000e432:	601a      	str	r2, [r3, #0]
  I2C1_CONCLR = I2C_CONCLR_SIC;
2000e434:	6008      	str	r0, [r1, #0]
}
2000e436:	4770      	bx	lr
2000e438:	400e0000 	.word	0x400e0000
2000e43c:	400e0018 	.word	0x400e0018

2000e440 <ssp_init>:
			uint8_t serial_clock_rate,
			uint8_t clk_prescale,
			ssp_mode_t mode,
			ssp_master_slave_t master_slave,
			ssp_slave_option_t slave_option)
{
2000e440:	b5f0      	push	{r4, r5, r6, r7, lr}
2000e442:	465f      	mov	r7, fp
2000e444:	464d      	mov	r5, r9
2000e446:	4656      	mov	r6, sl
2000e448:	4644      	mov	r4, r8
2000e44a:	b4f0      	push	{r4, r5, r6, r7}
2000e44c:	b083      	sub	sp, #12
2000e44e:	469c      	mov	ip, r3
2000e450:	ab0c      	add	r3, sp, #48	; 0x30
2000e452:	781c      	ldrb	r4, [r3, #0]
2000e454:	ad0d      	add	r5, sp, #52	; 0x34
2000e456:	782e      	ldrb	r6, [r5, #0]
2000e458:	af0e      	add	r7, sp, #56	; 0x38
2000e45a:	46a3      	mov	fp, r4
2000e45c:	ac10      	add	r4, sp, #64	; 0x40
2000e45e:	46b1      	mov	r9, r6
2000e460:	783e      	ldrb	r6, [r7, #0]
2000e462:	7827      	ldrb	r7, [r4, #0]
2000e464:	ab0f      	add	r3, sp, #60	; 0x3c
2000e466:	781d      	ldrb	r5, [r3, #0]
2000e468:	9701      	str	r7, [sp, #4]
	uint32_t clock;

	if (ssp_num == SSP0_NUM)
	{
		ssp_port = SSP0;
		CGU_BASE_SSP0_CLK = CGU_BASE_SSP0_CLK_CLK_SEL(CGU_SRC_PLL1)
2000e46a:	4b1a      	ldr	r3, [pc, #104]	; (2000e4d4 <ssp_init+0x94>)
			ssp_slave_option_t slave_option)
{
	uint32_t ssp_port;
	uint32_t clock;

	if (ssp_num == SSP0_NUM)
2000e46c:	2800      	cmp	r0, #0
2000e46e:	d024      	beq.n	2000e4ba <ssp_init+0x7a>
		/* use PLL1 as clock source for SSP0 */
	} else
	{
		ssp_port = SSP1;
		/* use PLL1 as clock source for SSP1 */
		CGU_BASE_SSP1_CLK = CGU_BASE_SSP1_CLK_CLK_SEL(CGU_SRC_PLL1)
2000e470:	4819      	ldr	r0, [pc, #100]	; (2000e4d8 <ssp_init+0x98>)
			| CGU_BASE_SSP1_CLK_AUTOBLOCK;
		CCU1_CLK_M4_SSP1_CFG |= 1; /* Enable SSP1 Clock */
2000e472:	4f1a      	ldr	r7, [pc, #104]	; (2000e4dc <ssp_init+0x9c>)
		/* use PLL1 as clock source for SSP0 */
	} else
	{
		ssp_port = SSP1;
		/* use PLL1 as clock source for SSP1 */
		CGU_BASE_SSP1_CLK = CGU_BASE_SSP1_CLK_CLK_SEL(CGU_SRC_PLL1)
2000e474:	6003      	str	r3, [r0, #0]
			| CGU_BASE_SSP1_CLK_AUTOBLOCK;
		CCU1_CLK_M4_SSP1_CFG |= 1; /* Enable SSP1 Clock */
2000e476:	683c      	ldr	r4, [r7, #0]
2000e478:	2301      	movs	r3, #1
2000e47a:	4323      	orrs	r3, r4
2000e47c:	4c18      	ldr	r4, [pc, #96]	; (2000e4e0 <ssp_init+0xa0>)
2000e47e:	603b      	str	r3, [r7, #0]
2000e480:	4818      	ldr	r0, [pc, #96]	; (2000e4e4 <ssp_init+0xa4>)
2000e482:	4f19      	ldr	r7, [pc, #100]	; (2000e4e8 <ssp_init+0xa8>)
2000e484:	46a0      	mov	r8, r4
	}

	/* Disable SSP before to configure it */
	SSP_CR1(ssp_port) = 0x0;
2000e486:	2300      	movs	r3, #0
2000e488:	6003      	str	r3, [r0, #0]

	/* Configure SSP */
	clock = serial_clock_rate;
	SSP_CPSR(ssp_port) = clk_prescale;
2000e48a:	4644      	mov	r4, r8
2000e48c:	464b      	mov	r3, r9
2000e48e:	6023      	str	r3, [r4, #0]
	SSP_CR0(ssp_port) =
		(data_size | frame_format | cpol_cpha_format | (clock<<8));
2000e490:	4311      	orrs	r1, r2
2000e492:	465b      	mov	r3, fp
2000e494:	4662      	mov	r2, ip
2000e496:	021c      	lsls	r4, r3, #8
2000e498:	4311      	orrs	r1, r2
2000e49a:	4321      	orrs	r1, r4
	SSP_CR1(ssp_port) = 0x0;

	/* Configure SSP */
	clock = serial_clock_rate;
	SSP_CPSR(ssp_port) = clk_prescale;
	SSP_CR0(ssp_port) =
2000e49c:	6039      	str	r1, [r7, #0]
		(data_size | frame_format | cpol_cpha_format | (clock<<8));

	/* Enable SSP */
	SSP_CR1(ssp_port) = (SSP_ENABLE | mode | master_slave | slave_option);
2000e49e:	2102      	movs	r1, #2
2000e4a0:	4331      	orrs	r1, r6
2000e4a2:	9e01      	ldr	r6, [sp, #4]
2000e4a4:	4329      	orrs	r1, r5
2000e4a6:	4331      	orrs	r1, r6
2000e4a8:	b2cd      	uxtb	r5, r1
2000e4aa:	6005      	str	r5, [r0, #0]
}
2000e4ac:	b003      	add	sp, #12
2000e4ae:	bc3c      	pop	{r2, r3, r4, r5}
2000e4b0:	4690      	mov	r8, r2
2000e4b2:	4699      	mov	r9, r3
2000e4b4:	46a2      	mov	sl, r4
2000e4b6:	46ab      	mov	fp, r5
2000e4b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint32_t clock;

	if (ssp_num == SSP0_NUM)
	{
		ssp_port = SSP0;
		CGU_BASE_SSP0_CLK = CGU_BASE_SSP0_CLK_CLK_SEL(CGU_SRC_PLL1)
2000e4ba:	4f0c      	ldr	r7, [pc, #48]	; (2000e4ec <ssp_init+0xac>)
			| CGU_BASE_SSP0_CLK_AUTOBLOCK;
		CCU1_CLK_M4_SSP0_CFG |= 1; /* Enable SSP0 Clock */
2000e4bc:	480c      	ldr	r0, [pc, #48]	; (2000e4f0 <ssp_init+0xb0>)
	uint32_t clock;

	if (ssp_num == SSP0_NUM)
	{
		ssp_port = SSP0;
		CGU_BASE_SSP0_CLK = CGU_BASE_SSP0_CLK_CLK_SEL(CGU_SRC_PLL1)
2000e4be:	603b      	str	r3, [r7, #0]
			| CGU_BASE_SSP0_CLK_AUTOBLOCK;
		CCU1_CLK_M4_SSP0_CFG |= 1; /* Enable SSP0 Clock */
2000e4c0:	6803      	ldr	r3, [r0, #0]
2000e4c2:	2701      	movs	r7, #1
2000e4c4:	431f      	orrs	r7, r3
2000e4c6:	6007      	str	r7, [r0, #0]
2000e4c8:	480a      	ldr	r0, [pc, #40]	; (2000e4f4 <ssp_init+0xb4>)
2000e4ca:	4f0b      	ldr	r7, [pc, #44]	; (2000e4f8 <ssp_init+0xb8>)
2000e4cc:	4680      	mov	r8, r0
2000e4ce:	480b      	ldr	r0, [pc, #44]	; (2000e4fc <ssp_init+0xbc>)
2000e4d0:	e7d9      	b.n	2000e486 <ssp_init+0x46>
2000e4d2:	46c0      	nop			; (mov r8, r8)
2000e4d4:	09000800 	.word	0x09000800
2000e4d8:	40050098 	.word	0x40050098
2000e4dc:	40051628 	.word	0x40051628
2000e4e0:	400c5010 	.word	0x400c5010
2000e4e4:	400c5004 	.word	0x400c5004
2000e4e8:	400c5000 	.word	0x400c5000
2000e4ec:	40050094 	.word	0x40050094
2000e4f0:	40051518 	.word	0x40051518
2000e4f4:	40083010 	.word	0x40083010
2000e4f8:	40083000 	.word	0x40083000
2000e4fc:	40083004 	.word	0x40083004

2000e500 <ssp_transfer>:
	while ((SSP_SR(ssp_port) & SSP_SR_BSY));
}

/* This Function Wait Data TX Ready, and Write Data to SSP */
uint16_t ssp_transfer(ssp_num_t ssp_num, uint16_t data)
{
2000e500:	b530      	push	{r4, r5, lr}
	uint32_t ssp_port;

	if (ssp_num == SSP0_NUM) {
2000e502:	2800      	cmp	r0, #0
2000e504:	d116      	bne.n	2000e534 <ssp_transfer+0x34>
2000e506:	4d0d      	ldr	r5, [pc, #52]	; (2000e53c <ssp_transfer+0x3c>)
2000e508:	4b0d      	ldr	r3, [pc, #52]	; (2000e540 <ssp_transfer+0x40>)
	} else {
		ssp_port = SSP1;
	}

	/* Wait Until FIFO not full  */
	while ((SSP_SR(ssp_port) & SSP_SR_TNF) == 0);
2000e50a:	2402      	movs	r4, #2
2000e50c:	681a      	ldr	r2, [r3, #0]
2000e50e:	4214      	tst	r4, r2
2000e510:	d0fc      	beq.n	2000e50c <ssp_transfer+0xc>

	SSP_DR(ssp_port) = data;
2000e512:	6029      	str	r1, [r5, #0]

static void ssp_wait_until_not_busy(ssp_num_t ssp_num)
{
	uint32_t ssp_port;

	if (ssp_num == SSP0_NUM) {
2000e514:	2800      	cmp	r0, #0
2000e516:	d10b      	bne.n	2000e530 <ssp_transfer+0x30>
2000e518:	4809      	ldr	r0, [pc, #36]	; (2000e540 <ssp_transfer+0x40>)
		ssp_port = SSP0;
	} else {
		ssp_port = SSP1;
	}

	while ((SSP_SR(ssp_port) & SSP_SR_BSY));
2000e51a:	2110      	movs	r1, #16
2000e51c:	6804      	ldr	r4, [r0, #0]
2000e51e:	4221      	tst	r1, r4
2000e520:	d1fc      	bne.n	2000e51c <ssp_transfer+0x1c>
	 * example...
	 */
	ssp_wait_until_not_busy(ssp_num);

	/* Wait Until Data Received (Rx FIFO not Empty) */
	while ((SSP_SR(ssp_port) & SSP_SR_RNE) == 0);
2000e522:	2004      	movs	r0, #4
2000e524:	681a      	ldr	r2, [r3, #0]
2000e526:	4210      	tst	r0, r2
2000e528:	d0fc      	beq.n	2000e524 <ssp_transfer+0x24>

	return SSP_DR(ssp_port);
2000e52a:	682d      	ldr	r5, [r5, #0]
2000e52c:	b2a8      	uxth	r0, r5
}
2000e52e:	bd30      	pop	{r4, r5, pc}

static void ssp_wait_until_not_busy(ssp_num_t ssp_num)
{
	uint32_t ssp_port;

	if (ssp_num == SSP0_NUM) {
2000e530:	4804      	ldr	r0, [pc, #16]	; (2000e544 <ssp_transfer+0x44>)
2000e532:	e7f2      	b.n	2000e51a <ssp_transfer+0x1a>
/* This Function Wait Data TX Ready, and Write Data to SSP */
uint16_t ssp_transfer(ssp_num_t ssp_num, uint16_t data)
{
	uint32_t ssp_port;

	if (ssp_num == SSP0_NUM) {
2000e534:	4d04      	ldr	r5, [pc, #16]	; (2000e548 <ssp_transfer+0x48>)
2000e536:	4b03      	ldr	r3, [pc, #12]	; (2000e544 <ssp_transfer+0x44>)
2000e538:	e7e7      	b.n	2000e50a <ssp_transfer+0xa>
2000e53a:	46c0      	nop			; (mov r8, r8)
2000e53c:	40083008 	.word	0x40083008
2000e540:	4008300c 	.word	0x4008300c
2000e544:	400c500c 	.word	0x400c500c
2000e548:	400c5008 	.word	0x400c5008

2000e54c <blocking_handler>:
	}

}

void blocking_handler(void)
{
2000e54c:	e7fe      	b.n	2000e54c <blocking_handler>
2000e54e:	46c0      	nop			; (mov r8, r8)

2000e550 <null_handler>:
}

void null_handler(void)
{
	/* Do nothing. */
}
2000e550:	4770      	bx	lr
2000e552:	46c0      	nop			; (mov r8, r8)

2000e554 <reset_handler>:
void WEAK __attribute__ ((naked)) reset_handler(void)
{
	volatile unsigned *src, *dest;
	funcp_t *fp;

	for (src = &_data_loadaddr, dest = &_data;
2000e554:	4a4f      	ldr	r2, [pc, #316]	; (2000e694 <reset_handler+0x140>)
2000e556:	4b50      	ldr	r3, [pc, #320]	; (2000e698 <reset_handler+0x144>)
2000e558:	429a      	cmp	r2, r3
2000e55a:	d21f      	bcs.n	2000e59c <reset_handler+0x48>
	.irq = {
		IRQ_HANDLERS
	}
};

void WEAK __attribute__ ((naked)) reset_handler(void)
2000e55c:	1cdf      	adds	r7, r3, #3
2000e55e:	1d14      	adds	r4, r2, #4
2000e560:	1b38      	subs	r0, r7, r4
2000e562:	0881      	lsrs	r1, r0, #2
2000e564:	3101      	adds	r1, #1
2000e566:	008f      	lsls	r7, r1, #2
2000e568:	4b4c      	ldr	r3, [pc, #304]	; (2000e69c <reset_handler+0x148>)
2000e56a:	1f38      	subs	r0, r7, #4
2000e56c:	0741      	lsls	r1, r0, #29
2000e56e:	18fe      	adds	r6, r7, r3
2000e570:	0fc8      	lsrs	r0, r1, #31
	funcp_t *fp;

	for (src = &_data_loadaddr, dest = &_data;
		dest < &_edata;
		src++, dest++) {
		*dest = *src;
2000e572:	cb02      	ldmia	r3!, {r1}
2000e574:	6011      	str	r1, [r2, #0]
void WEAK __attribute__ ((naked)) reset_handler(void)
{
	volatile unsigned *src, *dest;
	funcp_t *fp;

	for (src = &_data_loadaddr, dest = &_data;
2000e576:	42b3      	cmp	r3, r6
2000e578:	d00f      	beq.n	2000e59a <reset_handler+0x46>
2000e57a:	2800      	cmp	r0, #0
2000e57c:	d003      	beq.n	2000e586 <reset_handler+0x32>
		dest < &_edata;
		src++, dest++) {
		*dest = *src;
2000e57e:	cb01      	ldmia	r3!, {r0}
2000e580:	c401      	stmia	r4!, {r0}
void WEAK __attribute__ ((naked)) reset_handler(void)
{
	volatile unsigned *src, *dest;
	funcp_t *fp;

	for (src = &_data_loadaddr, dest = &_data;
2000e582:	42b3      	cmp	r3, r6
2000e584:	d009      	beq.n	2000e59a <reset_handler+0x46>
		dest < &_edata;
		src++, dest++) {
		*dest = *src;
2000e586:	1c18      	adds	r0, r3, #0
2000e588:	c820      	ldmia	r0!, {r5}
2000e58a:	1c21      	adds	r1, r4, #0
2000e58c:	c120      	stmia	r1!, {r5}
2000e58e:	685b      	ldr	r3, [r3, #4]
2000e590:	6063      	str	r3, [r4, #4]
	volatile unsigned *src, *dest;
	funcp_t *fp;

	for (src = &_data_loadaddr, dest = &_data;
		dest < &_edata;
		src++, dest++) {
2000e592:	1d03      	adds	r3, r0, #4
2000e594:	1d0c      	adds	r4, r1, #4
void WEAK __attribute__ ((naked)) reset_handler(void)
{
	volatile unsigned *src, *dest;
	funcp_t *fp;

	for (src = &_data_loadaddr, dest = &_data;
2000e596:	42b3      	cmp	r3, r6
2000e598:	d1f5      	bne.n	2000e586 <reset_handler+0x32>
2000e59a:	19d2      	adds	r2, r2, r7
		dest < &_edata;
		src++, dest++) {
		*dest = *src;
	}

	while (dest < &_ebss) {
2000e59c:	4840      	ldr	r0, [pc, #256]	; (2000e6a0 <reset_handler+0x14c>)
2000e59e:	4282      	cmp	r2, r0
2000e5a0:	d216      	bcs.n	2000e5d0 <reset_handler+0x7c>
	.irq = {
		IRQ_HANDLERS
	}
};

void WEAK __attribute__ ((naked)) reset_handler(void)
2000e5a2:	1cc4      	adds	r4, r0, #3
2000e5a4:	1d13      	adds	r3, r2, #4
2000e5a6:	1ae5      	subs	r5, r4, r3
2000e5a8:	08a9      	lsrs	r1, r5, #2
2000e5aa:	3101      	adds	r1, #1
2000e5ac:	0088      	lsls	r0, r1, #2
2000e5ae:	1810      	adds	r0, r2, r0
2000e5b0:	1ac4      	subs	r4, r0, r3
		src++, dest++) {
		*dest = *src;
	}

	while (dest < &_ebss) {
		*dest++ = 0;
2000e5b2:	2100      	movs	r1, #0
2000e5b4:	0765      	lsls	r5, r4, #29
2000e5b6:	d508      	bpl.n	2000e5ca <reset_handler+0x76>
2000e5b8:	6011      	str	r1, [r2, #0]
2000e5ba:	1c1a      	adds	r2, r3, #0
2000e5bc:	3304      	adds	r3, #4
2000e5be:	6011      	str	r1, [r2, #0]
		dest < &_edata;
		src++, dest++) {
		*dest = *src;
	}

	while (dest < &_ebss) {
2000e5c0:	4283      	cmp	r3, r0
2000e5c2:	d005      	beq.n	2000e5d0 <reset_handler+0x7c>
		*dest++ = 0;
2000e5c4:	1d1a      	adds	r2, r3, #4
2000e5c6:	6019      	str	r1, [r3, #0]
2000e5c8:	1d13      	adds	r3, r2, #4
2000e5ca:	6011      	str	r1, [r2, #0]
		dest < &_edata;
		src++, dest++) {
		*dest = *src;
	}

	while (dest < &_ebss) {
2000e5cc:	4283      	cmp	r3, r0
2000e5ce:	d1f9      	bne.n	2000e5c4 <reset_handler+0x70>
		*dest++ = 0;
	}

	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
2000e5d0:	4834      	ldr	r0, [pc, #208]	; (2000e6a4 <reset_handler+0x150>)
2000e5d2:	4935      	ldr	r1, [pc, #212]	; (2000e6a8 <reset_handler+0x154>)
2000e5d4:	4288      	cmp	r0, r1
2000e5d6:	d21b      	bcs.n	2000e610 <reset_handler+0xbc>
	.irq = {
		IRQ_HANDLERS
	}
};

void WEAK __attribute__ ((naked)) reset_handler(void)
2000e5d8:	3103      	adds	r1, #3
2000e5da:	1d06      	adds	r6, r0, #4
2000e5dc:	1b8f      	subs	r7, r1, r6
2000e5de:	08bd      	lsrs	r5, r7, #2
2000e5e0:	2401      	movs	r4, #1
2000e5e2:	1c6f      	adds	r7, r5, #1
2000e5e4:	402c      	ands	r4, r5
		*dest++ = 0;
	}

	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
		(*fp)();
2000e5e6:	6802      	ldr	r2, [r0, #0]
2000e5e8:	2501      	movs	r5, #1
2000e5ea:	4790      	blx	r2
	while (dest < &_ebss) {
		*dest++ = 0;
	}

	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
2000e5ec:	42bd      	cmp	r5, r7
2000e5ee:	d00f      	beq.n	2000e610 <reset_handler+0xbc>
2000e5f0:	2c00      	cmp	r4, #0
2000e5f2:	d004      	beq.n	2000e5fe <reset_handler+0xaa>
		(*fp)();
2000e5f4:	ce08      	ldmia	r6!, {r3}
2000e5f6:	2502      	movs	r5, #2
2000e5f8:	4798      	blx	r3
	while (dest < &_ebss) {
		*dest++ = 0;
	}

	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
2000e5fa:	42bd      	cmp	r5, r7
2000e5fc:	d008      	beq.n	2000e610 <reset_handler+0xbc>
		(*fp)();
2000e5fe:	1c34      	adds	r4, r6, #0
2000e600:	cc01      	ldmia	r4!, {r0}
2000e602:	4780      	blx	r0
2000e604:	3502      	adds	r5, #2
2000e606:	6876      	ldr	r6, [r6, #4]
2000e608:	47b0      	blx	r6
	while (dest < &_ebss) {
		*dest++ = 0;
	}

	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
2000e60a:	1d26      	adds	r6, r4, #4
2000e60c:	42bd      	cmp	r5, r7
2000e60e:	d1f6      	bne.n	2000e5fe <reset_handler+0xaa>
		(*fp)();
	}
	for (fp = &__init_array_start; fp < &__init_array_end; fp++) {
2000e610:	4b26      	ldr	r3, [pc, #152]	; (2000e6ac <reset_handler+0x158>)
2000e612:	4927      	ldr	r1, [pc, #156]	; (2000e6b0 <reset_handler+0x15c>)
2000e614:	428b      	cmp	r3, r1
2000e616:	d21b      	bcs.n	2000e650 <reset_handler+0xfc>
	.irq = {
		IRQ_HANDLERS
	}
};

void WEAK __attribute__ ((naked)) reset_handler(void)
2000e618:	3103      	adds	r1, #3
2000e61a:	1d1e      	adds	r6, r3, #4
2000e61c:	1b8f      	subs	r7, r1, r6
2000e61e:	08bd      	lsrs	r5, r7, #2
2000e620:	2401      	movs	r4, #1
2000e622:	1c6f      	adds	r7, r5, #1
2000e624:	402c      	ands	r4, r5
	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
		(*fp)();
	}
	for (fp = &__init_array_start; fp < &__init_array_end; fp++) {
		(*fp)();
2000e626:	681a      	ldr	r2, [r3, #0]
2000e628:	2501      	movs	r5, #1
2000e62a:	4790      	blx	r2

	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
		(*fp)();
	}
	for (fp = &__init_array_start; fp < &__init_array_end; fp++) {
2000e62c:	42bd      	cmp	r5, r7
2000e62e:	d00f      	beq.n	2000e650 <reset_handler+0xfc>
2000e630:	2c00      	cmp	r4, #0
2000e632:	d004      	beq.n	2000e63e <reset_handler+0xea>
		(*fp)();
2000e634:	ce01      	ldmia	r6!, {r0}
2000e636:	2502      	movs	r5, #2
2000e638:	4780      	blx	r0

	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
		(*fp)();
	}
	for (fp = &__init_array_start; fp < &__init_array_end; fp++) {
2000e63a:	42bd      	cmp	r5, r7
2000e63c:	d008      	beq.n	2000e650 <reset_handler+0xfc>
		(*fp)();
2000e63e:	1c34      	adds	r4, r6, #0
2000e640:	cc08      	ldmia	r4!, {r3}
2000e642:	4798      	blx	r3
2000e644:	3502      	adds	r5, #2
2000e646:	6876      	ldr	r6, [r6, #4]
2000e648:	47b0      	blx	r6

	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
		(*fp)();
	}
	for (fp = &__init_array_start; fp < &__init_array_end; fp++) {
2000e64a:	1d26      	adds	r6, r4, #4
2000e64c:	42bd      	cmp	r5, r7
2000e64e:	d1f6      	bne.n	2000e63e <reset_handler+0xea>

	/* might be provided by platform specific vector.c */
	pre_main();

	/* Call the application's entry point. */
	main();
2000e650:	f7fd fdc8 	bl	2000c1e4 <main>

	/* Destructors. */
	for (fp = &__fini_array_start; fp < &__fini_array_end; fp++) {
2000e654:	4817      	ldr	r0, [pc, #92]	; (2000e6b4 <reset_handler+0x160>)
2000e656:	4918      	ldr	r1, [pc, #96]	; (2000e6b8 <reset_handler+0x164>)
2000e658:	4288      	cmp	r0, r1
2000e65a:	d21b      	bcs.n	2000e694 <reset_handler+0x140>
	.irq = {
		IRQ_HANDLERS
	}
};

void WEAK __attribute__ ((naked)) reset_handler(void)
2000e65c:	3103      	adds	r1, #3
2000e65e:	1d06      	adds	r6, r0, #4
2000e660:	1b8f      	subs	r7, r1, r6
2000e662:	08bd      	lsrs	r5, r7, #2
2000e664:	2401      	movs	r4, #1
2000e666:	1c6f      	adds	r7, r5, #1
2000e668:	402c      	ands	r4, r5
	/* Call the application's entry point. */
	main();

	/* Destructors. */
	for (fp = &__fini_array_start; fp < &__fini_array_end; fp++) {
		(*fp)();
2000e66a:	6802      	ldr	r2, [r0, #0]
2000e66c:	2501      	movs	r5, #1
2000e66e:	4790      	blx	r2

	/* Call the application's entry point. */
	main();

	/* Destructors. */
	for (fp = &__fini_array_start; fp < &__fini_array_end; fp++) {
2000e670:	42bd      	cmp	r5, r7
2000e672:	d00f      	beq.n	2000e694 <reset_handler+0x140>
2000e674:	2c00      	cmp	r4, #0
2000e676:	d004      	beq.n	2000e682 <reset_handler+0x12e>
		(*fp)();
2000e678:	ce08      	ldmia	r6!, {r3}
2000e67a:	2502      	movs	r5, #2
2000e67c:	4798      	blx	r3

	/* Call the application's entry point. */
	main();

	/* Destructors. */
	for (fp = &__fini_array_start; fp < &__fini_array_end; fp++) {
2000e67e:	42bd      	cmp	r5, r7
2000e680:	d008      	beq.n	2000e694 <reset_handler+0x140>
		(*fp)();
2000e682:	1c34      	adds	r4, r6, #0
2000e684:	cc01      	ldmia	r4!, {r0}
2000e686:	4780      	blx	r0
2000e688:	3502      	adds	r5, #2
2000e68a:	6876      	ldr	r6, [r6, #4]
2000e68c:	47b0      	blx	r6

	/* Call the application's entry point. */
	main();

	/* Destructors. */
	for (fp = &__fini_array_start; fp < &__fini_array_end; fp++) {
2000e68e:	1d26      	adds	r6, r4, #4
2000e690:	42bd      	cmp	r5, r7
2000e692:	d1f6      	bne.n	2000e682 <reset_handler+0x12e>
2000e694:	2000ef30 	.word	0x2000ef30
2000e698:	2000ef30 	.word	0x2000ef30
2000e69c:	2000ec6c 	.word	0x2000ec6c
2000e6a0:	2000fb04 	.word	0x2000fb04
2000e6a4:	2000ec6c 	.word	0x2000ec6c
2000e6a8:	2000ec6c 	.word	0x2000ec6c
2000e6ac:	2000ec6c 	.word	0x2000ec6c
2000e6b0:	2000ec6c 	.word	0x2000ec6c
2000e6b4:	2000ec6c 	.word	0x2000ec6c
2000e6b8:	2000ec6c 	.word	0x2000ec6c

2000e6bc <nvic_enable_irq>:
 * @param[in] irqn Unsigned int8. Interrupt number @ref nvic_stm32f1_userint
 */

void nvic_enable_irq(uint8_t irqn)
{
	NVIC_ISER(irqn / 32) = (1 << (irqn % 32));
2000e6bc:	0943      	lsrs	r3, r0, #5
2000e6be:	4a04      	ldr	r2, [pc, #16]	; (2000e6d0 <nvic_enable_irq+0x14>)
2000e6c0:	0099      	lsls	r1, r3, #2
2000e6c2:	188b      	adds	r3, r1, r2
2000e6c4:	211f      	movs	r1, #31
2000e6c6:	4008      	ands	r0, r1
2000e6c8:	2201      	movs	r2, #1
2000e6ca:	4082      	lsls	r2, r0
2000e6cc:	601a      	str	r2, [r3, #0]
}
2000e6ce:	4770      	bx	lr
2000e6d0:	e000e100 	.word	0xe000e100

2000e6d4 <nvic_set_priority>:
void nvic_set_priority(uint8_t irqn, uint8_t priority)
{
	/* code from lpc43xx/nvic.c -- this is quite a hack and alludes to the
	 * negative interrupt numbers assigned to the system interrupts. better
	 * handling would mean signed integers. */
	if (irqn >= NVIC_IRQ_COUNT) {
2000e6d4:	281f      	cmp	r0, #31
2000e6d6:	d803      	bhi.n	2000e6e0 <nvic_set_priority+0xc>
		/* Cortex-M  system interrupts */
		SCS_SHPR((irqn & 0xF) - 4) = priority;
	} else {
		/* Device specific interrupts */
		NVIC_IPR(irqn) = priority;
2000e6d8:	4b04      	ldr	r3, [pc, #16]	; (2000e6ec <nvic_set_priority+0x18>)
2000e6da:	18c0      	adds	r0, r0, r3
2000e6dc:	7001      	strb	r1, [r0, #0]
	}
}
2000e6de:	4770      	bx	lr
	/* code from lpc43xx/nvic.c -- this is quite a hack and alludes to the
	 * negative interrupt numbers assigned to the system interrupts. better
	 * handling would mean signed integers. */
	if (irqn >= NVIC_IRQ_COUNT) {
		/* Cortex-M  system interrupts */
		SCS_SHPR((irqn & 0xF) - 4) = priority;
2000e6e0:	220f      	movs	r2, #15
2000e6e2:	4b03      	ldr	r3, [pc, #12]	; (2000e6f0 <nvic_set_priority+0x1c>)
2000e6e4:	4010      	ands	r0, r2
2000e6e6:	18c0      	adds	r0, r0, r3
2000e6e8:	7001      	strb	r1, [r0, #0]
2000e6ea:	e7f8      	b.n	2000e6de <nvic_set_priority+0xa>
2000e6ec:	e000e400 	.word	0xe000e400
2000e6f0:	e000ed14 	.word	0xe000ed14

2000e6f4 <__gnu_thumb1_case_uqi>:
2000e6f4:	b402      	push	{r1}
2000e6f6:	4671      	mov	r1, lr
2000e6f8:	0849      	lsrs	r1, r1, #1
2000e6fa:	0049      	lsls	r1, r1, #1
2000e6fc:	5c09      	ldrb	r1, [r1, r0]
2000e6fe:	0049      	lsls	r1, r1, #1
2000e700:	448e      	add	lr, r1
2000e702:	bc02      	pop	{r1}
2000e704:	4770      	bx	lr
2000e706:	46c0      	nop			; (mov r8, r8)

2000e708 <__aeabi_uidiv>:
2000e708:	2900      	cmp	r1, #0
2000e70a:	d034      	beq.n	2000e776 <.udivsi3_skip_div0_test+0x6a>

2000e70c <.udivsi3_skip_div0_test>:
2000e70c:	2301      	movs	r3, #1
2000e70e:	2200      	movs	r2, #0
2000e710:	b410      	push	{r4}
2000e712:	4288      	cmp	r0, r1
2000e714:	d32c      	bcc.n	2000e770 <.udivsi3_skip_div0_test+0x64>
2000e716:	2401      	movs	r4, #1
2000e718:	0724      	lsls	r4, r4, #28
2000e71a:	42a1      	cmp	r1, r4
2000e71c:	d204      	bcs.n	2000e728 <.udivsi3_skip_div0_test+0x1c>
2000e71e:	4281      	cmp	r1, r0
2000e720:	d202      	bcs.n	2000e728 <.udivsi3_skip_div0_test+0x1c>
2000e722:	0109      	lsls	r1, r1, #4
2000e724:	011b      	lsls	r3, r3, #4
2000e726:	e7f8      	b.n	2000e71a <.udivsi3_skip_div0_test+0xe>
2000e728:	00e4      	lsls	r4, r4, #3
2000e72a:	42a1      	cmp	r1, r4
2000e72c:	d204      	bcs.n	2000e738 <.udivsi3_skip_div0_test+0x2c>
2000e72e:	4281      	cmp	r1, r0
2000e730:	d202      	bcs.n	2000e738 <.udivsi3_skip_div0_test+0x2c>
2000e732:	0049      	lsls	r1, r1, #1
2000e734:	005b      	lsls	r3, r3, #1
2000e736:	e7f8      	b.n	2000e72a <.udivsi3_skip_div0_test+0x1e>
2000e738:	4288      	cmp	r0, r1
2000e73a:	d301      	bcc.n	2000e740 <.udivsi3_skip_div0_test+0x34>
2000e73c:	1a40      	subs	r0, r0, r1
2000e73e:	431a      	orrs	r2, r3
2000e740:	084c      	lsrs	r4, r1, #1
2000e742:	42a0      	cmp	r0, r4
2000e744:	d302      	bcc.n	2000e74c <.udivsi3_skip_div0_test+0x40>
2000e746:	1b00      	subs	r0, r0, r4
2000e748:	085c      	lsrs	r4, r3, #1
2000e74a:	4322      	orrs	r2, r4
2000e74c:	088c      	lsrs	r4, r1, #2
2000e74e:	42a0      	cmp	r0, r4
2000e750:	d302      	bcc.n	2000e758 <.udivsi3_skip_div0_test+0x4c>
2000e752:	1b00      	subs	r0, r0, r4
2000e754:	089c      	lsrs	r4, r3, #2
2000e756:	4322      	orrs	r2, r4
2000e758:	08cc      	lsrs	r4, r1, #3
2000e75a:	42a0      	cmp	r0, r4
2000e75c:	d302      	bcc.n	2000e764 <.udivsi3_skip_div0_test+0x58>
2000e75e:	1b00      	subs	r0, r0, r4
2000e760:	08dc      	lsrs	r4, r3, #3
2000e762:	4322      	orrs	r2, r4
2000e764:	2800      	cmp	r0, #0
2000e766:	d003      	beq.n	2000e770 <.udivsi3_skip_div0_test+0x64>
2000e768:	091b      	lsrs	r3, r3, #4
2000e76a:	d001      	beq.n	2000e770 <.udivsi3_skip_div0_test+0x64>
2000e76c:	0909      	lsrs	r1, r1, #4
2000e76e:	e7e3      	b.n	2000e738 <.udivsi3_skip_div0_test+0x2c>
2000e770:	1c10      	adds	r0, r2, #0
2000e772:	bc10      	pop	{r4}
2000e774:	4770      	bx	lr
2000e776:	2800      	cmp	r0, #0
2000e778:	d001      	beq.n	2000e77e <.udivsi3_skip_div0_test+0x72>
2000e77a:	2000      	movs	r0, #0
2000e77c:	43c0      	mvns	r0, r0
2000e77e:	b407      	push	{r0, r1, r2}
2000e780:	4802      	ldr	r0, [pc, #8]	; (2000e78c <.udivsi3_skip_div0_test+0x80>)
2000e782:	a102      	add	r1, pc, #8	; (adr r1, 2000e78c <.udivsi3_skip_div0_test+0x80>)
2000e784:	1840      	adds	r0, r0, r1
2000e786:	9002      	str	r0, [sp, #8]
2000e788:	bd03      	pop	{r0, r1, pc}
2000e78a:	46c0      	nop			; (mov r8, r8)
2000e78c:	00000019 	.word	0x00000019

2000e790 <__aeabi_uidivmod>:
2000e790:	2900      	cmp	r1, #0
2000e792:	d0f0      	beq.n	2000e776 <.udivsi3_skip_div0_test+0x6a>
2000e794:	b503      	push	{r0, r1, lr}
2000e796:	f7ff ffb9 	bl	2000e70c <.udivsi3_skip_div0_test>
2000e79a:	bc0e      	pop	{r1, r2, r3}
2000e79c:	4342      	muls	r2, r0
2000e79e:	1a89      	subs	r1, r1, r2
2000e7a0:	4718      	bx	r3
2000e7a2:	46c0      	nop			; (mov r8, r8)

2000e7a4 <__aeabi_idiv0>:
2000e7a4:	4770      	bx	lr
2000e7a6:	46c0      	nop			; (mov r8, r8)

2000e7a8 <__aeabi_lmul>:
2000e7a8:	469c      	mov	ip, r3
2000e7aa:	0403      	lsls	r3, r0, #16
2000e7ac:	b5f0      	push	{r4, r5, r6, r7, lr}
2000e7ae:	0c1b      	lsrs	r3, r3, #16
2000e7b0:	0417      	lsls	r7, r2, #16
2000e7b2:	0c3f      	lsrs	r7, r7, #16
2000e7b4:	0c15      	lsrs	r5, r2, #16
2000e7b6:	1c1e      	adds	r6, r3, #0
2000e7b8:	1c04      	adds	r4, r0, #0
2000e7ba:	0c00      	lsrs	r0, r0, #16
2000e7bc:	437e      	muls	r6, r7
2000e7be:	436b      	muls	r3, r5
2000e7c0:	4347      	muls	r7, r0
2000e7c2:	4345      	muls	r5, r0
2000e7c4:	18fb      	adds	r3, r7, r3
2000e7c6:	0c30      	lsrs	r0, r6, #16
2000e7c8:	1818      	adds	r0, r3, r0
2000e7ca:	4287      	cmp	r7, r0
2000e7cc:	d902      	bls.n	2000e7d4 <__aeabi_lmul+0x2c>
2000e7ce:	2780      	movs	r7, #128	; 0x80
2000e7d0:	027b      	lsls	r3, r7, #9
2000e7d2:	18ed      	adds	r5, r5, r3
2000e7d4:	0c07      	lsrs	r7, r0, #16
2000e7d6:	19ed      	adds	r5, r5, r7
2000e7d8:	4667      	mov	r7, ip
2000e7da:	437c      	muls	r4, r7
2000e7dc:	434a      	muls	r2, r1
2000e7de:	0436      	lsls	r6, r6, #16
2000e7e0:	0c33      	lsrs	r3, r6, #16
2000e7e2:	18a1      	adds	r1, r4, r2
2000e7e4:	0400      	lsls	r0, r0, #16
2000e7e6:	1949      	adds	r1, r1, r5
2000e7e8:	18c0      	adds	r0, r0, r3
2000e7ea:	bdf0      	pop	{r4, r5, r6, r7, pc}

2000e7ec <memcpy>:
2000e7ec:	b5f0      	push	{r4, r5, r6, r7, lr}
2000e7ee:	464f      	mov	r7, r9
2000e7f0:	4646      	mov	r6, r8
2000e7f2:	b4c0      	push	{r6, r7}
2000e7f4:	2a0f      	cmp	r2, #15
2000e7f6:	d972      	bls.n	2000e8de <memcpy+0xf2>
2000e7f8:	1c0b      	adds	r3, r1, #0
2000e7fa:	4303      	orrs	r3, r0
2000e7fc:	079c      	lsls	r4, r3, #30
2000e7fe:	d000      	beq.n	2000e802 <memcpy+0x16>
2000e800:	e090      	b.n	2000e924 <memcpy+0x138>
2000e802:	1c17      	adds	r7, r2, #0
2000e804:	3f10      	subs	r7, #16
2000e806:	093c      	lsrs	r4, r7, #4
2000e808:	3401      	adds	r4, #1
2000e80a:	0127      	lsls	r7, r4, #4
2000e80c:	680c      	ldr	r4, [r1, #0]
2000e80e:	1c3b      	adds	r3, r7, #0
2000e810:	6004      	str	r4, [r0, #0]
2000e812:	3b10      	subs	r3, #16
2000e814:	06de      	lsls	r6, r3, #27
2000e816:	684b      	ldr	r3, [r1, #4]
2000e818:	19cd      	adds	r5, r1, r7
2000e81a:	6043      	str	r3, [r0, #4]
2000e81c:	688c      	ldr	r4, [r1, #8]
2000e81e:	0ff6      	lsrs	r6, r6, #31
2000e820:	6084      	str	r4, [r0, #8]
2000e822:	68cb      	ldr	r3, [r1, #12]
2000e824:	1c04      	adds	r4, r0, #0
2000e826:	60c3      	str	r3, [r0, #12]
2000e828:	1c0b      	adds	r3, r1, #0
2000e82a:	3310      	adds	r3, #16
2000e82c:	3410      	adds	r4, #16
2000e82e:	429d      	cmp	r5, r3
2000e830:	d027      	beq.n	2000e882 <memcpy+0x96>
2000e832:	2e00      	cmp	r6, #0
2000e834:	d00b      	beq.n	2000e84e <memcpy+0x62>
2000e836:	6819      	ldr	r1, [r3, #0]
2000e838:	6021      	str	r1, [r4, #0]
2000e83a:	685e      	ldr	r6, [r3, #4]
2000e83c:	6066      	str	r6, [r4, #4]
2000e83e:	6899      	ldr	r1, [r3, #8]
2000e840:	60a1      	str	r1, [r4, #8]
2000e842:	68de      	ldr	r6, [r3, #12]
2000e844:	3310      	adds	r3, #16
2000e846:	60e6      	str	r6, [r4, #12]
2000e848:	3410      	adds	r4, #16
2000e84a:	429d      	cmp	r5, r3
2000e84c:	d019      	beq.n	2000e882 <memcpy+0x96>
2000e84e:	6819      	ldr	r1, [r3, #0]
2000e850:	6021      	str	r1, [r4, #0]
2000e852:	685e      	ldr	r6, [r3, #4]
2000e854:	6066      	str	r6, [r4, #4]
2000e856:	6899      	ldr	r1, [r3, #8]
2000e858:	60a1      	str	r1, [r4, #8]
2000e85a:	68de      	ldr	r6, [r3, #12]
2000e85c:	1c19      	adds	r1, r3, #0
2000e85e:	60e6      	str	r6, [r4, #12]
2000e860:	691b      	ldr	r3, [r3, #16]
2000e862:	1c26      	adds	r6, r4, #0
2000e864:	6123      	str	r3, [r4, #16]
2000e866:	694c      	ldr	r4, [r1, #20]
2000e868:	6174      	str	r4, [r6, #20]
2000e86a:	698b      	ldr	r3, [r1, #24]
2000e86c:	61b3      	str	r3, [r6, #24]
2000e86e:	69cc      	ldr	r4, [r1, #28]
2000e870:	3110      	adds	r1, #16
2000e872:	61f4      	str	r4, [r6, #28]
2000e874:	1c0b      	adds	r3, r1, #0
2000e876:	3610      	adds	r6, #16
2000e878:	1c34      	adds	r4, r6, #0
2000e87a:	3310      	adds	r3, #16
2000e87c:	3410      	adds	r4, #16
2000e87e:	429d      	cmp	r5, r3
2000e880:	d1e5      	bne.n	2000e84e <memcpy+0x62>
2000e882:	183f      	adds	r7, r7, r0
2000e884:	210f      	movs	r1, #15
2000e886:	46b8      	mov	r8, r7
2000e888:	4011      	ands	r1, r2
2000e88a:	2903      	cmp	r1, #3
2000e88c:	d94d      	bls.n	2000e92a <memcpy+0x13e>
2000e88e:	3904      	subs	r1, #4
2000e890:	088e      	lsrs	r6, r1, #2
2000e892:	00b3      	lsls	r3, r6, #2
2000e894:	3304      	adds	r3, #4
2000e896:	18ec      	adds	r4, r5, r3
2000e898:	46a4      	mov	ip, r4
2000e89a:	3b04      	subs	r3, #4
2000e89c:	1c2c      	adds	r4, r5, #0
2000e89e:	075f      	lsls	r7, r3, #29
2000e8a0:	cc08      	ldmia	r4!, {r3}
2000e8a2:	4641      	mov	r1, r8
2000e8a4:	46b1      	mov	r9, r6
2000e8a6:	c108      	stmia	r1!, {r3}
2000e8a8:	0ffe      	lsrs	r6, r7, #31
2000e8aa:	4564      	cmp	r4, ip
2000e8ac:	d00f      	beq.n	2000e8ce <memcpy+0xe2>
2000e8ae:	2e00      	cmp	r6, #0
2000e8b0:	d003      	beq.n	2000e8ba <memcpy+0xce>
2000e8b2:	cc80      	ldmia	r4!, {r7}
2000e8b4:	c180      	stmia	r1!, {r7}
2000e8b6:	4564      	cmp	r4, ip
2000e8b8:	d009      	beq.n	2000e8ce <memcpy+0xe2>
2000e8ba:	1c27      	adds	r7, r4, #0
2000e8bc:	cf08      	ldmia	r7!, {r3}
2000e8be:	1c0e      	adds	r6, r1, #0
2000e8c0:	c608      	stmia	r6!, {r3}
2000e8c2:	6864      	ldr	r4, [r4, #4]
2000e8c4:	604c      	str	r4, [r1, #4]
2000e8c6:	1d3c      	adds	r4, r7, #4
2000e8c8:	1d31      	adds	r1, r6, #4
2000e8ca:	4564      	cmp	r4, ip
2000e8cc:	d1f5      	bne.n	2000e8ba <memcpy+0xce>
2000e8ce:	4649      	mov	r1, r9
2000e8d0:	3101      	adds	r1, #1
2000e8d2:	008e      	lsls	r6, r1, #2
2000e8d4:	2703      	movs	r7, #3
2000e8d6:	19ad      	adds	r5, r5, r6
2000e8d8:	403a      	ands	r2, r7
2000e8da:	4446      	add	r6, r8
2000e8dc:	e001      	b.n	2000e8e2 <memcpy+0xf6>
2000e8de:	1c0d      	adds	r5, r1, #0
2000e8e0:	1c06      	adds	r6, r0, #0
2000e8e2:	2a00      	cmp	r2, #0
2000e8e4:	d01a      	beq.n	2000e91c <memcpy+0x130>
2000e8e6:	782f      	ldrb	r7, [r5, #0]
2000e8e8:	18b2      	adds	r2, r6, r2
2000e8ea:	43f3      	mvns	r3, r6
2000e8ec:	18d1      	adds	r1, r2, r3
2000e8ee:	2401      	movs	r4, #1
2000e8f0:	7037      	strb	r7, [r6, #0]
2000e8f2:	3601      	adds	r6, #1
2000e8f4:	400c      	ands	r4, r1
2000e8f6:	3501      	adds	r5, #1
2000e8f8:	4296      	cmp	r6, r2
2000e8fa:	d00f      	beq.n	2000e91c <memcpy+0x130>
2000e8fc:	2c00      	cmp	r4, #0
2000e8fe:	d005      	beq.n	2000e90c <memcpy+0x120>
2000e900:	782b      	ldrb	r3, [r5, #0]
2000e902:	3501      	adds	r5, #1
2000e904:	7033      	strb	r3, [r6, #0]
2000e906:	3601      	adds	r6, #1
2000e908:	4296      	cmp	r6, r2
2000e90a:	d007      	beq.n	2000e91c <memcpy+0x130>
2000e90c:	7829      	ldrb	r1, [r5, #0]
2000e90e:	7031      	strb	r1, [r6, #0]
2000e910:	786c      	ldrb	r4, [r5, #1]
2000e912:	3502      	adds	r5, #2
2000e914:	7074      	strb	r4, [r6, #1]
2000e916:	3602      	adds	r6, #2
2000e918:	4296      	cmp	r6, r2
2000e91a:	d1f7      	bne.n	2000e90c <memcpy+0x120>
2000e91c:	bc0c      	pop	{r2, r3}
2000e91e:	4690      	mov	r8, r2
2000e920:	4699      	mov	r9, r3
2000e922:	bdf0      	pop	{r4, r5, r6, r7, pc}
2000e924:	1c06      	adds	r6, r0, #0
2000e926:	1c0d      	adds	r5, r1, #0
2000e928:	e7dd      	b.n	2000e8e6 <memcpy+0xfa>
2000e92a:	1c3e      	adds	r6, r7, #0
2000e92c:	1c0a      	adds	r2, r1, #0
2000e92e:	e7d8      	b.n	2000e8e2 <memcpy+0xf6>

2000e930 <strcpy>:
2000e930:	1c03      	adds	r3, r0, #0
2000e932:	780a      	ldrb	r2, [r1, #0]
2000e934:	3101      	adds	r1, #1
2000e936:	701a      	strb	r2, [r3, #0]
2000e938:	3301      	adds	r3, #1
2000e93a:	2a00      	cmp	r2, #0
2000e93c:	d1f9      	bne.n	2000e932 <strcpy+0x2>
2000e93e:	4770      	bx	lr

2000e940 <strlen>:
2000e940:	2300      	movs	r3, #0
2000e942:	5cc2      	ldrb	r2, [r0, r3]
2000e944:	3301      	adds	r3, #1
2000e946:	2a00      	cmp	r2, #0
2000e948:	d1fb      	bne.n	2000e942 <strlen+0x2>
2000e94a:	1e58      	subs	r0, r3, #1
2000e94c:	4770      	bx	lr
2000e94e:	46c0      	nop			; (mov r8, r8)

2000e950 <version_string>:
2000e950:	7620 2e31 2e30 2d30 6372 3031 342d 672d      v1.0.0-rc10-4-g
2000e960:	6138 3735 6435 2d36 6964 7472 2079 3032     8a575d6-dirty 20
2000e970:	3032 302d 2d35 3730 0000 0000               20-05-07....

2000e97c <usb_request_handlers>:
2000e97c:	dfbd 2000 0000 0000 c305 2000 0000 0000     ... ....... ....

2000e98c <usb_descriptor_strings>:
2000e98c:	ed1f 2000 ed23 2000 ed74 2000 ecd7 2000     ... #.. t.. ... 
2000e99c:	0000 0000                                   ....

2000e9a0 <htoa>:
2000e9a0:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
2000e9b0:	80e0 0060 0e0f 0c0d 0a0b 0809 0607 0405     ..`.............
2000e9c0:	0203 0001                                   ....

2000e9c4 <freq_to_idx>:
2000e9c4:	0101 0101 0201 0202 0202 0303 0303 0403     ................
2000e9d4:	0404 0404 0505 0505 0605 0606 0606 0707     ................
2000e9e4:	0707 0707 0707 0707 0808 0808 0808 0808     ................
2000e9f4:	0808 0909 0909 0909 0909 0909 0a0a 0a0a     ................
2000ea04:	0a0a 0a0a 0a0a 0b0b 0b0b 0b0b 0b0b 0b0b     ................
2000ea14:	0b0b 0b0b 0b0b 0b0b 0b0b 0c0c 0c0c 0c0c     ................
2000ea24:	0c0c 0c0c 0c0c 0c0c 0c0c 0c0c 0c0c 0c0c     ................
2000ea34:	0c0c 0c0c 0c0c 0c0c 0c0c 0c0c 0c0c 0c0c     ................
2000ea44:	0c0c 0d0d 0d0d 0d0d 0d0d 0d0d 0d0d 0d0d     ................
2000ea54:	0d0d 0d0d 0d0d 0d0d 0d0d 0d0d 0d0d 0d0d     ................
2000ea64:	0d0d 0d0d 0d0d 0d0d 0d0d 0e0e 0e0e 0e0e     ................
2000ea74:	0e0e 0e0e 0e0e 0e0e 0e0e 0e0e 0e0e 0e0e     ................
2000ea84:	0e0e 0e0e 0e0e 0e0e 0f0f 0f0f 0f0f 0f0f     ................
2000ea94:	0f0f 0f0f 0f0f 0f0f 0f0f 0f0f 0f0f 0f0f     ................
2000eaa4:	0f0f 0f0f 0f0f 1010 1010 1010 1010 1010     ................
2000eab4:	1010 1010 1010 1010 1010 1010 1010 1010     ................
2000eac4:	1010 1010 1111 1111 1111 1111 1111 1111     ................
2000ead4:	1111 1111 1111 1111 1111 1111 1111 1111     ................
2000eae4:	1111 1111 1111 1111 1111 1111 1111 1111     ................
2000eaf4:	1111 1111 1111 1111 1111 1111 1111 1111     ................
2000eb04:	1111 1111 1111 1111 1111 1111 1111 1111     ................
2000eb14:	1111 1111 1111 1111 1111 1111 1111 1111     ................
2000eb24:	1111 1111 1111 1111 1111 1111 1111 1111     ................
2000eb34:	1111 1111 1111 1111 1111 1111 1111 1111     ................
2000eb44:	1111 1111 1111 1111 1111 1111 1111 1111     ................
2000eb54:	1212 1212 1212 1212 1212 1212 1212 1212     ................
2000eb64:	1212 1212 1212 1212 1212 1212 1212 1212     ................
2000eb74:	1212 1212 1212 1212 1212 1212 1212 1212     ................
2000eb84:	1212 1212 1212 1212 1212 1212 1212 1212     ................
2000eb94:	1212 1212 1212 1212 1212 1212 1212 1212     ................
2000eba4:	1212 1212 1212 1212 1212 1212 1212 1212     ................
2000ebb4:	1212 1212 1212 1212 1212 1212 1212 1212     ................
2000ebc4:	1212 1212 1212 1212 1212 1212 1212 1212     ................
2000ebd4:	1212 1212 1212 1212 1212 1313 1313 1313     ................
2000ebe4:	1313 1313 1313 1313 1313 1313 1313 1313     ................
2000ebf4:	1313 1313 1313 1313 1313 1313 1313 1313     ................
2000ec04:	1313 1313 1313 1313 1313 1313 1313 1313     ................
2000ec14:	1313 1313 1313 1313                         ........

2000ec1c <freq_ranges>:
2000ec1c:	0208 08df be02 0208 088b 7b02 0208 0869     ...........{..i.
2000ec2c:	5802 0200 0044 4402 0200 0034 3402 0200     .X..D..D..4..4..
2000ec3c:	0024 2402 0200 0014 1302 0200 0013 1102     $..$............
2000ec4c:	0200 0000 0041 4100 0000 0040 4000 0000          ....A..A..@..@.

2000ec5b <lut>:
2000ec5b:	0800 0c04 0a02 0e06 0901 0d05 0b03 0f07     ................
	...
